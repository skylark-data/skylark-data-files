{"version":3,"sources":["skylark-data-files.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-data-files.js","sourcesContent":["define('skylark-data-files/files',[],function(){\r\n\t\r\n});\ndefine('skylark-data-files/action-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  var ActionType;\r\n  (function (ActionType) {\r\n      // Indicates that the code should not do anything.\r\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\r\n      // Indicates that the code should throw an exception.\r\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\r\n      // Indicates that the code should truncate the file, but only if it is a file.\r\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\r\n      // Indicates that the code should create the file.\r\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\r\n  })(ActionType || (ActionType = {}));\r\n\r\n  return files.ActionType = ActionType;\r\n});\r\n  \ndefine('skylark-data-files/error-codes',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Standard libc error codes. Add more to this enum and ErrorStrings as they are\r\n   * needed.\r\n   * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\r\n   */\r\n  var ErrorCodes;\r\n  (function (ErrorCodes) {\r\n      ErrorCodes[ErrorCodes[\"EPERM\"] = 1] = \"EPERM\";\r\n      ErrorCodes[ErrorCodes[\"ENOENT\"] = 2] = \"ENOENT\";\r\n      ErrorCodes[ErrorCodes[\"EIO\"] = 5] = \"EIO\";\r\n      ErrorCodes[ErrorCodes[\"EBADF\"] = 9] = \"EBADF\";\r\n      ErrorCodes[ErrorCodes[\"EACCES\"] = 13] = \"EACCES\";\r\n      ErrorCodes[ErrorCodes[\"EBUSY\"] = 16] = \"EBUSY\";\r\n      ErrorCodes[ErrorCodes[\"EEXIST\"] = 17] = \"EEXIST\";\r\n      ErrorCodes[ErrorCodes[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\r\n      ErrorCodes[ErrorCodes[\"EISDIR\"] = 21] = \"EISDIR\";\r\n      ErrorCodes[ErrorCodes[\"EINVAL\"] = 22] = \"EINVAL\";\r\n      ErrorCodes[ErrorCodes[\"EFBIG\"] = 27] = \"EFBIG\";\r\n      ErrorCodes[ErrorCodes[\"ENOSPC\"] = 28] = \"ENOSPC\";\r\n      ErrorCodes[ErrorCodes[\"EROFS\"] = 30] = \"EROFS\";\r\n      ErrorCodes[ErrorCodes[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\r\n      ErrorCodes[ErrorCodes[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\r\n  })(ErrorCodes || (ErrorCodes = {}));\r\n\r\n  return files.ErrorCodes = ErrorCodes;\r\n});\r\n  \ndefine('skylark-data-files/error-strings',[\r\n  \"./files\",\r\n  \"./error-codes\"\r\n],function (files,ErrorCodes) {\r\n  'use strict';\r\n\r\n  /* tslint:disable:variable-name */\r\n  /**\r\n   * Strings associated with each error code.\r\n   * @hidden\r\n   */\r\n  const ErrorStrings = {};\r\n  ErrorStrings[ErrorCodes.EPERM] = 'Operation not permitted.';\r\n  ErrorStrings[ErrorCodes.ENOENT] = 'No such file or directory.';\r\n  ErrorStrings[ErrorCodes.EIO] = 'Input/output error.';\r\n  ErrorStrings[ErrorCodes.EBADF] = 'Bad file descriptor.';\r\n  ErrorStrings[ErrorCodes.EACCES] = 'Permission denied.';\r\n  ErrorStrings[ErrorCodes.EBUSY] = 'Resource busy or locked.';\r\n  ErrorStrings[ErrorCodes.EEXIST] = 'File exists.';\r\n  ErrorStrings[ErrorCodes.ENOTDIR] = 'File is not a directory.';\r\n  ErrorStrings[ErrorCodes.EISDIR] = 'File is a directory.';\r\n  ErrorStrings[ErrorCodes.EINVAL] = 'Invalid argument.';\r\n  ErrorStrings[ErrorCodes.EFBIG] = 'File is too big.';\r\n  ErrorStrings[ErrorCodes.ENOSPC] = 'No space left on disk.';\r\n  ErrorStrings[ErrorCodes.EROFS] = 'Cannot modify a read-only file system.';\r\n  ErrorStrings[ErrorCodes.ENOTEMPTY] = 'Directory is not empty.';\r\n  ErrorStrings[ErrorCodes.ENOTSUP] = 'Operation is not supported.';\r\n\r\n  return files.ErrorStrings = ErrorStrings;\r\n});\r\n  \ndefine('skylark-data-files/file-error',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    \"./error-strings\"\r\n],function (Buffer,files,ErrorCodes,ErrorStrings) {\r\n   'use strict';\r\n   \r\n\r\n    /* tslint:enable:variable-name */\r\n    /**\r\n     * Represents a BrowserFS error. Passed back to applications after a failed\r\n     * call to the BrowserFS API.\r\n     */\r\n    class FileError extends Error {\r\n        /**\r\n         * Represents a BrowserFS error. Passed back to applications after a failed\r\n         * call to the BrowserFS API.\r\n         *\r\n         * Error codes mirror those returned by regular Unix file operations, which is\r\n         * what Node returns.\r\n         * @constructor FileError\r\n         * @param type The type of the error.\r\n         * @param [message] A descriptive error message.\r\n         */\r\n        constructor(type, message = ErrorStrings[type], path) {\r\n            super(message);\r\n            // Unsupported.\r\n            this.syscall = \"\";\r\n            this.errno = type;\r\n            this.code = ErrorCodes[type];\r\n            this.path = path;\r\n            this.stack = new Error().stack;\r\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\r\n        }\r\n        static fromJSON(json) {\r\n            const err = new FileError(0);\r\n            err.errno = json.errno;\r\n            err.code = json.code;\r\n            err.path = json.path;\r\n            err.stack = json.stack;\r\n            err.message = json.message;\r\n            return err;\r\n        }\r\n        /**\r\n         * Creates an FileError object from a buffer.\r\n         */\r\n        static fromBuffer(buffer, i = 0) {\r\n            return FileError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\r\n        }\r\n        static create(code, p) {\r\n            return new FileError(code, ErrorStrings[code], p);\r\n        }\r\n        static ENOENT(path) {\r\n            return this.create(ErrorCodes.ENOENT, path);\r\n        }\r\n        static EEXIST(path) {\r\n            return this.create(ErrorCodes.EEXIST, path);\r\n        }\r\n        static EISDIR(path) {\r\n            return this.create(ErrorCodes.EISDIR, path);\r\n        }\r\n        static ENOTDIR(path) {\r\n            return this.create(ErrorCodes.ENOTDIR, path);\r\n        }\r\n        static EPERM(path) {\r\n            return this.create(ErrorCodes.EPERM, path);\r\n        }\r\n        static ENOTEMPTY(path) {\r\n            return this.create(ErrorCodes.ENOTEMPTY, path);\r\n        }\r\n        /**\r\n         * @return A friendly error message.\r\n         */\r\n        toString() {\r\n            return this.message;\r\n        }\r\n        toJSON() {\r\n            return {\r\n                errno: this.errno,\r\n                code: this.code,\r\n                path: this.path,\r\n                stack: this.stack,\r\n                message: this.message\r\n            };\r\n        }\r\n        /**\r\n         * Writes the API error into a buffer.\r\n         */\r\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\r\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\r\n            buffer.writeUInt32LE(bytesWritten, i);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * The size of the API error in buffer-form in bytes.\r\n         */\r\n        bufferSize() {\r\n            // 4 bytes for string length.\r\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\r\n        }\r\n    }\r\n\r\n    return files.FileError = FileError;\r\n\r\n});\ndefine('skylark-data-files/base-file',[\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\"\r\n], function (files,ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Base class that contains shared implementations of functions for the file\r\n     * object.\r\n     */\r\n    class BaseFile {\r\n        sync(cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        datasync(cb) {\r\n            this.sync(cb);\r\n        }\r\n        datasyncSync() {\r\n            return this.syncSync();\r\n        }\r\n        chown(uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chmod(mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n    return files.BaseFile = BaseFile;\r\n});\ndefine('skylark-data-files/file-flag',[\r\n  \"./files\",\r\n  './error-codes',\r\n  \"./file-error\",\r\n  \"./action-type\"\r\n], function (files,ErrorCodes,FileError,ActionType) {\r\n    'use strict';\r\n\r\n\r\n\r\n  /**\r\n   * Represents one of the following file flags. A convenience object.\r\n   *\r\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\r\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\r\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\r\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\r\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\r\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\r\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\r\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\r\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\r\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\r\n   *\r\n   * Exclusive mode ensures that the file path is newly created.\r\n   */\r\n  class FileFlag {\r\n      /**\r\n       * This should never be called directly.\r\n       * @param modeStr The string representing the mode\r\n       * @throw when the mode string is invalid\r\n       */\r\n      constructor(flagStr) {\r\n          this.flagStr = flagStr;\r\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\r\n              throw new FileError(ErrorCodes.EINVAL, \"Invalid flag: \" + flagStr);\r\n          }\r\n      }\r\n      /**\r\n       * Get an object representing the given file flag.\r\n       * @param modeStr The string representing the flag\r\n       * @return The FileFlag object representing the flag\r\n       * @throw when the flag string is invalid\r\n       */\r\n      static getFileFlag(flagStr) {\r\n          // Check cache first.\r\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\r\n              return FileFlag.flagCache[flagStr];\r\n          }\r\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\r\n      }\r\n      /**\r\n       * Get the underlying flag string for this flag.\r\n       */\r\n      getFlagString() {\r\n          return this.flagStr;\r\n      }\r\n      /**\r\n       * Returns true if the file is readable.\r\n       */\r\n      isReadable() {\r\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is writeable.\r\n       */\r\n      isWriteable() {\r\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file mode should truncate.\r\n       */\r\n      isTruncating() {\r\n          return this.flagStr.indexOf('w') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is appendable.\r\n       */\r\n      isAppendable() {\r\n          return this.flagStr.indexOf('a') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in synchronous mode.\r\n       */\r\n      isSynchronous() {\r\n          return this.flagStr.indexOf('s') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in exclusive mode.\r\n       */\r\n      isExclusive() {\r\n          return this.flagStr.indexOf('x') !== -1;\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path existing.\r\n       */\r\n      pathExistsAction() {\r\n          if (this.isExclusive()) {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n          else if (this.isTruncating()) {\r\n              return ActionType.TRUNCATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.NOP;\r\n          }\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path not existing.\r\n       */\r\n      pathNotExistsAction() {\r\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\r\n              return ActionType.CREATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n      }\r\n  }\r\n  // Contains cached FileMode instances.\r\n  FileFlag.flagCache = {};\r\n  // Array of valid mode strings.\r\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\r\n\r\n\r\n\r\n  return files.FileFlag = FileFlag;\r\n});\ndefine('skylark-data-files/file-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n    * Indicates the type of the given file. Applied to 'mode'.\r\n    */\r\n  var FileType;\r\n  (function (FileType) {\r\n      FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\r\n      FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\r\n      FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\r\n  })(FileType || (FileType = {}));\r\n\r\n  return files.FileType = FileType;\r\n});\r\n  \ndefine('skylark-data-files/stats',[\r\n    'skylark-langx-binary/buffer',\r\n    \"./file-type\"\r\n],function (Buffer,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Emulation of Node's `fs.Stats` object.\r\n     *\r\n     * Attribute descriptions are from `man 2 stat'\r\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\r\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\r\n     */\r\n    class Stats {\r\n        /**\r\n         * Provides information about a particular entry in the file system.\r\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\r\n         * @param size Size of the item in bytes. For directories/symlinks,\r\n         *   this is normally the size of the struct that represents the item.\r\n         * @param mode Unix-style file mode (e.g. 0o644)\r\n         * @param atimeMs time of last access, in milliseconds since epoch\r\n         * @param mtimeMs time of last modification, in milliseconds since epoch\r\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\r\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\r\n         */\r\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\r\n            /**\r\n             * UNSUPPORTED ATTRIBUTES\r\n             * I assume no one is going to need these details, although we could fake\r\n             * appropriate values if need be.\r\n             */\r\n            // ID of device containing file\r\n            this.dev = 0;\r\n            // inode number\r\n            this.ino = 0;\r\n            // device ID (if special file)\r\n            this.rdev = 0;\r\n            // number of hard links\r\n            this.nlink = 1;\r\n            // blocksize for file system I/O\r\n            this.blksize = 4096;\r\n            // @todo Maybe support these? atm, it's a one-user filesystem.\r\n            // user ID of owner\r\n            this.uid = 0;\r\n            // group ID of owner\r\n            this.gid = 0;\r\n            // XXX: Some file systems stash data on stats objects.\r\n            this.fileData = null;\r\n            this.size = size;\r\n            let currentTime = 0;\r\n            if (typeof (atimeMs) !== 'number') {\r\n                currentTime = Date.now();\r\n                atimeMs = currentTime;\r\n            }\r\n            if (typeof (mtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                mtimeMs = currentTime;\r\n            }\r\n            if (typeof (ctimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                ctimeMs = currentTime;\r\n            }\r\n            if (typeof (birthtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                birthtimeMs = currentTime;\r\n            }\r\n            this.atimeMs = atimeMs;\r\n            this.ctimeMs = ctimeMs;\r\n            this.mtimeMs = mtimeMs;\r\n            this.birthtimeMs = birthtimeMs;\r\n            if (!mode) {\r\n                switch (itemType) {\r\n                    case FileType.FILE:\r\n                        this.mode = 0x1a4;\r\n                        break;\r\n                    case FileType.DIRECTORY:\r\n                    default:\r\n                        this.mode = 0x1ff;\r\n                }\r\n            }\r\n            else {\r\n                this.mode = mode;\r\n            }\r\n            // number of 512B blocks allocated\r\n            this.blocks = Math.ceil(size / 512);\r\n            // Check if mode also includes top-most bits, which indicate the file's\r\n            // type.\r\n            if (this.mode < 0x1000) {\r\n                this.mode |= itemType;\r\n            }\r\n        }\r\n        static fromBuffer(buffer) {\r\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\r\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\r\n        }\r\n        /**\r\n         * Clones the stats object.\r\n         */\r\n        static clone(s) {\r\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\r\n        }\r\n        get atime() {\r\n            return new Date(this.atimeMs);\r\n        }\r\n        get mtime() {\r\n            return new Date(this.mtimeMs);\r\n        }\r\n        get ctime() {\r\n            return new Date(this.ctimeMs);\r\n        }\r\n        get birthtime() {\r\n            return new Date(this.birthtimeMs);\r\n        }\r\n        toBuffer() {\r\n            const buffer = Buffer.alloc(32);\r\n            buffer.writeUInt32LE(this.size, 0);\r\n            buffer.writeUInt32LE(this.mode, 4);\r\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\r\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\r\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\r\n         */\r\n        isSymbolicLink() {\r\n            return (this.mode & 0xF000) === FileType.SYMLINK;\r\n        }\r\n        /**\r\n         * Change the mode of the file. We use this helper function to prevent messing\r\n         * up the type of the file, which is encoded in mode.\r\n         */\r\n        chmod(mode) {\r\n            this.mode = (this.mode & 0xF000) | mode;\r\n        }\r\n        // We don't support the following types of files.\r\n        isSocket() {\r\n            return false;\r\n        }\r\n        isBlockDevice() {\r\n            return false;\r\n        }\r\n        isCharacterDevice() {\r\n            return false;\r\n        }\r\n        isFIFO() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return files.Stats = Stats;\r\n});\ndefine('skylark-data-files/file-system',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths/path\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, path, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return path.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});\ndefine('skylark-data-files/utils',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(path.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});\ndefine('skylark-data-files/preload-file',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,file,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});\ndefine('skylark-data-files/no-sync-file',[\r\n     \"./preload-file\"\r\n], function (PreloadFile) {\r\n    'use strict';\r\n    /**\r\n     * File class for the InMemory and XHR file systems.\r\n     * Doesn't sync to anything, so it works nicely for memory-only files.\r\n     */\r\n    class NoSyncFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        /**\r\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous sync. Doesn't do anything.\r\n         */\r\n        syncSync() {\r\n            // NOP.\r\n        }\r\n        /**\r\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous close. Doesn't do anything.\r\n         */\r\n        closeSync() {\r\n            // NOP.\r\n        }\r\n    }\r\n\r\n    return files.NoSyncFile = NoSyncFile;\r\n    \r\n});\ndefine('skylark-data-files/main',[\r\n\t\"./files\",\r\n\t\"./action-type\",\r\n\t\"./base-file\",\r\n\t\"./error-codes\",\r\n\t\"./error-strings\",\r\n\t\"./file-error\",\r\n\t\"./file-flag\",\r\n\t\"./file-system\",\r\n\t\"./no-sync-file\",\r\n\t\"./preload-file\",\r\n\t\"./stats\"\r\n],function(files){\r\n\treturn files;\r\n});\ndefine('skylark-data-files', ['skylark-data-files/main'], function (main) { return main; });\n\n"]}