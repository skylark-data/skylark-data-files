{"version":3,"sources":["inodes/file-index.js"],"names":["define","paths","Stats","FileType","DirInode","FileINode","FileIndex","[object Object]","this","_index","addPath","listing","idx","rootInode","queue","length","inode","next","pop","pwd","tree","parent","node","hasOwnProperty","children","name","push","FileInode","FILE","_ls","cb","path","dir","files","getListing","file","item","getItem","isFileInode","getData","Error","splitPath","_split_path","dirpath","itemname","undefined","addItem","isDirInode","itemNameMark","lastIndexOf","parentPath","substring","itemName","addPathFast","isDir","remItem","child","removePath","p","dirname","substr"],"mappings":"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","file":"../../inodes/file-index.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type',\r\n    \"./dir-inode\",\r\n    \"./file-inode\"\r\n], function (paths, Stats,FileType,DirInode,FileINode) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple class for storing a filesystem index. Assumes that all paths passed\r\n     * to it are *absolute* paths.\r\n     *\r\n     * Can be used as a partial or a full index, although care must be taken if used\r\n     * for the former purpose, especially when directories are concerned.\r\n     */\r\n    class FileIndex {\r\n        /**\r\n         * Constructs a new FileIndex.\r\n         */\r\n        constructor() {\r\n            // _index is a single-level key,value store that maps *directory* paths to\r\n            // DirInodes. File information is only contained in DirInodes themselves.\r\n            this._index = {};\r\n            // Create the root directory.\r\n            this.addPath('/', new DirInode());\r\n        }\r\n        /**\r\n         * Static method for constructing indices from a JSON listing.\r\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\r\n         * @return A new FileIndex object.\r\n         */\r\n        static fromListing(listing) {\r\n            const idx = new FileIndex();\r\n            // Add a root DirNode.\r\n            const rootInode = new DirInode();\r\n            idx._index['/'] = rootInode;\r\n            const queue = [['', listing, rootInode]];\r\n            while (queue.length > 0) {\r\n                let inode;\r\n                const next = queue.pop();\r\n                const pwd = next[0];\r\n                const tree = next[1];\r\n                const parent = next[2];\r\n                for (const node in tree) {\r\n                    if (tree.hasOwnProperty(node)) {\r\n                        const children = tree[node];\r\n                        const name = `${pwd}/${node}`;\r\n                        if (children) {\r\n                            idx._index[name] = inode = new DirInode();\r\n                            queue.push([name, children, inode]);\r\n                        }\r\n                        else {\r\n                            // This inode doesn't have correct size information, noted with -1.\r\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\r\n                        }\r\n                        if (parent) {\r\n                            parent._ls[node] = inode;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return idx;\r\n        }\r\n        /**\r\n         * Runs the given function over all files in the index.\r\n         */\r\n        fileIterator(cb) {\r\n            for (const path in this._index) {\r\n                if (this._index.hasOwnProperty(path)) {\r\n                    const dir = this._index[path];\r\n                    const files = dir.getListing();\r\n                    for (const file of files) {\r\n                        const item = dir.getItem(file);\r\n                        if (isFileInode(item)) {\r\n                            cb(item.getData());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPath(path, inode) {\r\n            if (!inode) {\r\n                throw new Error('Inode must be specified');\r\n            }\r\n            if (path[0] !== '/') {\r\n                throw new Error('Path must be absolute, got: ' + path);\r\n            }\r\n            // Check if it already exists.\r\n            if (this._index.hasOwnProperty(path)) {\r\n                return this._index[path] === inode;\r\n            }\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[dirpath];\r\n            if (parent === undefined && path !== '/') {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                if (!this.addPath(dirpath, parent)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Add myself to my parent.\r\n            if (path !== '/') {\r\n                if (!parent.addItem(itemname, inode)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // If I'm a directory, add myself to the index.\r\n            if (isDirInode(inode)) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * The path is added without special treatment (no joining of adjacent separators, etc).\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPathFast(path, inode) {\r\n            const itemNameMark = path.lastIndexOf('/');\r\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\r\n            const itemName = path.substring(itemNameMark + 1);\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[parentPath];\r\n            if (parent === undefined) {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                this.addPathFast(parentPath, parent);\r\n            }\r\n            if (!parent.addItem(itemName, inode)) {\r\n                return false;\r\n            }\r\n            // If adding a directory, add to the index as well.\r\n            if (inode.isDir()) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given path. Can be a file or a directory.\r\n         * @return The removed item,\r\n         *   or null if it did not exist.\r\n         */\r\n        removePath(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to remove it from its parent directory first.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Remove myself from my parent.\r\n            const inode = parent.remItem(itemname);\r\n            if (inode === null) {\r\n                return null;\r\n            }\r\n            // If I'm a directory, remove myself from the index, and remove my children.\r\n            if (isDirInode(inode)) {\r\n                const children = inode.getListing();\r\n                for (const child of children) {\r\n                    this.removePath(path + '/' + child);\r\n                }\r\n                // Remove the directory from the index, unless it's the root.\r\n                if (path !== '/') {\r\n                    delete this._index[path];\r\n                }\r\n            }\r\n            return inode;\r\n        }\r\n        /**\r\n         * Retrieves the directory listing of the given path.\r\n         * @return An array of files in the given path, or 'null' if it does not exist.\r\n         */\r\n        ls(path) {\r\n            const item = this._index[path];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            return item.getListing();\r\n        }\r\n        /**\r\n         * Returns the inode of the given item.\r\n         * @return Returns null if the item does not exist.\r\n         */\r\n        getInode(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Retrieve from its parent directory.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Root case\r\n            if (dirpath === path) {\r\n                return parent;\r\n            }\r\n            return parent.getItem(itemname);\r\n        }\r\n        /**\r\n         * Split into a (directory path, item name) pair\r\n         */\r\n        _split_path(p) {\r\n            const dirpath = paths.dirname(p);\r\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\r\n            return [dirpath, itemname];\r\n        }\r\n    }\r\n    \r\n\r\n    return FileIndex;\r\n});"]}