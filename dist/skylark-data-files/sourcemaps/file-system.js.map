{"version":3,"sources":["file-system.js"],"names":["define","setImmediate","Buffer","path","files","ErrorCodes","FileError","FileFlag","Stats","wrapCbHook","cb","numArgs","wrapCb","Error","hookedCb","arg1","arg2","arg3","assertRoot","fs","EIO","normalizeMode","mode","def","trueMode","parseInt","isNaN","normalizeTime","time","Date","EINVAL","normalizePath","p","indexOf","resolve","normalizeOptions","options","defEnc","defFlag","defMode","encoding","flag","TypeError","nopCb","FileSystem","[object Object]","this","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","rootFS","constructor","isAvailable","getTime","oldPath","newPath","newCb","rename","e","renameSync","exists","existsSync","stat","statSync","len","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","data","isWriteable","writeFile","writeFileSync","isAppendable","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","length","sync","syncSync","datasync","datasyncSync","arg4","arg5","buffer","offset","position","from","undefined","getPos","write","writeSync","alloc","err","bytesRead","buf","toString","read","shenanigans","rv","readSync","uid","gid","callback","chown","chownSync","numMode","chmod","chmodSync","atime","mtime","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","ENOTSUP","cbWrapper","EBADF"],"mappings":"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","file":"../file-system.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths/path\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, path, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return path.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});"]}