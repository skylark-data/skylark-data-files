{"version":3,"sources":["file-system.js"],"names":["define","setImmediate","Buffer","paths","files","ErrorCodes","FileError","FileFlag","Stats","wrapCbHook","cb","numArgs","wrapCb","Error","hookedCb","arg1","arg2","arg3","assertRoot","fs","EIO","normalizeMode","mode","def","trueMode","parseInt","isNaN","normalizeTime","time","Date","EINVAL","normalizePath","p","indexOf","resolve","normalizeOptions","options","defEnc","defFlag","defMode","encoding","flag","TypeError","nopCb","FileSystem","[object Object]","this","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","rootFS","constructor","isAvailable","getTime","oldPath","newPath","newCb","rename","e","renameSync","path","exists","existsSync","stat","statSync","len","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","data","isWriteable","writeFile","writeFileSync","isAppendable","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","length","sync","syncSync","datasync","datasyncSync","arg4","arg5","buffer","offset","position","from","undefined","getPos","write","writeSync","alloc","err","bytesRead","buf","toString","read","shenanigans","rv","readSync","uid","gid","callback","chown","chownSync","numMode","chmod","chmodSync","atime","mtime","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","ENOTSUP","cbWrapper","EBADF"],"mappings":"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","file":"../file-system.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, paths, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return paths.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});"]}