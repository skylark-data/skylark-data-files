{"version":3,"sources":["utils.js"],"names":["define","Buffer","paths","FileError","ErrorCodes","buffer2Uint8array","buff","Uint8Array","uint8Array2Buffer","u8","byteOffset","byteLength","buffer","arrayBuffer2Buffer","from","ab","emptyBuff","emptyBuffer","alloc","deprecationMessage","print","fsName","opts","console","warn","JSON","stringify","isIE","navigator","exec","userAgent","toLowerCase","indexOf","isWebWorker","window","fail","Error","mkdirpSync","p","mode","fs","existsSync","dirname","mkdirSync","buffer2ArrayBuffer","u8offset","u8Len","slice","arrayish2Buffer","arr","copyingSlice","start","end","length","TypeError","s0","newS0","subarray","bufferValidator","v","cb","isBuffer","EINVAL","checkOptions","fsType","optsInfo","Options","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","e","optName","hasOwnProperty","opt","providedValue","undefined","optional","incorrectOptions","Object","keys","filter","o","map","a","str","distance","levenshtein","sort","b","description","typeMatches","Array","isArray","type","join","validator"],"mappings":"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","file":"../utils.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(paths.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});"]}