{"version":3,"sources":["providers/http/http-provider.js"],"names":["define","async","paths","files","registry","NoSyncFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","utils","xhr","fetch","DirInode","FileIndex","FileInode","copyingSlice","xhrIsAvailable","asyncDownloadFile","syncDownloadFile","getFileSizeAsync","getFileSizeSync","fetchIsAvailable","fetchFileAsync","fetchFileSizeAsync","isFileInode","isDirInode","syncNotAvailableError","ENOTSUP","HttpProvider","[object Object]","index","prefixUrl","preferXHR","super","length","charAt","this","_index","fromListing","_requestFileAsyncInternal","_requestFileSizeAsyncInternal","_requestFileSyncInternal","_requestFileSizeSyncInternal","opts","cb","undefined","e","data","baseUrl","fileIterator","file","fileData","Name","path","buffer","inode","getInode","EISDIR","ENOENT","stats","getData","size","isLstat","_requestFileSizeAsync","clone","getStats","EINVAL","_requestFileSizeSync","flags","mode","isWriteable","EPERM","self","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","_requestFileAsync","err","_requestFileSync","readdirSync","getListing","ENOTDIR","fname","encoding","flag","oldCb","open","fd","arg","close","err2","fdBuff","getBuffer","buff","toString","tryToString","openSync","closeSync","filePath","slice","p","type","_getHTTPPath","Options","optional","description","add","providers"],"mappings":"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","file":"../../../providers/http/http-provider.js","sourcesContent":["define([\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    \"../../files\",\n    \"../registry\",\n    '../../no-sync-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    './xhr',\n    './fetch',\n    '../../inodes/dir-inode',\n    '../../inodes/file-index',\n    '../../inodes/file-inode',\n\n], function (async,paths,files,registry,NoSyncFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType,  utils,xhr, fetch, DirInode,FileIndex,FileInode) {\n\n\n    'use strict';\n\n    const { copyingSlice }  = utils;\n\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n\n    const isFileInode = FileInode.isFileInode,\n          isDirInode = DirInode.isDirInode;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new FileError(ErrorCodes.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HttpProvider extends BaseProvider {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HttpProvider file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HttpProvider(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HttpProvider(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HttpProvider.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw FileError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(FileError.FileError(ErrorCodes.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw FileError.FileError(ErrorCodes.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new FileError(ErrorCodes.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(FileError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(FileError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new FileError(ErrorCodes.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw FileError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw FileError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HttpProvider.Name = \"http\";\n    HttpProvider.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    registry.add(\"http\",HttpProvider);\n\n    return files.providers.HttpProvider = HttpProvider;\n});"]}