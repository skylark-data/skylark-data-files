{"version":3,"sources":["providers/http/fetch.js"],"names":["define","Buffer","ErrorCodes","FileError","fetchIsAvailable","fetch","fetchFileAsync","p","type","cb","request","e","EINVAL","message","then","res","ok","EIO","status","arrayBuffer","buf","from","catch","err","json","fetchFileSizeAsync","method","parseInt","headers","get"],"mappings":";;;;;;;AAAAA,QACI,8BACA,oBACA,oBACD,SAAUC,EAAOC,EAAWC,GAC3B,aAyDA,OACIC,iBAvDyC,oBAAZ,OAAqC,OAAVC,MAwDxDC,eAtDJ,SAAwBC,EAAGC,EAAMC,GAC7B,IAAIC,EACJ,IACIA,EAAUL,MAAME,GAEpB,MAAOI,GAEH,OAAOF,EAAG,IAAIN,EAAUD,EAAWU,OAAQD,EAAEE,UAEjDH,EACKI,KAAMC,IACP,IAAKA,EAAIC,GACL,OAAOP,EAAG,IAAIN,EAAUD,EAAWe,2CAA4CF,EAAIG,WAGnF,OAAQV,GACJ,IAAK,SACDO,EAAII,cACCL,KAAMM,GAAQX,EAAG,KAAMR,EAAOoB,KAAKD,KACnCE,MAAOC,GAAQd,EAAG,IAAIN,EAAUD,EAAWe,IAAKM,EAAIV,WACzD,MACJ,IAAK,OACDE,EAAIS,OACCV,KAAMU,GAASf,EAAG,KAAMe,IACxBF,MAAOC,GAAQd,EAAG,IAAIN,EAAUD,EAAWe,IAAKM,EAAIV,WACzD,MACJ,QACIJ,EAAG,IAAIN,EAAUD,EAAWU,OAAQ,0BAA4BJ,OAI3Ec,MAAOC,GAAQd,EAAG,IAAIN,EAAUD,EAAWe,IAAKM,EAAIV,YAwBzDY,mBAhBJ,SAA4BlB,EAAGE,GAC3BJ,MAAME,GAAKmB,OAAQ,SACdZ,KAAMC,GACFA,EAAIC,GAIEP,EAAG,KAAMkB,SAASZ,EAAIa,QAAQC,IAAI,mBAAqB,KAAM,KAH7DpB,EAAG,IAAIN,EAAUD,EAAWe,gDAAiDF,EAAIG,YAM3FI,MAAOC,GAAQd,EAAG,IAAIN,EAAUD,EAAWe,IAAKM,EAAIV","file":"../../../providers/http/fetch.js","sourcesContent":["define([\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error'\n], function (Buffer,ErrorCodes,FileError) {\n    'use strict';\n\n\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\n\n    function fetchFileAsync(p, type, cb) {\n        let request;\n        try {\n            request = fetch(p);\n        }\n        catch (e) {\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\n            return cb(new FileError(ErrorCodes.EINVAL, e.message));\n        }\n        request\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch error: response returned code ${res.status}`));\n            }\n            else {\n                switch (type) {\n                    case 'buffer':\n                        res.arrayBuffer()\n                            .then((buf) => cb(null, Buffer.from(buf)))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    case 'json':\n                        res.json()\n                            .then((json) => cb(null, json))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n                }\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n\n    function fetchFileSizeAsync(p, cb) {\n        fetch(p, { method: 'HEAD' })\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch HEAD error: response returned code ${res.status}`));\n            }\n            else {\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    return {\n        fetchIsAvailable: fetchIsAvailable,\n        fetchFileAsync: fetchFileAsync,\n        fetchFileSizeAsync: fetchFileSizeAsync\n    };\n});"]}