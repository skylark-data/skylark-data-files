{"version":3,"sources":["providers/indexeddb/indexed-db-store.js"],"names":["define","FileError","ErrorCodes","IndexedDBROTransaction","IndexedDBRWTransaction","onErrorHandler","cb","code","EIO","message","e","preventDefault","undefined","IndexedDBStore","[object Object]","db","storeName","this","openReq","indexedDB","open","onupgradeneeded","event","target","result","objectStoreNames","contains","deleteObjectStore","createObjectStore","onsuccess","onerror","EACCES","IndexedDBProvider","Name","r","transaction","objectStore","clear","setTimeout","toString","name","ENOENT","ENOSPC","convertError","type","tx","EINVAL"],"mappings":";;;;;;;AAAAA,QACI,mBACA,oBACA,8BACA,+BACD,SAAUC,EAAUC,EAAWC,EAAuBC,GACrD,aAyBA,SAASC,EAAeC,EAAIC,EAAOL,EAAWM,IAAKC,EAAU,MACzD,OAAO,SAAUC,GAEbA,EAAEC,iBACFL,EAAG,IAAIL,EAAUM,EAAkB,OAAZE,EAAmBA,OAAUG,WAItDC,EACFC,YAAYC,EAAIC,GACZC,KAAKF,GAAKA,EACVE,KAAKD,UAAYA,EAErBF,cAAcE,EAAWV,GACrB,MAAMY,EAAUC,UAAUC,KAAKJ,EAAW,GAC1CE,EAAQG,gBAAkB,CAACC,IACvB,MAAMP,EAAKO,EAAMC,OAAOC,OAGpBT,EAAGU,iBAAiBC,SAASV,IAC7BD,EAAGY,kBAAkBX,GAEzBD,EAAGa,kBAAkBZ,KAEzBE,EAAQW,UAAY,CAACP,IACjBhB,EAAG,KAAM,IAAIO,EAAeS,EAAMC,OAAOC,OAAQR,MAErDE,EAAQY,QAAUzB,EAAeC,EAAIJ,EAAW6B,QAEpDjB,OACI,OAAOkB,kBAAkBC,KAAO,MAAQhB,KAAKD,UAEjDF,MAAMR,GACF,IACI,MAA2G4B,EAAhGjB,KAAKF,GAAGoB,YAAYlB,KAAKD,UAAW,aAA+BoB,YAAYnB,KAAKD,WAA4BqB,QAC3HH,EAAEL,UAAY,CAACP,IAEXgB,WAAWhC,EAAI,KAEnB4B,EAAEJ,QAAUzB,EAAeC,GAE/B,MAAOI,GACHJ,EA3DZ,SAAsBI,EAAGD,EAAUC,EAAE6B,YACjC,OAAQ7B,EAAE8B,MACN,IAAK,gBACD,OAAO,IAAIvC,EAAUC,EAAWuC,OAAQhC,GAC5C,IAAK,qBACD,OAAO,IAAIR,EAAUC,EAAWwC,OAAQjC,GAC5C,QAEI,OAAO,IAAIR,EAAUC,EAAWM,IAAKC,IAmDlCkC,CAAajC,KAGxBI,iBAAiB8B,EAAO,YACpB,MAAMC,EAAK5B,KAAKF,GAAGoB,YAAYlB,KAAKD,UAAW4B,GAAOR,EAAcS,EAAGT,YAAYnB,KAAKD,WACxF,GAAa,cAAT4B,EACA,OAAO,IAAIxC,EAAuByC,EAAIT,GAErC,GAAa,aAATQ,EACL,OAAO,IAAIzC,EAAuB0C,EAAIT,GAGtC,MAAM,IAAInC,EAAUC,EAAW4C,OAAQ,8BAMnD,OAAOjC","file":"../../../providers/indexeddb/indexed-db-store.js","sourcesContent":["define([\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    class IndexedDBStore {\r\n        constructor(db, storeName) {\r\n            this.db = db;\r\n            this.storeName = storeName;\r\n        }\r\n        static Create(storeName, cb) {\r\n            const openReq = indexedDB.open(storeName, 1);\r\n            openReq.onupgradeneeded = (event) => {\r\n                const db = event.target.result;\r\n                // Huh. This should never happen; we're at version 1. Why does another\r\n                // database exist?\r\n                if (db.objectStoreNames.contains(storeName)) {\r\n                    db.deleteObjectStore(storeName);\r\n                }\r\n                db.createObjectStore(storeName);\r\n            };\r\n            openReq.onsuccess = (event) => {\r\n                cb(null, new IndexedDBStore(event.target.result, storeName));\r\n            };\r\n            openReq.onerror = onErrorHandler(cb, ErrorCodes.EACCES);\r\n        }\r\n        name() {\r\n            return IndexedDBProvider.Name + \" - \" + this.storeName;\r\n        }\r\n        clear(cb) {\r\n            try {\r\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\r\n                r.onsuccess = (event) => {\r\n                    // Use setTimeout to commit transaction.\r\n                    setTimeout(cb, 0);\r\n                };\r\n                r.onerror = onErrorHandler(cb);\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        beginTransaction(type = 'readonly') {\r\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\r\n            if (type === 'readwrite') {\r\n                return new IndexedDBRWTransaction(tx, objectStore);\r\n            }\r\n            else if (type === 'readonly') {\r\n                return new IndexedDBROTransaction(tx, objectStore);\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Invalid transaction type.');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBStore;\r\n});"]}