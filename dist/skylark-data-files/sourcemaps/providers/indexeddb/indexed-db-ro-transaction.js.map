{"version":3,"sources":["providers/indexeddb/indexed-db-ro-transaction.js"],"names":["define","FileError","ErrorCodes","AsyncKeyValueProvider","utils","arrayBuffer2Buffer","buffer2ArrayBuffer","[object Object]","tx","store","this","key","cb","r","get","onerror","code","EIO","message","e","preventDefault","undefined","onErrorHandler","onsuccess","event","result","target","toString","name","ENOENT","ENOSPC","convertError"],"mappings":";;;;;;;AAAAA,QACI,mBACA,oBACA,8BACA,eACD,SAAUC,EAAUC,EAAYC,EAAwBC,GACvD,aAGA,MAAMC,mBAAEA,EAAkBC,mBAAEA,GAAwBF,EAgEpD,aA7BIG,YAAYC,EAAIC,GACZC,KAAKF,GAAKA,EACVE,KAAKD,MAAQA,EAEjBF,IAAII,EAAKC,GACL,IACI,MAAMC,EAAIH,KAAKD,MAAMK,IAAIH,GACzBE,EAAEE,QAlBd,SAAwBH,EAAII,EAAOd,EAAWe,IAAKC,EAAU,MACzD,OAAO,SAAUC,GAEbA,EAAEC,iBACFR,EAAG,IAAIX,EAAUe,EAAkB,OAAZE,EAAmBA,OAAUG,KAcpCC,CAAeV,GAC3BC,EAAEU,UAAY,CAACC,IAGX,MAAMC,EAASD,EAAME,OAAOD,OAExBb,EAAG,UADQS,IAAXI,EACSA,EAIApB,EAAmBoB,MAIxC,MAAON,GACHP,EAlDZ,SAAsBO,EAAGD,EAAUC,EAAEQ,YACjC,OAAQR,EAAES,MACN,IAAK,gBACD,OAAO,IAAI3B,EAAUC,EAAW2B,OAAQX,GAC5C,IAAK,qBACD,OAAO,IAAIjB,EAAUC,EAAW4B,OAAQZ,GAC5C,QAEI,OAAO,IAAIjB,EAAUC,EAAWe,IAAKC,IA0ClCa,CAAaZ","file":"../../../providers/indexeddb/indexed-db-ro-transaction.js","sourcesContent":["define([\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils'\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            this.tx = tx;\r\n            this.store = store;\r\n        }\r\n        get(key, cb) {\r\n            try {\r\n                const r = this.store.get(key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    // IDB returns the value 'undefined' when you try to get keys that\r\n                    // don't exist. The caller expects this behavior.\r\n                    const result = event.target.result;\r\n                    if (result === undefined) {\r\n                        cb(null, result);\r\n                    }\r\n                    else {\r\n                        // IDB data is stored as an ArrayBuffer\r\n                        cb(null, arrayBuffer2Buffer(result));\r\n                    }\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return IndexedDBROTransaction;\r\n});"]}