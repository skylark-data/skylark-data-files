{"version":3,"sources":["providers/sync-key-value-provider.js"],"names":["define","GenerateRandomID","Buffer","path","files","BaseProvider","SynchronousProvider","ErrorCodes","FileError","FileType","Inode","utils","emptyBuffer","[object Object]","options","super","this","store","makeRootDirectory","name","clear","oldPath","newPath","tx","beginTransaction","oldParent","dirname","oldName","basename","newParent","newName","oldDirNode","findINode","oldDirList","getDirListing","ENOENT","nodeId","indexOf","EBUSY","newDirNode","newDirList","newNameNode","getINode","isFile","EPERM","del","id","e","abort","put","from","JSON","stringify","commit","p","isLstat","toStats","flag","mode","data","newFile","commitNewFile","FILE","SyncKeyValueFile","node","get","undefined","removeEntry","readdirSync","length","ENOTEMPTY","DIRECTORY","Object","keys","stats","fileInodeId","_findINode","fileInode","inodeChanged","update","toBuffer","ROOT_NODE_ID","currTime","Date","getTime","dirInode","getEmptyDirNode","parent","filename","readDirectory","inode","dirList","resolve","sep","fromBuffer","isDirectory","ENOTDIR","parse","toString","currId","EIO","type","parentDir","fname","parentNode","dirListing","EEXIST","fileNode","dataId","addNewNode","fileNodeId","isDir","parentListing","fileName","EISDIR"],"mappings":"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","file":"../../providers/sync-key-value-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-string/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths/path\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"./base-provider\",\r\n    \"./synchronous-provider\",\r\n    '../utils'\r\n], function (GenerateRandomID, Buffer,path,files,BaseProvider, SynchronousProvider, ErrorCodes, FileError, FileType,  Inode, utils) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n\r\n    /**\r\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\r\n     * underlying key-value store.\r\n     *\r\n     * We use a unique ID for each node in the file system. The root node has a\r\n     * fixed ID.\r\n     * @todo Introduce Node ID caching.\r\n     * @todo Check modes.\r\n     */\r\n    class SyncKeyValueProvider extends SynchronousProvider {\r\n        static isAvailable() { return true; }\r\n        constructor(options) {\r\n            super();\r\n            this.store = options.store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        getName() { return this.store.name(); }\r\n        isReadOnly() { return false; }\r\n        supportsSymlinks() { return false; }\r\n        supportsProps() { return false; }\r\n        supportsSynch() { return true; }\r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty() {\r\n            this.store.clear();\r\n            // INVARIANT: Root always exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            const tx = this.store.beginTransaction('readwrite'), oldParent = path.dirname(oldPath), oldName = path.basename(oldPath), newParent = path.dirname(newPath), newName = path.basename(newPath), \r\n            // Remove oldPath from parent's directory listing.\r\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\r\n            if (!oldDirList[oldName]) {\r\n                throw FileError.ENOENT(oldPath);\r\n            }\r\n            const nodeId = oldDirList[oldName];\r\n            delete oldDirList[oldName];\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                throw new FileError(ErrorCodes.EBUSY, oldParent);\r\n            }\r\n            // Add newPath to parent's directory listing.\r\n            let newDirNode, newDirList;\r\n            if (newParent === oldParent) {\r\n                // Prevent us from re-grabbing the same directory listing, which still\r\n                // contains oldName.\r\n                newDirNode = oldDirNode;\r\n                newDirList = oldDirList;\r\n            }\r\n            else {\r\n                newDirNode = this.findINode(tx, newParent);\r\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\r\n            }\r\n            if (newDirList[newName]) {\r\n                // If it's a file, delete it.\r\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\r\n                if (newNameNode.isFile()) {\r\n                    try {\r\n                        tx.del(newNameNode.id);\r\n                        tx.del(newDirList[newName]);\r\n                    }\r\n                    catch (e) {\r\n                        tx.abort();\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    // If it's a directory, throw a permissions error.\r\n                    throw FileError.EPERM(newPath);\r\n                }\r\n            }\r\n            newDirList[newName] = nodeId;\r\n            // Commit the two changed directory listings.\r\n            try {\r\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\r\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        statSync(p, isLstat) {\r\n            // Get the inode to the item, convert it into a Stats object.\r\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\r\n        }\r\n        createFileSync(p, flag, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\r\n            // Open the file.\r\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\r\n        }\r\n        openFileSync(p, flag) {\r\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\r\n        }\r\n        unlinkSync(p) {\r\n            this.removeEntry(p, false);\r\n        }\r\n        rmdirSync(p) {\r\n            // Check first if directory is empty.\r\n            if (this.readdirSync(p).length > 0) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                this.removeEntry(p, true);\r\n            }\r\n        }\r\n        mkdirSync(p, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\r\n        }\r\n        readdirSync(p) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\r\n        }\r\n        _syncSync(p, data, stats) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite'), \r\n            // We use the _findInode helper because we actually need the INode id.\r\n            fileInodeId = this._findINode(tx, path.dirname(p), path.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\r\n            try {\r\n                // Sync data.\r\n                tx.put(fileInode.id, data, true);\r\n                // Sync metadata.\r\n                if (inodeChanged) {\r\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\r\n                }\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory() {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            if (tx.get(ROOT_NODE_ID) === undefined) {\r\n                // Create new inode.\r\n                const currTime = (new Date()).getTime(), \r\n                // Mode 0666\r\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                // If the root doesn't exist, the first random ID shouldn't exist,\r\n                // either.\r\n                tx.put(dirInode.id, getEmptyDirNode(), false);\r\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\r\n                tx.commit();\r\n            }\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @return string The ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename) {\r\n            const readDirectory = (inode) => {\r\n                // Get the root's directory listing.\r\n                const dirList = this.getDirListing(tx, parent, inode);\r\n                // Get the file's ID.\r\n                if (dirList[filename]) {\r\n                    return dirList[filename];\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(path.resolve(parent, filename));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    return ROOT_NODE_ID;\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root ndoe.\r\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\r\n                }\r\n            }\r\n            else {\r\n                return readDirectory(this.getINode(tx, parent + path.sep + filename, this._findINode(tx, path.dirname(parent), path.basename(parent))));\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @return The Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p) {\r\n            return this.getINode(tx, p, this._findINode(tx, path.dirname(p), path.basename(p)));\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         */\r\n        getINode(tx, p, id) {\r\n            const inode = tx.get(id);\r\n            if (inode === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return Inode.fromBuffer(inode);\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode) {\r\n            if (!inode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            const data = tx.get(inode.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return JSON.parse(data.toString());\r\n        }\r\n        /**\r\n         * Creates a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @return The GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data) {\r\n            const retries = 0;\r\n            let currId;\r\n            while (retries < 5) {\r\n                try {\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false);\r\n                    return currId;\r\n                }\r\n                catch (e) {\r\n                    // Ignore and reroll.\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.');\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @return The Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data) {\r\n            const parentDir = path.dirname(p), fname = path.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            // Check if file already exists.\r\n            if (dirListing[fname]) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            let fileNode;\r\n            try {\r\n                // Commit data.\r\n                const dataId = this.addNewNode(tx, data);\r\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                // Commit file node.\r\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\r\n                // Update and commit parent directory listing.\r\n                dirListing[fname] = fileNodeId;\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n            return fileNode;\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir) {\r\n            const tx = this.store.beginTransaction('readwrite'), parent = path.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = path.basename(p);\r\n            if (!parentListing[fileName]) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            // Remove from directory listing of parent.\r\n            const fileNodeId = parentListing[fileName];\r\n            delete parentListing[fileName];\r\n            // Get file inode.\r\n            const fileNode = this.getINode(tx, p, fileNodeId);\r\n            if (!isDir && fileNode.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            else if (isDir && !fileNode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            try {\r\n                // Delete data.\r\n                tx.del(fileNode.id);\r\n                // Delete node.\r\n                tx.del(fileNodeId);\r\n                // Update directory listing.\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            // Success.\r\n            tx.commit();\r\n        }\r\n    }\r\n\r\n\r\n    return SyncKeyValueProvider;\r\n});"]}