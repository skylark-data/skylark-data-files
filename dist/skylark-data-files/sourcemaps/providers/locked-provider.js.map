{"version":3,"sources":["providers/locked-provider.js"],"names":["define","Mutex","[object Object]","fs","this","_fs","_mu","getName","p","cb","diskSpace","isReadOnly","supportsLinks","supportsProps","supportsSynch","oldPath","newPath","lock","rename","err","unlock","isLocked","Error","renameSync","isLstat","stat","statSync","flag","mode","open","fd","openSync","unlink","unlinkSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","files","readdirSync","exists","existsSync","cache","realpath","resolvedPath","realpathSync","len","truncate","truncateSync","fname","encoding","readFile","data","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","isLchmod","chmod","chmodSync","isLchown","uid","gid","chown","chownSync","atime","mtime","utimes","utimesSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","linkString","readlinkSync"],"mappings":"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","file":"../../providers/locked-provider.js","sourcesContent":["define(['./mutex'], function (Mutex) {\r\n    'use strict';\r\n    /**\r\n     * This class serializes access to an underlying async filesystem.\r\n     * For example, on an OverlayFS instance with an async lower\r\n     * directory operations like rename and rmdir may involve multiple\r\n     * requests involving both the upper and lower filesystems -- they\r\n     * are not executed in a single atomic step.  OverlayFS uses this\r\n     * LockedProvider to avoid having to reason about the correctness of\r\n     * multiple requests interleaving.\r\n     */\r\n    class LockedProvider {\r\n        constructor(fs) {\r\n            this._fs = fs;\r\n            this._mu = new Mutex();\r\n        }\r\n        getName() {\r\n            return 'LockedProvider<' + this._fs.getName() + '>';\r\n        }\r\n        getFSUnlocked() {\r\n            return this._fs;\r\n        }\r\n        diskSpace(p, cb) {\r\n            // FIXME: should this lock?\r\n            this._fs.diskSpace(p, cb);\r\n        }\r\n        isReadOnly() {\r\n            return this._fs.isReadOnly();\r\n        }\r\n        supportsLinks() {\r\n            return this._fs.supportsLinks();\r\n        }\r\n        supportsProps() {\r\n            return this._fs.supportsProps();\r\n        }\r\n        supportsSynch() {\r\n            return this._fs.supportsSynch();\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rename(oldPath, newPath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.renameSync(oldPath, newPath);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.stat(p, isLstat, (err, stat) => {\r\n                    this._mu.unlock();\r\n                    cb(err, stat);\r\n                });\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.statSync(p, isLstat);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.open(p, flag, mode, (err, fd) => {\r\n                    this._mu.unlock();\r\n                    cb(err, fd);\r\n                });\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.openSync(p, flag, mode);\r\n        }\r\n        unlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.unlink(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.unlinkSync(p);\r\n        }\r\n        rmdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rmdir(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.rmdirSync(p);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.mkdir(p, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.mkdirSync(p, mode);\r\n        }\r\n        readdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readdir(p, (err, files) => {\r\n                    this._mu.unlock();\r\n                    cb(err, files);\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readdirSync(p);\r\n        }\r\n        exists(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.exists(p, (exists) => {\r\n                    this._mu.unlock();\r\n                    cb(exists);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.existsSync(p);\r\n        }\r\n        realpath(p, cache, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\r\n                    this._mu.unlock();\r\n                    cb(err, resolvedPath);\r\n                });\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.realpathSync(p, cache);\r\n        }\r\n        truncate(p, len, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.truncate(p, len, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        truncateSync(p, len) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.truncateSync(p, len);\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\r\n                    this._mu.unlock();\r\n                    cb(err, data);\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readFileSync(fname, encoding, flag);\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chmod(p, isLchmod, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chmodSync(p, isLchmod, mode);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chownSync(p, isLchown, uid, gid);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.utimes(p, atime, mtime, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.utimesSync(p, atime, mtime);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.link(srcpath, dstpath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        readlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readlink(p, (err, linkString) => {\r\n                    this._mu.unlock();\r\n                    cb(err, linkString);\r\n                });\r\n            });\r\n        }\r\n        readlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readlinkSync(p);\r\n        }\r\n    }\r\n\r\n    return LockedProvider;\r\n});"]}