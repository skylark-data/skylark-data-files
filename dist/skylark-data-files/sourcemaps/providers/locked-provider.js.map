{"version":3,"sources":["providers/locked-provider.js"],"names":["define","files","Mutex","providers","LockedProvider","[object Object]","fs","this","_fs","_mu","getName","p","cb","diskSpace","isReadOnly","supportsLinks","supportsProps","supportsSynch","oldPath","newPath","lock","rename","err","unlock","isLocked","Error","renameSync","isLstat","stat","statSync","flag","mode","open","fd","openSync","unlink","unlinkSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","exists","existsSync","cache","realpath","resolvedPath","realpathSync","len","truncate","truncateSync","fname","encoding","readFile","data","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","isLchmod","chmod","chmodSync","isLchown","uid","gid","chown","chownSync","atime","mtime","utimes","utimesSync","srcpath","dstpath","link","linkSync","type","symlink","symlinkSync","readlink","linkString","readlinkSync"],"mappings":"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","file":"../../providers/locked-provider.js","sourcesContent":["define([\r\n    \"../files\",\r\n    './mutex'\r\n], function (files,Mutex) {\r\n    'use strict';\r\n    /**\r\n     * This class serializes access to an underlying async filesystem.\r\n     * For example, on an OverlayFS instance with an async lower\r\n     * directory operations like rename and rmdir may involve multiple\r\n     * requests involving both the upper and lower filesystems -- they\r\n     * are not executed in a single atomic step.  OverlayFS uses this\r\n     * LockedProvider to avoid having to reason about the correctness of\r\n     * multiple requests interleaving.\r\n     */\r\n    class LockedProvider {\r\n        constructor(fs) {\r\n            this._fs = fs;\r\n            this._mu = new Mutex();\r\n        }\r\n        getName() {\r\n            return 'LockedProvider<' + this._fs.getName() + '>';\r\n        }\r\n        getFSUnlocked() {\r\n            return this._fs;\r\n        }\r\n        diskSpace(p, cb) {\r\n            // FIXME: should this lock?\r\n            this._fs.diskSpace(p, cb);\r\n        }\r\n        isReadOnly() {\r\n            return this._fs.isReadOnly();\r\n        }\r\n        supportsLinks() {\r\n            return this._fs.supportsLinks();\r\n        }\r\n        supportsProps() {\r\n            return this._fs.supportsProps();\r\n        }\r\n        supportsSynch() {\r\n            return this._fs.supportsSynch();\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rename(oldPath, newPath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.renameSync(oldPath, newPath);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.stat(p, isLstat, (err, stat) => {\r\n                    this._mu.unlock();\r\n                    cb(err, stat);\r\n                });\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.statSync(p, isLstat);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.open(p, flag, mode, (err, fd) => {\r\n                    this._mu.unlock();\r\n                    cb(err, fd);\r\n                });\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.openSync(p, flag, mode);\r\n        }\r\n        unlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.unlink(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.unlinkSync(p);\r\n        }\r\n        rmdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rmdir(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.rmdirSync(p);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.mkdir(p, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.mkdirSync(p, mode);\r\n        }\r\n        readdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readdir(p, (err, files) => {\r\n                    this._mu.unlock();\r\n                    cb(err, files);\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readdirSync(p);\r\n        }\r\n        exists(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.exists(p, (exists) => {\r\n                    this._mu.unlock();\r\n                    cb(exists);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.existsSync(p);\r\n        }\r\n        realpath(p, cache, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\r\n                    this._mu.unlock();\r\n                    cb(err, resolvedPath);\r\n                });\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.realpathSync(p, cache);\r\n        }\r\n        truncate(p, len, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.truncate(p, len, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        truncateSync(p, len) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.truncateSync(p, len);\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\r\n                    this._mu.unlock();\r\n                    cb(err, data);\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readFileSync(fname, encoding, flag);\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chmod(p, isLchmod, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chmodSync(p, isLchmod, mode);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chownSync(p, isLchown, uid, gid);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.utimes(p, atime, mtime, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.utimesSync(p, atime, mtime);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.link(srcpath, dstpath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        readlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readlink(p, (err, linkString) => {\r\n                    this._mu.unlock();\r\n                    cb(err, linkString);\r\n                });\r\n            });\r\n        }\r\n        readlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readlinkSync(p);\r\n        }\r\n    }\r\n\r\n    return files.providers.LockedProvider = LockedProvider;\r\n});"]}