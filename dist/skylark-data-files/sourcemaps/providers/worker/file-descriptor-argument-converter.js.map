{"version":3,"sources":["providers/worker/file-descriptor-argument-converter.js"],"names":["define","Buffer","Stats","FileType","FileError","ErrorCodes","FileFlag","ActionType","utils","misc","SpecialArgType","buffer2ArrayBuffer","arrayBuffer2Buffer","emptyBuffer","[object Object]","this","_fileDescriptors","_nextId","fd","p","flag","cb","id","data","stat","err","stats","bufferToTransferrableObject","toBuffer","isReadable","read","alloc","size","bytesRead","buff","type","FD","path","getFlagString","ArrayBuffer","request","fdArg","args","_applyFdChanges","method","e","remoteFd","transferrableObjectToBuffer","remoteStats","fromBuffer","getFileFlag","isWriteable","write","length","isAppendable","getPos","applyStatChanges","mode","chmod","truncate"],"mappings":";;;;;;;AAAAA,QACI,8BACA,cACA,kBACA,mBACA,oBACA,kBACA,oBACA,cACA,SACA,sBACD,SAAUC,EAAQC,EAAMC,EAASC,EAAWC,EAAYC,EAASC,EAAWC,EAAMC,EAAKC,GAGtF,MAAMC,mBAAEA,EAAkBC,mBAAEA,EAAkBC,YAAEA,GAAiBL,EA0HjE,aArHIM,cACIC,KAAKC,oBACLD,KAAKE,QAAU,EAEnBH,YAAYI,EAAIC,EAAGC,EAAMC,GACrB,MAAMC,EAAKP,KAAKE,UAChB,IAAIM,EACAC,EACJT,KAAKC,iBAAiBM,GAAMJ,EAE5BA,EAAGM,KAAK,CAACC,EAAKC,KACND,EACAJ,EAAGI,IAGHD,EAAOf,EAAKkB,4BAA4BD,EAAME,YAE1CR,EAAKS,aACLX,EAAGY,KAAK7B,EAAO8B,MAAML,EAAMM,MAAO,EAAGN,EAAMM,KAAM,EAAG,CAACP,EAAKQ,EAAWC,KAC7DT,EACAJ,EAAGI,IAGHF,EAAOd,EAAKkB,4BAA4BO,GACxCb,EAAG,MACCc,KAAMzB,EAAe0B,GACrBd,GAAIA,EACJC,KAAMA,EACNC,KAAMA,EACNa,KAAMlB,EACNC,KAAMA,EAAKkB,qBAQvBjB,EAAG,MACCc,KAAMzB,EAAe0B,GACrBd,GAAIA,EACJC,KAAM,IAAIgB,YAAY,GACtBf,KAAMA,EACNa,KAAMlB,EACNC,KAAMA,EAAKkB,qBAM/BxB,kBAAkB0B,EAASnB,GACvB,MAAMoB,EAAQD,EAAQE,KAAK,GAC3B3B,KAAK4B,gBAAgBF,EAAO,CAAChB,EAAKP,KAC1BO,EACAJ,EAAGI,GAIHP,EAAGsB,EAAQI,QAASC,IACO,UAAnBL,EAAQI,eACD7B,KAAKC,iBAAiByB,EAAMnB,IAEvCD,EAAGwB,OAKnB/B,gBAAgBgC,EAAUzB,GACtB,MAAMH,EAAKH,KAAKC,iBAAiB8B,EAASxB,IAAKC,EAAOwB,4BAA4BD,EAASvB,MAAOyB,EAAc9C,EAAM+C,WAAWF,4BAA4BD,EAAStB,OAEhKJ,EAAOd,EAAS4C,YAAYJ,EAAS1B,MACvCA,EAAK+B,cAGLjC,EAAGkC,MAAM7B,EAAM,EAAGA,EAAK8B,OAAQjC,EAAKkC,eAAiBpC,EAAGqC,SAAW,EAAIV,IACnE,SAASW,IAELtC,EAAGM,KAAK,CAACqB,EAAGnB,KACJmB,EACAxB,EAAGwB,GAGCnB,EAAM+B,OAAST,EAAYS,KAC3BvC,EAAGwC,MAAMV,EAAYS,KAAOZ,IACxBxB,EAAGwB,EAAG3B,KAIVG,EAAGwB,EAAG3B,KAKlB2B,EACAxB,EAAGwB,GAMEzB,EAAKkC,eAMNE,IALAtC,EAAGyC,SAASpC,EAAK8B,OAAQ,KACrBG,QAUhBnC,EAAG,KAAMH","file":"../../../providers/worker/file-descriptor-argument-converter.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"../../utils\",\r\n    \"./misc\",\r\n    \"./special-arg-type\"\r\n], function (Buffer, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,utils,misc,SpecialArgType) {\r\n\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer, emptyBuffer }  = utils;\r\n    /**\r\n     * @hidden\r\n     */\r\n    class FileDescriptorArgumentConverter {\r\n        constructor() {\r\n            this._fileDescriptors = {};\r\n            this._nextId = 0;\r\n        }\r\n        toRemoteArg(fd, p, flag, cb) {\r\n            const id = this._nextId++;\r\n            let data;\r\n            let stat;\r\n            this._fileDescriptors[id] = fd;\r\n            // Extract needed information asynchronously.\r\n            fd.stat((err, stats) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else {\r\n                    stat = misc.bufferToTransferrableObject(stats.toBuffer());\r\n                    // If it's a readable flag, we need to grab contents.\r\n                    if (flag.isReadable()) {\r\n                        fd.read(Buffer.alloc(stats.size), 0, stats.size, 0, (err, bytesRead, buff) => {\r\n                            if (err) {\r\n                                cb(err);\r\n                            }\r\n                            else {\r\n                                data = misc.bufferToTransferrableObject(buff);\r\n                                cb(null, {\r\n                                    type: SpecialArgType.FD,\r\n                                    id: id,\r\n                                    data: data,\r\n                                    stat: stat,\r\n                                    path: p,\r\n                                    flag: flag.getFlagString()\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        // File is not readable, which means writing to it will append or\r\n                        // truncate/replace existing contents. Return an empty arraybuffer.\r\n                        cb(null, {\r\n                            type: SpecialArgType.FD,\r\n                            id: id,\r\n                            data: new ArrayBuffer(0),\r\n                            stat: stat,\r\n                            path: p,\r\n                            flag: flag.getFlagString()\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        applyFdAPIRequest(request, cb) {\r\n            const fdArg = request.args[0];\r\n            this._applyFdChanges(fdArg, (err, fd) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else {\r\n                    // Apply method on now-changed file descriptor.\r\n                    fd[request.method]((e) => {\r\n                        if (request.method === 'close') {\r\n                            delete this._fileDescriptors[fdArg.id];\r\n                        }\r\n                        cb(e);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        _applyFdChanges(remoteFd, cb) {\r\n            const fd = this._fileDescriptors[remoteFd.id], data = transferrableObjectToBuffer(remoteFd.data), remoteStats = Stats.fromBuffer(transferrableObjectToBuffer(remoteFd.stat));\r\n            // Write data if the file is writable.\r\n            const flag = FileFlag.getFileFlag(remoteFd.flag);\r\n            if (flag.isWriteable()) {\r\n                // Appendable: Write to end of file.\r\n                // Writeable: Replace entire contents of file.\r\n                fd.write(data, 0, data.length, flag.isAppendable() ? fd.getPos() : 0, (e) => {\r\n                    function applyStatChanges() {\r\n                        // Check if mode changed.\r\n                        fd.stat((e, stats) => {\r\n                            if (e) {\r\n                                cb(e);\r\n                            }\r\n                            else {\r\n                                if (stats.mode !== remoteStats.mode) {\r\n                                    fd.chmod(remoteStats.mode, (e) => {\r\n                                        cb(e, fd);\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    cb(e, fd);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    if (e) {\r\n                        cb(e);\r\n                    }\r\n                    else {\r\n                        // If writeable & not appendable, we need to ensure file contents are\r\n                        // identical to those from the remote FD. Thus, we truncate to the\r\n                        // length of the remote file.\r\n                        if (!flag.isAppendable()) {\r\n                            fd.truncate(data.length, () => {\r\n                                applyStatChanges();\r\n                            });\r\n                        }\r\n                        else {\r\n                            applyStatChanges();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                cb(null, fd);\r\n            }\r\n        }\r\n    }\r\n\r\n    return FileDescriptorArgumentConverter;\r\n});"]}