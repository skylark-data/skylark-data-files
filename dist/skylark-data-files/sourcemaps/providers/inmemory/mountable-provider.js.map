{"version":3,"sources":["providers/inmemory/mountable-provider.js"],"names":["define","paths","files","registry","BaseProvider","InMemoryProvider","FileError","ErrorCodes","utils","mkdirpSync","MountableProvider","[object Object]","rootFs","super","this","mountList","mntMap","opts","cb","Create","e","imfs","fs","Object","keys","forEach","mountPoint","mount","resolve","EINVAL","push","sort","a","b","length","splice","indexOf","readdirSync","rmdirSync","dirname","path","len","i","substr","Name","err","realPath","index","message","oldPath","newPath","fs1rv","_getFs","fs2rv","rename","standardizeError","readFile","data","writeFile","unlink","renameSync","readFileSync","writeFileSync","unlinkSync","p","fsInfo","rv","rv2","concat","filter","val","readdir","cache","mountedPath","realpathSync","join","realpath","_containsMountPt","ENOTEMPTY","rmdir","mountPoints","pt","slice","defineFcn","name","isSync","numArgs","args","apply","Options","fsCmdMap","cmds","fnName","prototype","providers"],"mappings":"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","file":"../../../providers/inmemory/mountable-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    \"../../files\",\r\n    \"../registry\",\r\n    \"../base-provider\",\r\n    './in-memory-provider',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../../utils'\r\n], function (paths,files,registry,BaseProvider, InMemoryProvider, FileError, ErrorCodes, utils) {\r\n    'use strict';\r\n    const { mkdirpSync }  = utils;\r\n\r\n    /**\r\n     * The mountable filesystem provider allows you to mount multiple backend types or\r\n     * multiple instantiations of the same backend into a single file system tree.\r\n     * The file systems do not need to know about each other; all interactions are\r\n     * automatically facilitated through this interface.\r\n     *\r\n     * For example, if a file system is mounted at /mnt/blah, and a request came in\r\n     * for /mnt/blah/foo.txt, the file system would see a request for /foo.txt.\r\n     *\r\n     * You can mount file systems when you configure the file system:\r\n     * ```javascript\r\n     * BrowserFS.configure({\r\n     *   fs: \"MountableProvider\",\r\n     *   options: {\r\n     *     '/data': { fs: 'HTTPRequest', options: { index: \"http://mysite.com/files/index.json\" } },\r\n     *     '/home': { fs: 'LocalStorage' }\r\n     *   }\r\n     * }, function(e) {\r\n     *\r\n     * });\r\n     * ```\r\n     *\r\n     * For advanced users, you can also mount file systems *after* MFS is constructed:\r\n     * ```javascript\r\n     * BrowserFS.Provider.HTTPRequest.Create({\r\n     *   index: \"http://mysite.com/files/index.json\"\r\n     * }, function(e, xhrfs) {\r\n     *   BrowserFS.Provider.MountableProvider.Create({\r\n     *     '/data': xhrfs\r\n     *   }, function(e, mfs) {\r\n     *     BrowserFS.initialize(mfs);\r\n     *\r\n     *     // Added after-the-fact...\r\n     *     BrowserFS.Provider.LocalStorage.Create(function(e, lsfs) {\r\n     *       mfs.mount('/home', lsfs);\r\n     *     });\r\n     *   });\r\n     * });\r\n     * ```\r\n     *\r\n     * Since MountableProvider simply proxies requests to mounted file systems, it supports all of the operations that the mounted file systems support.\r\n     *\r\n     * With no mounted file systems, `MountableProvider` acts as a simple `InMemory` filesystem.\r\n     */\r\n    class MountableProvider extends BaseProvider {\r\n        /**\r\n         * Creates a new, empty MountableProvider.\r\n         */\r\n        constructor(rootFs) {\r\n            super();\r\n            // Contains the list of mount points in mntMap, sorted by string length in decreasing order.\r\n            // Ensures that we scan the most specific mount points for a match first, which lets us\r\n            // nest mount points.\r\n            this.mountList = [];\r\n            this.mntMap = {};\r\n            this.rootFs = rootFs;\r\n        }\r\n        /**\r\n         * Creates a MountableProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            InMemoryProvider.Create({}, (e, imfs) => {\r\n                if (imfs) {\r\n                    const fs = new MountableProvider(imfs);\r\n                    try {\r\n                        Object.keys(opts).forEach((mountPoint) => {\r\n                            fs.mount(mountPoint, opts[mountPoint]);\r\n                        });\r\n                    }\r\n                    catch (e) {\r\n                        return cb(e);\r\n                    }\r\n                    cb(null, fs);\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        /**\r\n         * Mounts the file system at the given mount point.\r\n         */\r\n        mount(mountPoint, fs) {\r\n            if (mountPoint[0] !== '/') {\r\n                mountPoint = `/${mountPoint}`;\r\n            }\r\n            mountPoint = paths.resolve(mountPoint);\r\n            if (this.mntMap[mountPoint]) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Mount point \" + mountPoint + \" is already taken.\");\r\n            }\r\n            mkdirpSync(mountPoint, 0x1ff, this.rootFs);\r\n            this.mntMap[mountPoint] = fs;\r\n            this.mountList.push(mountPoint);\r\n            this.mountList = this.mountList.sort((a, b) => b.length - a.length);\r\n        }\r\n        umount(mountPoint) {\r\n            if (mountPoint[0] !== '/') {\r\n                mountPoint = `/${mountPoint}`;\r\n            }\r\n            mountPoint = paths.resolve(mountPoint);\r\n            if (!this.mntMap[mountPoint]) {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Mount point \" + mountPoint + \" is already unmounted.\");\r\n            }\r\n            delete this.mntMap[mountPoint];\r\n            this.mountList.splice(this.mountList.indexOf(mountPoint), 1);\r\n            while (mountPoint !== '/') {\r\n                if (this.rootFs.readdirSync(mountPoint).length === 0) {\r\n                    this.rootFs.rmdirSync(mountPoint);\r\n                    mountPoint = paths.dirname(mountPoint);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Returns the file system that the path points to.\r\n         */\r\n        _getFs(path) {\r\n            const mountList = this.mountList, len = mountList.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const mountPoint = mountList[i];\r\n                // We know path is normalized, so it is a substring of the mount point.\r\n                if (mountPoint.length <= path.length && path.indexOf(mountPoint) === 0) {\r\n                    path = path.substr(mountPoint.length > 1 ? mountPoint.length : 0);\r\n                    if (path === '') {\r\n                        path = '/';\r\n                    }\r\n                    return { fs: this.mntMap[mountPoint], path: path, mountPoint: mountPoint };\r\n                }\r\n            }\r\n            // Query our root file system.\r\n            return { fs: this.rootFs, path: path, mountPoint: '/' };\r\n        }\r\n        // Global information methods\r\n        getName() {\r\n            return MountableProvider.Name;\r\n        }\r\n        diskSpace(path, cb) {\r\n            cb(0, 0);\r\n        }\r\n        isReadOnly() {\r\n            return false;\r\n        }\r\n        supportsLinks() {\r\n            // I'm not ready for cross-FS links yet.\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        /**\r\n         * Fixes up error messages so they mention the mounted file location relative\r\n         * to the MFS root, not to the particular FS's root.\r\n         * Mutates the input error, and returns it.\r\n         */\r\n        standardizeError(err, path, realPath) {\r\n            const index = err.message.indexOf(path);\r\n            if (index !== -1) {\r\n                err.message = err.message.substr(0, index) + realPath + err.message.substr(index + path.length);\r\n                err.path = realPath;\r\n            }\r\n            return err;\r\n        }\r\n        // The following methods involve multiple file systems, and thus have custom\r\n        // logic.\r\n        // Note that we go through the Node API to use its robust default argument\r\n        // processing.\r\n        rename(oldPath, newPath, cb) {\r\n            // Scenario 1: old and new are on same FS.\r\n            const fs1rv = this._getFs(oldPath);\r\n            const fs2rv = this._getFs(newPath);\r\n            if (fs1rv.fs === fs2rv.fs) {\r\n                return fs1rv.fs.rename(fs1rv.path, fs2rv.path, (e) => {\r\n                    if (e) {\r\n                        this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\r\n                    }\r\n                    cb(e);\r\n                });\r\n            }\r\n            // Scenario 2: Different file systems.\r\n            // Read old file, write new file, delete old file.\r\n            return fs.readFile(oldPath, function (err, data) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                fs.writeFile(newPath, data, function (err) {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    fs.unlink(oldPath, cb);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            // Scenario 1: old and new are on same FS.\r\n            const fs1rv = this._getFs(oldPath);\r\n            const fs2rv = this._getFs(newPath);\r\n            if (fs1rv.fs === fs2rv.fs) {\r\n                try {\r\n                    return fs1rv.fs.renameSync(fs1rv.path, fs2rv.path);\r\n                }\r\n                catch (e) {\r\n                    this.standardizeError(this.standardizeError(e, fs1rv.path, oldPath), fs2rv.path, newPath);\r\n                    throw e;\r\n                }\r\n            }\r\n            // Scenario 2: Different file systems.\r\n            const data = fs.readFileSync(oldPath);\r\n            fs.writeFileSync(newPath, data);\r\n            return fs.unlinkSync(oldPath);\r\n        }\r\n        readdirSync(p) {\r\n            const fsInfo = this._getFs(p);\r\n            // If null, rootfs did not have the directory\r\n            // (or the target FS is the root fs).\r\n            let rv = null;\r\n            // Mount points are all defined in the root FS.\r\n            // Ensure that we list those, too.\r\n            if (fsInfo.fs !== this.rootFs) {\r\n                try {\r\n                    rv = this.rootFs.readdirSync(p);\r\n                }\r\n                catch (e) {\r\n                    // Ignore.\r\n                }\r\n            }\r\n            try {\r\n                const rv2 = fsInfo.fs.readdirSync(fsInfo.path);\r\n                if (rv === null) {\r\n                    return rv2;\r\n                }\r\n                else {\r\n                    // Filter out duplicates.\r\n                    return rv2.concat(rv.filter((val) => rv2.indexOf(val) === -1));\r\n                }\r\n            }\r\n            catch (e) {\r\n                if (rv === null) {\r\n                    throw this.standardizeError(e, fsInfo.path, p);\r\n                }\r\n                else {\r\n                    // The root FS had something.\r\n                    return rv;\r\n                }\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            fsInfo.fs.readdir(fsInfo.path, (err, files) => {\r\n                if (fsInfo.fs !== this.rootFs) {\r\n                    try {\r\n                        const rv = this.rootFs.readdirSync(p);\r\n                        if (files) {\r\n                            // Filter out duplicates.\r\n                            files = files.concat(rv.filter((val) => files.indexOf(val) === -1));\r\n                        }\r\n                        else {\r\n                            files = rv;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        // Root FS and target FS did not have directory.\r\n                        if (err) {\r\n                            return cb(this.standardizeError(err, fsInfo.path, p));\r\n                        }\r\n                    }\r\n                }\r\n                else if (err) {\r\n                    // Root FS and target FS are the same, and did not have directory.\r\n                    return cb(this.standardizeError(err, fsInfo.path, p));\r\n                }\r\n                cb(null, files);\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            const fsInfo = this._getFs(p);\r\n            try {\r\n                const mountedPath = fsInfo.fs.realpathSync(fsInfo.path, {});\r\n                // resolve is there to remove any trailing slash that may be present\r\n                return paths.resolve(paths.join(fsInfo.mountPoint, mountedPath));\r\n            }\r\n            catch (e) {\r\n                throw this.standardizeError(e, fsInfo.path, p);\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            fsInfo.fs.realpath(fsInfo.path, {}, (err, rv) => {\r\n                if (err) {\r\n                    cb(this.standardizeError(err, fsInfo.path, p));\r\n                }\r\n                else {\r\n                    // resolve is there to remove any trailing slash that may be present\r\n                    cb(null, paths.resolve(paths.join(fsInfo.mountPoint, rv)));\r\n                }\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            const fsInfo = this._getFs(p);\r\n            if (this._containsMountPt(p)) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                try {\r\n                    fsInfo.fs.rmdirSync(fsInfo.path);\r\n                }\r\n                catch (e) {\r\n                    throw this.standardizeError(e, fsInfo.path, p);\r\n                }\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            const fsInfo = this._getFs(p);\r\n            if (this._containsMountPt(p)) {\r\n                cb(FileError.ENOTEMPTY(p));\r\n            }\r\n            else {\r\n                fsInfo.fs.rmdir(fsInfo.path, (err) => {\r\n                    cb(err ? this.standardizeError(err, fsInfo.path, p) : null);\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Returns true if the given path contains a mount point.\r\n         */\r\n        _containsMountPt(p) {\r\n            const mountPoints = this.mountList, len = mountPoints.length;\r\n            for (let i = 0; i < len; i++) {\r\n                const pt = mountPoints[i];\r\n                if (pt.length >= p.length && pt.slice(0, p.length) === p) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    MountableProvider.Name = \"MountableProvider\";\r\n    MountableProvider.Options = {};\r\n    /**\r\n     * Tricky: Define all of the functions that merely forward arguments to the\r\n     * relevant file system, or return/throw an error.\r\n     * Take advantage of the fact that the *first* argument is always the path, and\r\n     * the *last* is the callback function (if async).\r\n     * @todo Can use numArgs to make proxying more efficient.\r\n     * @hidden\r\n     */\r\n    function defineFcn(name, isSync, numArgs) {\r\n        if (isSync) {\r\n            return function (...args) {\r\n                const path = args[0];\r\n                const rv = this._getFs(path);\r\n                args[0] = rv.path;\r\n                try {\r\n                    return rv.fs[name].apply(rv.fs, args);\r\n                }\r\n                catch (e) {\r\n                    this.standardizeError(e, rv.path, path);\r\n                    throw e;\r\n                }\r\n            };\r\n        }\r\n        else {\r\n            return function (...args) {\r\n                const path = args[0];\r\n                const rv = this._getFs(path);\r\n                args[0] = rv.path;\r\n                if (typeof args[args.length - 1] === 'function') {\r\n                    const cb = args[args.length - 1];\r\n                    args[args.length - 1] = (...args) => {\r\n                        if (args.length > 0 && args[0] instanceof FileError) {\r\n                            this.standardizeError(args[0], rv.path, path);\r\n                        }\r\n                        cb.apply(null, args);\r\n                    };\r\n                }\r\n                return rv.fs[name].apply(rv.fs, args);\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    const fsCmdMap = [\r\n        // 1 arg functions\r\n        ['exists', 'unlink', 'readlink'],\r\n        // 2 arg functions\r\n        ['stat', 'mkdir', 'truncate'],\r\n        // 3 arg functions\r\n        ['open', 'readFile', 'chmod', 'utimes'],\r\n        // 4 arg functions\r\n        ['chown'],\r\n        // 5 arg functions\r\n        ['writeFile', 'appendFile']\r\n    ];\r\n    for (let i = 0; i < fsCmdMap.length; i++) {\r\n        const cmds = fsCmdMap[i];\r\n        for (const fnName of cmds) {\r\n            MountableProvider.prototype[fnName] = defineFcn(fnName, false, i + 1);\r\n            MountableProvider.prototype[fnName + 'Sync'] = defineFcn(fnName + 'Sync', true, i + 1);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.MountableProvider = MountableProvider;\r\n});"]}