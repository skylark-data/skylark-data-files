{"version":3,"sources":["providers/base-provider.js"],"names":["define","Bufer","path","ErrorCodes","FileError","ActionType","FileFlag","utils","fail","[object Object]","p","cb","flag","ENOTSUP","mode","this","stat","e","stats","pathNotExistsAction","CREATE_FILE","dirname","parentStats","isDirectory","ENOTDIR","createFile","THROW_EXCEPTION","ENOENT","EINVAL","EISDIR","pathExistsAction","EEXIST","TRUNCATE_FILE","openFile","fd","truncate","sync","NOP","oldPath","newPath","isLstat","statSync","createFileSync","unlinkSync","openFileSync","err","cache","supportsLinks","splitPath","split","sep","i","length","addPaths","slice","join","apply","exists","doesExist","existsSync","len","open","getFileFlag","er","close","er2","openSync","truncateSync","closeSync","fname","encoding","oldCb","arg","err2","buf","Buffer","alloc","size","read","toString","readSync","data","from","write","writeSync","isLchmod","isLchown","uid","gid","atime","mtime","srcpath","dstpath","type"],"mappings":"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","file":"../../providers/base-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths/path\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils'\r\n], function (Bufer,path, ErrorCodes, FileError, ActionType, FileFlag, utils) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Basic filesystem class. Most filesystems should extend this class, as it\r\n     * provides default implementations for a handful of methods.\r\n     */\r\n    class BaseProvider {\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        diskSpace(p, cb) {\r\n            cb(0, 0);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         */\r\n        openFile(p, flag, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFile(p, flag, mode, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            const mustBeFile = (e, stats) => {\r\n                if (e) {\r\n                    // File does not exist.\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            // Ensure parent exists.\r\n                            return this.stat(path.dirname(p), false, (e, parentStats) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (parentStats && !parentStats.isDirectory()) {\r\n                                    cb(FileError.ENOTDIR(path.dirname(p)));\r\n                                }\r\n                                else {\r\n                                    this.createFile(p, flag, mode, cb);\r\n                                }\r\n                            });\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.ENOENT(p));\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n                else {\r\n                    // File exists.\r\n                    if (stats && stats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(p));\r\n                    }\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.EEXIST(p));\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            // NOTE: In a previous implementation, we deleted the file and\r\n                            // re-created it. However, this created a race condition if another\r\n                            // asynchronous request was trying to read the file, as the file\r\n                            // would not exist for a small period of time.\r\n                            return this.openFile(p, flag, (e, fd) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (fd) {\r\n                                    fd.truncate(0, () => {\r\n                                        fd.sync(() => {\r\n                                            cb(null, fd);\r\n                                        });\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    fail();\r\n                                }\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this.openFile(p, flag, cb);\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n            };\r\n            this.stat(p, false, mustBeFile);\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        statSync(p, isLstat) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         * @return A File object corresponding to the opened file.\r\n         */\r\n        openFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        openSync(p, flag, mode) {\r\n            // Check if the path exists, and is a file.\r\n            let stats;\r\n            try {\r\n                stats = this.statSync(p, false);\r\n            }\r\n            catch (e) {\r\n                // File does not exist.\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        // Ensure parent exists.\r\n                        const parentStats = this.statSync(path.dirname(p), false);\r\n                        if (!parentStats.isDirectory()) {\r\n                            throw FileError.ENOTDIR(path.dirname(p));\r\n                        }\r\n                        return this.createFileSync(p, flag, mode);\r\n                    case ActionType.THROW_EXCEPTION:\r\n                        throw FileError.ENOENT(p);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n                }\r\n            }\r\n            // File exists.\r\n            if (stats.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            switch (flag.pathExistsAction()) {\r\n                case ActionType.THROW_EXCEPTION:\r\n                    throw FileError.EEXIST(p);\r\n                case ActionType.TRUNCATE_FILE:\r\n                    // Delete file.\r\n                    this.unlinkSync(p);\r\n                    // Create file. Use the same mode as the old file.\r\n                    // Node itself modifies the ctime when this occurs, so this action\r\n                    // will preserve that behavior if the underlying file system\r\n                    // supports those properties.\r\n                    return this.createFileSync(p, flag, stats.mode);\r\n                case ActionType.NOP:\r\n                    return this.openFileSync(p, flag, mode);\r\n                default:\r\n                    throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        unlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        rmdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        rmdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        mkdirSync(p, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        exists(p, cb) {\r\n            this.stat(p, null, function (err) {\r\n                cb(!err);\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            try {\r\n                this.statSync(p, true);\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(path.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = path.join.apply(null, addPaths);\r\n                }\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                this.exists(p, function (doesExist) {\r\n                    if (doesExist) {\r\n                        cb(null, p);\r\n                    }\r\n                    else {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(path.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = path.join.apply(path, addPaths);\r\n                }\r\n                return splitPath.join(path.sep);\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                if (this.existsSync(p)) {\r\n                    return p;\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        truncate(p, len, cb) {\r\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\r\n                if (er) {\r\n                    return cb(er);\r\n                }\r\n                fd.truncate(len, (function (er) {\r\n                    fd.close((function (er2) {\r\n                        cb(er || er2);\r\n                    }));\r\n                }));\r\n            }));\r\n        }\r\n        truncateSync(p, len) {\r\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\r\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\r\n            try {\r\n                fd.truncateSync(len);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, (err, fd) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                fd.stat((err, stat) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    // Allocate buffer.\r\n                    const buf = Buffer.alloc(stat.size);\r\n                    fd.read(buf, 0, stat.size, 0, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        else if (encoding === null) {\r\n                            return cb(err, buf);\r\n                        }\r\n                        try {\r\n                            cb(null, buf.toString(encoding));\r\n                        }\r\n                        catch (e) {\r\n                            cb(e);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const stat = fd.statSync();\r\n                // Allocate buffer.\r\n                const buf = Buffer.alloc(stat.size);\r\n                fd.readSync(buf, 0, stat.size, 0);\r\n                fd.closeSync();\r\n                if (encoding === null) {\r\n                    return buf;\r\n                }\r\n                return buf.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                try {\r\n                    if (typeof data === 'string') {\r\n                        data = Buffer.from(data, encoding);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return cb(e);\r\n                }\r\n                // Write into file.\r\n                fd.write(data, 0, data.length, 0, cb);\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                // Write into file.\r\n                fd.writeSync(data, 0, data.length, 0);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            this.open(fname, flag, mode, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.write(data, 0, data.length, null, cb);\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.writeSync(data, 0, data.length, null);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n\r\n\r\n    return BaseProvider;\r\n});"]}