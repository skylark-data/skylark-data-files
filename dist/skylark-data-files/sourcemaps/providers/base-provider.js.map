{"version":3,"sources":["providers/base-provider.js"],"names":["define","Buffer","paths","files","ErrorCodes","FileError","ActionType","FileFlag","utils","fail","providers","BaseProvider","[object Object]","p","cb","flag","ENOTSUP","mode","this","stat","e","stats","pathNotExistsAction","CREATE_FILE","dirname","parentStats","isDirectory","ENOTDIR","createFile","THROW_EXCEPTION","ENOENT","EINVAL","EISDIR","pathExistsAction","EEXIST","TRUNCATE_FILE","openFile","fd","truncate","sync","NOP","oldPath","newPath","isLstat","statSync","createFileSync","unlinkSync","openFileSync","err","cache","supportsLinks","splitPath","split","sep","i","length","addPaths","slice","join","apply","exists","doesExist","path","existsSync","len","open","getFileFlag","er","close","er2","openSync","truncateSync","closeSync","fname","encoding","oldCb","arg","err2","buf","alloc","size","read","toString","readSync","data","from","write","writeSync","isLchmod","isLchown","uid","gid","atime","mtime","srcpath","dstpath","type"],"mappings":"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","file":"../../providers/base-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils'\r\n], function (Buffer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Basic filesystem class. Most filesystems should extend this class, as it\r\n     * provides default implementations for a handful of methods.\r\n     */\r\n    class BaseProvider {\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        diskSpace(p, cb) {\r\n            cb(0, 0);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         */\r\n        openFile(p, flag, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFile(p, flag, mode, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            const mustBeFile = (e, stats) => {\r\n                if (e) {\r\n                    // File does not exist.\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            // Ensure parent exists.\r\n                            return this.stat(paths.dirname(p), false, (e, parentStats) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (parentStats && !parentStats.isDirectory()) {\r\n                                    cb(FileError.ENOTDIR(paths.dirname(p)));\r\n                                }\r\n                                else {\r\n                                    this.createFile(p, flag, mode, cb);\r\n                                }\r\n                            });\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.ENOENT(p));\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n                else {\r\n                    // File exists.\r\n                    if (stats && stats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(p));\r\n                    }\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.EEXIST(p));\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            // NOTE: In a previous implementation, we deleted the file and\r\n                            // re-created it. However, this created a race condition if another\r\n                            // asynchronous request was trying to read the file, as the file\r\n                            // would not exist for a small period of time.\r\n                            return this.openFile(p, flag, (e, fd) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (fd) {\r\n                                    fd.truncate(0, () => {\r\n                                        fd.sync(() => {\r\n                                            cb(null, fd);\r\n                                        });\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    fail();\r\n                                }\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this.openFile(p, flag, cb);\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n            };\r\n            this.stat(p, false, mustBeFile);\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        statSync(p, isLstat) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         * @return A File object corresponding to the opened file.\r\n         */\r\n        openFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        openSync(p, flag, mode) {\r\n            // Check if the path exists, and is a file.\r\n            let stats;\r\n            try {\r\n                stats = this.statSync(p, false);\r\n            }\r\n            catch (e) {\r\n                // File does not exist.\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        // Ensure parent exists.\r\n                        const parentStats = this.statSync(paths.dirname(p), false);\r\n                        if (!parentStats.isDirectory()) {\r\n                            throw FileError.ENOTDIR(paths.dirname(p));\r\n                        }\r\n                        return this.createFileSync(p, flag, mode);\r\n                    case ActionType.THROW_EXCEPTION:\r\n                        throw FileError.ENOENT(p);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n                }\r\n            }\r\n            // File exists.\r\n            if (stats.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            switch (flag.pathExistsAction()) {\r\n                case ActionType.THROW_EXCEPTION:\r\n                    throw FileError.EEXIST(p);\r\n                case ActionType.TRUNCATE_FILE:\r\n                    // Delete file.\r\n                    this.unlinkSync(p);\r\n                    // Create file. Use the same mode as the old file.\r\n                    // Node itself modifies the ctime when this occurs, so this action\r\n                    // will preserve that behavior if the underlying file system\r\n                    // supports those properties.\r\n                    return this.createFileSync(p, flag, stats.mode);\r\n                case ActionType.NOP:\r\n                    return this.openFileSync(p, flag, mode);\r\n                default:\r\n                    throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        unlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        rmdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        rmdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        mkdirSync(p, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        exists(p, cb) {\r\n            this.stat(p, null, function (err) {\r\n                cb(!err);\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            try {\r\n                this.statSync(p, true);\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(null, addPaths);\r\n                }\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                this.exists(p, function (doesExist) {\r\n                    if (doesExist) {\r\n                        cb(null, p);\r\n                    }\r\n                    else {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(path, addPaths);\r\n                }\r\n                return splitPath.join(paths.sep);\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                if (this.existsSync(p)) {\r\n                    return p;\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        truncate(p, len, cb) {\r\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\r\n                if (er) {\r\n                    return cb(er);\r\n                }\r\n                fd.truncate(len, (function (er) {\r\n                    fd.close((function (er2) {\r\n                        cb(er || er2);\r\n                    }));\r\n                }));\r\n            }));\r\n        }\r\n        truncateSync(p, len) {\r\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\r\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\r\n            try {\r\n                fd.truncateSync(len);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, (err, fd) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                fd.stat((err, stat) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    // Allocate buffer.\r\n                    const buf = Buffer.alloc(stat.size);\r\n                    fd.read(buf, 0, stat.size, 0, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        else if (encoding === null) {\r\n                            return cb(err, buf);\r\n                        }\r\n                        try {\r\n                            cb(null, buf.toString(encoding));\r\n                        }\r\n                        catch (e) {\r\n                            cb(e);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const stat = fd.statSync();\r\n                // Allocate buffer.\r\n                const buf = Buffer.alloc(stat.size);\r\n                fd.readSync(buf, 0, stat.size, 0);\r\n                fd.closeSync();\r\n                if (encoding === null) {\r\n                    return buf;\r\n                }\r\n                return buf.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                try {\r\n                    if (typeof data === 'string') {\r\n                        data = Buffer.from(data, encoding);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return cb(e);\r\n                }\r\n                // Write into file.\r\n                fd.write(data, 0, data.length, 0, cb);\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                // Write into file.\r\n                fd.writeSync(data, 0, data.length, 0);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            this.open(fname, flag, mode, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.write(data, 0, data.length, null, cb);\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.writeSync(data, 0, data.length, null);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.BaseProvider = BaseProvider;\r\n});"]}