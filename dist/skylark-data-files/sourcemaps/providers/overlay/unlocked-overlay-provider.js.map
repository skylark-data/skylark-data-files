{"version":3,"sources":["providers/overlay/unlocked-overlay-provider.js"],"names":["define","paths","BaseProvider","Stats","FileType","FileError","ErrorCodes","FileFlag","ActionType","OverlayFile","deletionLogPath","makeModeWritable","mode","getFlag","f","getFileFlag","[object Object]","writable","readable","super","this","_isInitialized","_initializeCallbacks","_deletedFiles","_deleteLog","_deleteLogUpdatePending","_deleteLogUpdateNeeded","_deleteLogError","_writable","_readable","isReadOnly","ApiError","ErrorCode","EINVAL","file","cb","createParentDirectoriesAsync","getPath","err","writeFile","getBuffer","getStats","createParentDirectories","writeFileSync","OverlayFS","Name","callbackArray","end","e","forEach","push","length","readFile","data","errno","ENOENT","_reparseDeletionLog","supportsSynch","supportsProps","log","updateLog","oldPath","newPath","checkInitAsync","checkPathAsync","EPERM","stat","oldErr","oldStats","newErr","newStats","self","copyDirContents","files","shift","oldFile","resolve","newFile","rename","isDirectory","exists","mkdir","mkdirErr","readdir","ENOTDIR","readdirErr","ENOTEMPTY","EISDIR","unlink","checkInitialized","checkPath","statSync","existsSync","stats","readdirSync","renameSync","mkdirSync","name","readFileSync","unlinkSync","p","isLstat","clone","oldStat","flag","pathExistsAction","TRUNCATE_FILE","open","NOP","readFileErr","size","EEXIST","pathNotExistsAction","CREATE_FILE","openSync","buf","writableExists","readableExists","deletePath","rmdirLower","rmdir","rmdirSync","dirStats","wFiles","code","rFiles","seenMap","filtered","concat","filter","fPath","result","contents","fileP","existsWritable","existsReadable","isLchmod","operateOnWritableAsync","chmod","operateOnWritable","chmodSync","uid","gid","chown","isLchown","chownSync","atime","mtime","utimes","utimesSync","addition","split","path","slice","parent","dirname","toCreate","statDone","EBUSY","createParents","dir","pop","reverse","copyToWritable","copyToWritableAsync","pStats"],"mappings":"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","file":"../../../providers/overlay/unlocked-overlay-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-paths\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"./overlay-file\"\r\n], function (paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,OverlayFile) {\r\n    /**\r\n     * @hidden\r\n     */\r\n    const deletionLogPath = '/.deletedFiles.log';\r\n\r\n    /**\r\n     * Given a read-only mode, makes it writable.\r\n     * @hidden\r\n     */\r\n    function makeModeWritable(mode) {\r\n        return 0o222 | mode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFlag(f) {\r\n        return FileFlag.getFileFlag(f);\r\n    }    \r\n     /**\r\n     * *INTERNAL, DO NOT USE DIRECTLY!*\r\n     *\r\n     * Core OverlayProviderclass that contains no locking whatsoever. We wrap these objects\r\n     * in a LockedFS to prevent races.\r\n     */\r\n    class UnlockedOverlayProvider extends BaseProvider {\r\n        constructor(writable, readable) {\r\n            super();\r\n            this._isInitialized = false;\r\n            this._initializeCallbacks = [];\r\n            this._deletedFiles = {};\r\n            this._deleteLog = '';\r\n            // If 'true', we have scheduled a delete log update.\r\n            this._deleteLogUpdatePending = false;\r\n            // If 'true', a delete log update is needed after the scheduled delete log\r\n            // update finishes.\r\n            this._deleteLogUpdateNeeded = false;\r\n            // If there was an error updating the delete log...\r\n            this._deleteLogError = null;\r\n            this._writable = writable;\r\n            this._readable = readable;\r\n            if (this._writable.isReadOnly()) {\r\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getOverlayedProviders() {\r\n            return {\r\n                readable: this._readable,\r\n                writable: this._writable\r\n            };\r\n        }\r\n        _syncAsync(file, cb) {\r\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\r\n            });\r\n        }\r\n        _syncSync(file) {\r\n            this.createParentDirectories(file.getPath());\r\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\r\n        }\r\n        getName() {\r\n            return OverlayFS.Name;\r\n        }\r\n        /**\r\n         * **INTERNAL METHOD**\r\n         *\r\n         * Called once to load up metadata stored on the writable file system.\r\n         */\r\n        _initialize(cb) {\r\n            const callbackArray = this._initializeCallbacks;\r\n            const end = (e) => {\r\n                this._isInitialized = !e;\r\n                this._initializeCallbacks = [];\r\n                callbackArray.forEach(((cb) => cb(e)));\r\n            };\r\n            // if we're already initialized, immediately invoke the callback\r\n            if (this._isInitialized) {\r\n                return cb();\r\n            }\r\n            callbackArray.push(cb);\r\n            // The first call to initialize initializes, the rest wait for it to complete.\r\n            if (callbackArray.length !== 1) {\r\n                return;\r\n            }\r\n            // Read deletion log, process into metadata.\r\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\r\n                if (err) {\r\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\r\n                    if (err.errno !== ErrorCode.ENOENT) {\r\n                        return end(err);\r\n                    }\r\n                }\r\n                else {\r\n                    this._deleteLog = data;\r\n                }\r\n                this._reparseDeletionLog();\r\n                end();\r\n            });\r\n        }\r\n        isReadOnly() { return false; }\r\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\r\n        supportsLinks() { return false; }\r\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\r\n        getDeletionLog() {\r\n            return this._deleteLog;\r\n        }\r\n        restoreDeletionLog(log) {\r\n            this._deleteLog = log;\r\n            this._reparseDeletionLog();\r\n            this.updateLog('');\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\r\n                return;\r\n            }\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\r\n            }\r\n            // nothing to do if paths match\r\n            if (oldPath === newPath) {\r\n                return cb();\r\n            }\r\n            this.stat(oldPath, false, (oldErr, oldStats) => {\r\n                if (oldErr) {\r\n                    return cb(oldErr);\r\n                }\r\n                return this.stat(newPath, false, (newErr, newStats) => {\r\n                    const self = this;\r\n                    // precondition: both oldPath and newPath exist and are dirs.\r\n                    // decreases: |files|\r\n                    // Need to move *every file/folder* currently stored on\r\n                    // readable to its new location on writable.\r\n                    function copyDirContents(files) {\r\n                        const file = files.shift();\r\n                        if (!file) {\r\n                            return cb();\r\n                        }\r\n                        const oldFile = paths.resolve(oldPath, file);\r\n                        const newFile = paths.resolve(newPath, file);\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        self.rename(oldFile, newFile, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            copyDirContents(files);\r\n                        });\r\n                    }\r\n                    let mode = 0o777;\r\n                    // from linux's rename(2) manpage: oldpath can specify a\r\n                    // directory.  In this case, newpath must either not exist, or\r\n                    // it must specify an empty directory.\r\n                    if (oldStats.isDirectory()) {\r\n                        if (newErr) {\r\n                            if (newErr.errno !== ErrorCode.ENOENT) {\r\n                                return cb(newErr);\r\n                            }\r\n                            return this._writable.exists(oldPath, (exists) => {\r\n                                // simple case - both old and new are on the writable layer\r\n                                if (exists) {\r\n                                    return this._writable.rename(oldPath, newPath, cb);\r\n                                }\r\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\r\n                                    if (mkdirErr) {\r\n                                        return cb(mkdirErr);\r\n                                    }\r\n                                    this._readable.readdir(oldPath, (err, files) => {\r\n                                        if (err) {\r\n                                            return cb();\r\n                                        }\r\n                                        copyDirContents(files);\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                        mode = newStats.mode;\r\n                        if (!newStats.isDirectory()) {\r\n                            return cb(ApiError.ENOTDIR(newPath));\r\n                        }\r\n                        this.readdir(newPath, (readdirErr, files) => {\r\n                            if (files && files.length) {\r\n                                return cb(ApiError.ENOTEMPTY(newPath));\r\n                            }\r\n                            this._readable.readdir(oldPath, (err, files) => {\r\n                                if (err) {\r\n                                    return cb();\r\n                                }\r\n                                copyDirContents(files);\r\n                            });\r\n                        });\r\n                    }\r\n                    if (newStats && newStats.isDirectory()) {\r\n                        return cb(ApiError.EISDIR(newPath));\r\n                    }\r\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            return this.unlink(oldPath, cb);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            this.checkInitialized();\r\n            this.checkPath(oldPath);\r\n            this.checkPath(newPath);\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot rename deletion log.');\r\n            }\r\n            // Write newPath using oldPath's contents, delete oldPath.\r\n            const oldStats = this.statSync(oldPath, false);\r\n            if (oldStats.isDirectory()) {\r\n                // Optimization: Don't bother moving if old === new.\r\n                if (oldPath === newPath) {\r\n                    return;\r\n                }\r\n                let mode = 0o777;\r\n                if (this.existsSync(newPath)) {\r\n                    const stats = this.statSync(newPath, false);\r\n                    mode = stats.mode;\r\n                    if (stats.isDirectory()) {\r\n                        if (this.readdirSync(newPath).length > 0) {\r\n                            throw ApiError.ENOTEMPTY(newPath);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw ApiError.ENOTDIR(newPath);\r\n                    }\r\n                }\r\n                // Take care of writable first. Move any files there, or create an empty directory\r\n                // if it doesn't exist.\r\n                if (this._writable.existsSync(oldPath)) {\r\n                    this._writable.renameSync(oldPath, newPath);\r\n                }\r\n                else if (!this._writable.existsSync(newPath)) {\r\n                    this._writable.mkdirSync(newPath, mode);\r\n                }\r\n                // Need to move *every file/folder* currently stored on readable to its new location\r\n                // on writable.\r\n                if (this._readable.existsSync(oldPath)) {\r\n                    this._readable.readdirSync(oldPath).forEach((name) => {\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        this.renameSync(paths.resolve(oldPath, name), paths.resolve(newPath, name));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\r\n                    throw ApiError.EISDIR(newPath);\r\n                }\r\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\r\n            }\r\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\r\n                this.unlinkSync(oldPath);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this._writable.stat(p, isLstat, (err, stat) => {\r\n                if (err && err.errno === ErrorCode.ENOENT) {\r\n                    if (this._deletedFiles[p]) {\r\n                        cb(ApiError.ENOENT(p));\r\n                    }\r\n                    this._readable.stat(p, isLstat, (err, stat) => {\r\n                        if (stat) {\r\n                            // Make the oldStat's mode writable. Preserve the topmost\r\n                            // part of the mode, which specifies if it is a file or a\r\n                            // directory.\r\n                            stat = Stats.clone(stat);\r\n                            stat.mode = makeModeWritable(stat.mode);\r\n                        }\r\n                        cb(err, stat);\r\n                    });\r\n                }\r\n                else {\r\n                    cb(err, stat);\r\n                }\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            this.checkInitialized();\r\n            try {\r\n                return this._writable.statSync(p, isLstat);\r\n            }\r\n            catch (e) {\r\n                if (this._deletedFiles[p]) {\r\n                    throw ApiError.ENOENT(p);\r\n                }\r\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\r\n                // Make the oldStat's mode writable. Preserve the topmost part of the\r\n                // mode, which specifies if it is a file or a directory.\r\n                oldStat.mode = makeModeWritable(oldStat.mode);\r\n                return oldStat;\r\n            }\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, stats) => {\r\n                if (stats) {\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this._writable.exists(p, (exists) => {\r\n                                if (exists) {\r\n                                    this._writable.open(p, flag, mode, cb);\r\n                                }\r\n                                else {\r\n                                    // at this point we know the stats object we got is from\r\n                                    // the readable FS.\r\n                                    stats = Stats.clone(stats);\r\n                                    stats.mode = mode;\r\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\r\n                                        if (readFileErr) {\r\n                                            return cb(readFileErr);\r\n                                        }\r\n                                        if (stats.size === -1) {\r\n                                            stats.size = data.length;\r\n                                        }\r\n                                        const f = new OverlayFile(this, p, flag, stats, data);\r\n                                        cb(null, f);\r\n                                    });\r\n                                }\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.EEXIST(p));\r\n                    }\r\n                }\r\n                else {\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                return this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.ENOENT(p));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot open deletion log.');\r\n            }\r\n            if (this.existsSync(p)) {\r\n                switch (flag.pathExistsAction()) {\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    case ActionType.NOP:\r\n                        if (this._writable.existsSync(p)) {\r\n                            return this._writable.openSync(p, flag, mode);\r\n                        }\r\n                        else {\r\n                            // Create an OverlayFile.\r\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\r\n                            const stats = Stats.clone(this._readable.statSync(p, false));\r\n                            stats.mode = mode;\r\n                            return new OverlayFile(this, p, flag, stats, buf);\r\n                        }\r\n                    default:\r\n                        throw ApiError.EEXIST(p);\r\n                }\r\n            }\r\n            else {\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    default:\r\n                        throw ApiError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        return this._writable.unlink(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    this.deletePath(p);\r\n                                }\r\n                                cb(null);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        // if this only exists on the readable FS, add it to the\r\n                        // delete map.\r\n                        this.deletePath(p);\r\n                        cb(null);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.unlinkSync(p);\r\n                }\r\n                // if it still exists add to the delete log\r\n                if (this.existsSync(p)) {\r\n                    this.deletePath(p);\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            const rmdirLower = () => {\r\n                this.readdir(p, (err, files) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    if (files.length) {\r\n                        return cb(ApiError.ENOTEMPTY(p));\r\n                    }\r\n                    this.deletePath(p);\r\n                    cb(null);\r\n                });\r\n            };\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        this._writable.rmdir(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this._readable.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    rmdirLower();\r\n                                }\r\n                                else {\r\n                                    cb();\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        rmdirLower();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.rmdirSync(p);\r\n                }\r\n                if (this.existsSync(p)) {\r\n                    // Check if directory is empty.\r\n                    if (this.readdirSync(p).length > 0) {\r\n                        throw ApiError.ENOTEMPTY(p);\r\n                    }\r\n                    else {\r\n                        this.deletePath(p);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (exists) {\r\n                    return cb(ApiError.EEXIST(p));\r\n                }\r\n                // The below will throw should any of the parent directories\r\n                // fail to exist on _writable.\r\n                this.createParentDirectoriesAsync(p, (err) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this._writable.mkdir(p, mode, cb);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                throw ApiError.EEXIST(p);\r\n            }\r\n            else {\r\n                // The below will throw should any of the parent directories fail to exist\r\n                // on _writable.\r\n                this.createParentDirectories(p);\r\n                this._writable.mkdirSync(p, mode);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, dirStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (!dirStats.isDirectory()) {\r\n                    return cb(ApiError.ENOTDIR(p));\r\n                }\r\n                this._writable.readdir(p, (err, wFiles) => {\r\n                    if (err && err.code !== 'ENOENT') {\r\n                        return cb(err);\r\n                    }\r\n                    else if (err || !wFiles) {\r\n                        wFiles = [];\r\n                    }\r\n                    this._readable.readdir(p, (err, rFiles) => {\r\n                        // if the directory doesn't exist on the lower FS set rFiles\r\n                        // here to simplify the following code.\r\n                        if (err || !rFiles) {\r\n                            rFiles = [];\r\n                        }\r\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\r\n                        const seenMap = {};\r\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\r\n                            // Remove duplicates.\r\n                            const result = !seenMap[fPath];\r\n                            seenMap[fPath] = true;\r\n                            return result;\r\n                        });\r\n                        cb(null, filtered);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            this.checkInitialized();\r\n            const dirStats = this.statSync(p, false);\r\n            if (!dirStats.isDirectory()) {\r\n                throw ApiError.ENOTDIR(p);\r\n            }\r\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\r\n            let contents = [];\r\n            try {\r\n                contents = contents.concat(this._writable.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            try {\r\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            const seenMap = {};\r\n            return contents.filter((fileP) => {\r\n                const result = !seenMap[fileP];\r\n                seenMap[fileP] = true;\r\n                return result;\r\n            });\r\n        }\r\n        exists(p, cb) {\r\n            // Cannot pass an error back to callback, so throw an exception instead\r\n            // if not initialized.\r\n            this.checkInitialized();\r\n            this._writable.exists(p, (existsWritable) => {\r\n                if (existsWritable) {\r\n                    return cb(true);\r\n                }\r\n                this._readable.exists(p, (existsReadable) => {\r\n                    cb(existsReadable && this._deletedFiles[p] !== true);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            this.checkInitialized();\r\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chmod(p, isLchmod, mode, cb);\r\n                }\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chmodSync(p, isLchmod, mode);\r\n            });\r\n        }\r\n        chown(p, isLchmod, uid, gid, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\r\n                }\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chownSync(p, isLchown, uid, gid);\r\n            });\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.utimes(p, atime, mtime, cb);\r\n                }\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.utimesSync(p, atime, mtime);\r\n            });\r\n        }\r\n        deletePath(p) {\r\n            this._deletedFiles[p] = true;\r\n            this.updateLog(`d${p}\\n`);\r\n        }\r\n        updateLog(addition) {\r\n            this._deleteLog += addition;\r\n            if (this._deleteLogUpdatePending) {\r\n                this._deleteLogUpdateNeeded = true;\r\n            }\r\n            else {\r\n                this._deleteLogUpdatePending = true;\r\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\r\n                    this._deleteLogUpdatePending = false;\r\n                    if (e) {\r\n                        this._deleteLogError = e;\r\n                    }\r\n                    else if (this._deleteLogUpdateNeeded) {\r\n                        this._deleteLogUpdateNeeded = false;\r\n                        this.updateLog('');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        _reparseDeletionLog() {\r\n            this._deletedFiles = {};\r\n            this._deleteLog.split('\\n').forEach((path) => {\r\n                // If the log entry begins w/ 'd', it's a deletion.\r\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\r\n            });\r\n        }\r\n        checkInitialized() {\r\n            if (!this._isInitialized) {\r\n                throw new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\");\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                throw e;\r\n            }\r\n        }\r\n        checkInitAsync(cb) {\r\n            if (!this._isInitialized) {\r\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\"));\r\n                return false;\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                cb(e);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        checkPath(p) {\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM(p);\r\n            }\r\n        }\r\n        checkPathAsync(p, cb) {\r\n            if (p === deletionLogPath) {\r\n                cb(ApiError.EPERM(p));\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createParentDirectoriesAsync(p, cb) {\r\n            let parent = paths.dirname(p);\r\n            const toCreate = [];\r\n            const self = this;\r\n            this._writable.stat(parent, false, statDone);\r\n            function statDone(err, stat) {\r\n                if (err) {\r\n                    if (parent === \"/\") {\r\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\r\n                    }\r\n                    else {\r\n                        toCreate.push(parent);\r\n                        parent = paths.dirname(parent);\r\n                        self._writable.stat(parent, false, statDone);\r\n                    }\r\n                }\r\n                else {\r\n                    createParents();\r\n                }\r\n            }\r\n            function createParents() {\r\n                if (!toCreate.length) {\r\n                    return cb();\r\n                }\r\n                const dir = toCreate.pop();\r\n                self._readable.stat(dir, false, (err, stats) => {\r\n                    // stop if we couldn't read the dir\r\n                    if (!stats) {\r\n                        return cb();\r\n                    }\r\n                    self._writable.mkdir(dir, stats.mode, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        createParents();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * With the given path, create the needed parent directories on the writable storage\r\n         * should they not exist. Use modes from the read-only storage.\r\n         */\r\n        createParentDirectories(p) {\r\n            let parent = paths.dirname(p), toCreate = [];\r\n            while (!this._writable.existsSync(parent)) {\r\n                toCreate.push(parent);\r\n                parent = paths.dirname(parent);\r\n            }\r\n            toCreate = toCreate.reverse();\r\n            toCreate.forEach((p) => {\r\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\r\n            });\r\n        }\r\n        /**\r\n         * Helper function:\r\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\r\n         * - Calls f to perform operation on writable.\r\n         */\r\n        operateOnWritable(p, f) {\r\n            if (this.existsSync(p)) {\r\n                if (!this._writable.existsSync(p)) {\r\n                    // File is on readable storage. Copy to writable storage before\r\n                    // changing its mode.\r\n                    this.copyToWritable(p);\r\n                }\r\n                f();\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        operateOnWritableAsync(p, cb) {\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (existsWritable) => {\r\n                    if (existsWritable) {\r\n                        cb();\r\n                    }\r\n                    else {\r\n                        return this.copyToWritableAsync(p, cb);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Copy from readable to writable storage.\r\n         * PRECONDITION: File does not exist on writable storage.\r\n         */\r\n        copyToWritable(p) {\r\n            const pStats = this.statSync(p, false);\r\n            if (pStats.isDirectory()) {\r\n                this._writable.mkdirSync(p, pStats.mode);\r\n            }\r\n            else {\r\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\r\n            }\r\n        }\r\n        copyToWritableAsync(p, cb) {\r\n            this.stat(p, false, (err, pStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (pStats.isDirectory()) {\r\n                    return this._writable.mkdir(p, pStats.mode, cb);\r\n                }\r\n                // need to copy file.\r\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\r\n                });\r\n            });\r\n        }\r\n    }\r\n \r\n\r\n    return UnlockedOverlayProvider;\r\n});"]}