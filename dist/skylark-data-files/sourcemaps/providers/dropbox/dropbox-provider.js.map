{"version":3,"sources":["providers/dropbox/dropbox-provider.js"],"names":["define","setImmediate","Buffer","paths","files","registry","BaseProvider","Stats","FileType","FileError","ErrorCodes","utils","DropboxFile","arrayBuffer2Buffer","buffer2ArrayBuffer","dirname","FixPath","p","ExtractTheFuckingError","e","obj","error","obj2","reason","JSON","parse","GetErrorMessage","err","user_message","text","error_summary","Error","stringify","LookupErrorToError","msg","EBADF","ENOENT","EISDIR","ENOTDIR","EPERM","EIO","WriteErrorToError","ENOSPC","FilesDeleteWrapped","client","cb","arg","path","filesDeleteV2","then","catch","path_lookup","path_write","setTimeout","Math","random","DropboxProvider","[object Object]","super","this","_client","opts","Dropbox","Name","mainCb","readdir","next","length","shift","oldPath","newPath","stat","stats","rename","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","to","isDirectory","unlink","isLstat","DIRECTORY","filesGetMetadata","ref","fileMetadata","FILE","size","flags","downloadArg","filesDownload","res","b","fileBlob","fr","FileReader","onload","ab","result","byteLength","readAsArrayBuffer","mode","fileData","alloc","commitInfo","contents","Blob","type","filesUpload","metadata","createFile","ENOTEMPTY","parent","filesCreateFolderV2","mkdir","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","map","path_display","filter","concat","has_more","cursor","filesListFolderContinue","ProcessListFolderError","d",".tag","_syncFile","Options","description","add","providers"],"mappings":"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","file":"../../../providers/dropbox/dropbox-provider.js","sourcesContent":["define([\n    \"skylark-langx-funcs/defer\",\n    \"skylark-langx-binary/buffer\",\n    \"skylark-langx-paths\",\n    \"../../files\",\n    \"../registry\",\n    \"../base-provider\",\n    '../../stats',\n    '../../file-type',\n    '../../file-error',\n    '../../error-codes',\n    '../../utils',\n    './dropbox-file'\n], function (setImmediate,Buffer,paths,files, registry,BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\n    'use strict';\n\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  paths;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'not_found':\n                return FileError.ENOENT(p);\n            case 'not_file':\n                return FileError.EISDIR(p);\n            case 'not_folder':\n                return FileError.ENOTDIR(p);\n            case 'restricted_content':\n                return FileError.EPERM(p);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return FileError.EPERM(p);\n            case 'insufficient_space':\n                return new FileError(ErrorCodes.ENOSPC, msg);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxProvider extends BaseProvider {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxProvider instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxProvider(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxProvider.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(FileError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(FileError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(FileError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(FileError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(FileError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(FileError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxProvider.Name = \"DropboxV2\";\n    DropboxProvider.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxProvider.DropboxFile = DropboxFile;\n\n    registry.add(\"dropbox\",DropboxProvider);\n\n    return  files.providers.DropboxProvider= DropboxProvider;\n    \n});"]}