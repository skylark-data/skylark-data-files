{"version":3,"sources":["providers/dropbox/dropbox-provider.js"],"names":["define","setImmediate","Buffer","paths","BaseProvider","Stats","FileType","FileError","ErrorCodes","utils","DropboxFile","arrayBuffer2Buffer","buffer2ArrayBuffer","dirname","FixPath","p","ExtractTheFuckingError","e","obj","error","obj2","reason","JSON","parse","GetErrorMessage","err","user_message","text","error_summary","Error","stringify","LookupErrorToError","msg","EBADF","ENOENT","EISDIR","ENOTDIR","EPERM","EIO","WriteErrorToError","ENOSPC","FilesDeleteWrapped","client","cb","arg","path","filesDeleteV2","then","catch","path_lookup","path_write","setTimeout","Math","random","PreloadFile","[object Object]","_fs","_path","_flag","_stat","contents","super","this","_syncFile","getPath","getBuffer","sync","DropboxProvider","_client","opts","Dropbox","Name","mainCb","readdir","next","length","shift","oldPath","newPath","stat","stats","rename","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","to","isDirectory","unlink","isLstat","DIRECTORY","filesGetMetadata","ref","fileMetadata","FILE","size","flags","downloadArg","filesDownload","res","b","fileBlob","fr","FileReader","onload","ab","result","byteLength","readAsArrayBuffer","mode","fileData","alloc","commitInfo","Blob","type","filesUpload","metadata","createFile","ENOTEMPTY","parent","filesCreateFolderV2","mkdir","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","map","path_display","filter","concat","has_more","cursor","filesListFolderContinue","ProcessListFolderError","d",".tag","Options","description"],"mappings":"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","file":"../../../providers/dropbox/dropbox-provider.js","sourcesContent":["define([\n    \"skylark-langx-funcs/defer\",\n    \"skylark-langx-binary/buffer\",\n    \"skylark-langx-paths\",\n    \"../base-provider\",\n    '../../stats',\n    '../../file-type',\n    '../../file-error',\n    '../../error-codes',\n    '../../utils',\n    '../../dropbox-file'\n], function (setImmediate,Buffer,paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\n    'use strict';\n\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  paths;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'not_found':\n                return FileError.ENOENT(p);\n            case 'not_file':\n                return FileError.EISDIR(p);\n            case 'not_folder':\n                return FileError.ENOTDIR(p);\n            case 'restricted_content':\n                return FileError.EPERM(p);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return FileError.EPERM(p);\n            case 'insufficient_space':\n                return new FileError(ErrorCodes.ENOSPC, msg);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n    class DropboxFile extends PreloadFile {\n        constructor(_fs, _path, _flag, _stat, contents) {\n            super(_fs, _path, _flag, _stat, contents);\n        }\n        sync(cb) {\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\n        }\n        close(cb) {\n            this.sync(cb);\n        }\n    }\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxProvider extends BaseProvider {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxProvider instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxProvider(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxProvider.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(FileError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(FileError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(FileError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(FileError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(FileError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(FileError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxProvider.Name = \"DropboxV2\";\n    DropboxProvider.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxProvider.DropboxFile = DropboxFile;\n\n    return  DropboxProvider;\n    \n});"]}