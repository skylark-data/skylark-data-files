{"version":3,"sources":["providers/html5/html5-lfs-provider.js"],"names":["define","async","paths","files","registry","PreloadFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","utils","Html5LfsFile","asyncEach","each","buffer2ArrayBuffer","arrayBuffer2Buffer","_getFS","window","webkitRequestProvider","requestProvider","convertError","err","p","expectedDir","name","EEXIST","ENOSPC","ENOENT","EACCES","EPERM","ENOTDIR","EISDIR","EINVAL","Html5LfsProvider","[object Object]","size","type","PERSISTENT","super","this","opts","cb","fs","_allocate","e","Name","mainCb","_readdir","entries","entry","succ","error","fullPath","isDirectory","removeRecursively","remove","er","oldPath","newPath","semaphore","successCount","root","currentPath","success","file","dirname","getDirectory","parentDir","basename","moveTo","unlink","rename","getFile","path","isLstat","create","loadAsDir","dir","stat","DIRECTORY","failedToLoad","FILE","flags","mode","isExclusive","pathNotExistsAction","CREATE_FILE","exclusive","reader","FileReader","onloadend","event","bfsFile","_makeFile","result","onerror","ev","readAsArrayBuffer","_remove","readdir","length","ENOTEMPTY","rv","push","flag","data","ArrayBuffer","stats","buffer","list","dirEntry","createReader","readEntries","results","concat","Array","prototype","slice","call","errorCallback","navigator","webkitPersistentStorage","requestQuota","TEMPORARY","webkitTemporaryStorage","TypeError","webkitStorageInfo","_requestQuota","granted","isFile","Options","optional","description","add"],"mappings":";;;;;;;AAAAA,QACI,sBACA,sBACA,cACA,cACA,qBACA,mBACA,oBACA,mBACA,oBACA,cACA,kBACA,cACA,oBACD,SAAUC,EAAMC,EAAOC,EAAMC,EAAUC,EAAaC,EAAcC,EAAYC,EAAUC,EAAYC,EAAMC,EAAUC,EAAMC,GACzH,aAEA,MAAMC,EAAYb,EAAMc,MAElBC,mBAAEA,EAAkBC,mBAAEA,GAAuBL,EAanD,MAAMM,EAASC,OAAOC,uBAAyBD,OAAOE,iBAAmB,KAuCzE,SAASC,EAAaC,EAAKC,EAAGC,GAC1B,OAAQF,EAAIG,MAGR,IAAK,kBACD,OAAOlB,EAAUmB,OAAOH,GAE5B,IAAK,qBACD,OAAOhB,EAAUA,UAAUD,EAAWqB,OAAQJ,GAElD,IAAK,gBACD,OAAOhB,EAAUqB,OAAOL,GAI5B,IAAK,gBACD,OAAOhB,EAAUA,UAAUD,EAAWuB,OAAQN,GAIlD,IAAK,2BACD,OAAOhB,EAAUA,UAAUD,EAAWwB,MAAOP,GAGjD,IAAK,oBACD,OAAOhB,EAAUA,UAAUiB,EAAclB,EAAWyB,QAAUzB,EAAW0B,OAAQT,GAErF,IAAK,gBAGL,IAAK,oBAGL,IAAK,6BACL,QACI,OAAOhB,EAAUA,UAAUD,EAAW2B,OAAQV,UAUpDW,UAAyB7B,EAM3B8B,YAAYC,EAAO,EAAGC,EAAOnB,OAAOoB,YAChCC,QAEAC,KAAKJ,KAAO,QAAcA,EAC1BI,KAAKH,KAAOA,EAMhBF,cAAcM,EAAMC,GAChB,MAAMC,EAAK,IAAIT,EAAiBO,EAAKL,KAAMK,EAAKJ,MAChDM,EAAGC,UAAWC,GAAMA,EAAIH,EAAGG,GAAKH,EAAG,KAAMC,IAG7CR,qBACI,QAASlB,EAGbkB,UACI,OAAOD,EAAiBY,KAG5BX,aACI,OAAO,EAGXA,mBACI,OAAO,EAGXA,gBACI,OAAO,EAGXA,gBACI,OAAO,EAQXA,MAAMY,GAEFP,KAAKQ,SAAS,IAAK,CAAC1B,EAAK2B,KACrB,GAAI3B,EACAyB,EAAOzB,OAEN,CA2BDT,EAAUoC,EAhBU,CAACC,EAAOR,KACxB,MAAMS,EAAO,KACTT,KAEEU,EAAS9B,IACXoB,EAAGrB,EAAaC,EAAK4B,EAAMG,UAAWH,EAAMI,eAE3BJ,EApKxBI,YAqKOJ,EAAMK,kBAAkBJ,EAAMC,GAG9BF,EAAMM,OAAOL,EAAMC,IApBTK,IACVnC,EACAyB,EAAOzB,GAGPyB,SAyBpBZ,OAAOuB,EAASC,EAASjB,GACrB,IAAIkB,EAAY,EACZC,EAAe,EACnB,MAAMC,EAAOtB,KAAKG,GAAGmB,KACrB,IAAIC,EAAcL,EAClB,MAAMN,EAAS9B,MACLsC,GAAa,GACflB,EAAGrB,EAAaC,EAAKyC,GAAa,KAGpCC,EAAWC,GACU,KAAjBJ,EACKnB,EAAG,IAAInC,EAAUD,EAAW2B,OAAQ,uFAI3CyB,IAAYC,EACLjB,KAGXqB,EAAc9D,EAAMiE,QAAQP,QAC5BG,EAAKK,aAAaJ,KAAkBK,IAChCL,EAAc9D,EAAMoE,SAASV,GAC7BM,EAAKK,OAAOF,EAAWL,EAAcb,IAAYR,KAAUpB,IAGnD2C,EAAKX,aACLS,EAAcJ,EAEdnB,KAAK+B,OAAOZ,EAAUd,IACdA,EAEAO,EAAM9B,GAINkB,KAAKgC,OAAOd,EAASC,EAASjB,MAKtCU,EAAM9B,MAGf8B,IAIPU,EAAKW,QAAQf,KAAaM,EAASZ,GACnCU,EAAKK,aAAaT,KAAaM,EAASZ,GAG5CjB,KAAKuC,EAAMC,EAASjC,GAGhB,MAAMD,GACFmC,QAAQ,GAWNC,EAAaC,IAGf,MACMC,EAAO,IAAItE,EAAMC,EAASsE,UADnB,MAEbtC,EAAG,KAAMqC,IAGPE,EAAgB3D,IAClBoB,EAAGrB,EAAaC,EAAKoD,GAAM,KAU/BlC,KAAKG,GAAGmB,KAAKW,QAAQC,EAAMjC,EA3BPS,IAKhBA,EAAMe,KAJiBA,IACnB,MAAMc,EAAO,IAAItE,EAAMC,EAASwE,KAAMjB,EAAK7B,MAC3CM,EAAG,KAAMqC,IAEaE,IAgBH,KACvBzC,KAAKG,GAAGmB,KAAKK,aAAaO,EAAMjC,EAAMoC,EAAWI,KAOzD9C,KAAKZ,EAAG4D,EAAOC,EAAM1C,GAEjB,MAAMU,EAAS9B,IACM,6BAAbA,EAAIG,MAAuC0D,EAAME,cACjD3C,EAAGnC,EAAUmB,OAAOH,IAGpBmB,EAAGrB,EAAaC,EAAKC,GAAG,KAGhCiB,KAAKG,GAAGmB,KAAKW,QAAQlD,GACjBqD,OAAQO,EAAMG,wBAA0B9E,EAAW+E,YACnDC,UAAWL,EAAME,eACjBnC,IAEAA,EAAMe,KAAMA,IACR,MAAMwB,EAAS,IAAIC,WACnBD,EAAOE,UAAY,CAACC,IAChB,MAAMC,EAAUrD,KAAKsD,UAAUvE,EAAG2B,EAAOiC,EAAOlB,EAAMwB,EAAOM,QAC7DrD,EAAG,KAAMmD,KAEbJ,EAAOO,QAAU,CAACC,IACd7C,EAAMqC,EAAOrC,SAEjBqC,EAAOS,kBAAkBjC,IAC1Bb,IACJA,GAEPjB,OAAOuC,EAAMhC,GACTF,KAAK2D,QAAQzB,EAAMhC,GAAI,GAE3BP,MAAMuC,EAAMhC,GAERF,KAAK4D,QAAQ1B,EAAM,CAAC7B,EAAG3C,KACf2C,EACAH,EAAGG,GAEE3C,EAAMmG,OAAS,EACpB3D,EAAGnC,EAAU+F,UAAU5B,IAGvBlC,KAAK2D,QAAQzB,EAAMhC,GAAI,KAInCP,MAAMuC,EAAMU,EAAM1C,GAadF,KAAKG,GAAGmB,KAAKK,aAAaO,GATtBE,QAAQ,EACRY,WAAW,GAEEV,IACbpC,KAEWpB,IACXoB,EAAGrB,EAAaC,EAAKoD,GAAM,MAOnCvC,QAAQuC,EAAMhC,GACVF,KAAKQ,SAAS0B,EAAM,CAAC7B,EAAGI,KACpB,IAAIA,EAQA,OAAOP,EAAGG,GARD,CACT,MAAM0D,KACN,IAAK,MAAMrD,KAASD,EAChBsD,EAAGC,KAAKtD,EAAMzB,MAElBiB,EAAG,KAAM6D,MAUrBpE,UAAUuC,EAAMxB,EAAOuD,EAAM1B,EAAM2B,EAAO,IAAIC,YAAY,IACtD,MAAMC,EAAQ,IAAInG,EAAMC,EAASwE,KAAMH,EAAK3C,MACtCyE,EAAS7F,EAAmB0F,GAClC,OAAO,IAAI9F,EAAa4B,KAAMU,EAAOwB,EAAM+B,EAAMG,EAAOC,GAK5D1E,SAASuC,EAAMhC,GACX,MAAMU,EAAS9B,IACXoB,EAAGrB,EAAaC,EAAKoD,GAAM,KA/TvC,IAAkBoC,EAkUVtE,KAAKG,GAAGmB,KAAKK,aAAaO,GAAQE,QAAQ,GAAUmC,IAChD,MAAMtB,EAASsB,EAASC,eACxB,IAAI/D,KAEJ,MAAMgE,EAAc,KAChBxB,EAAOwB,YAAcC,IACbA,EAAQb,QACRpD,EAAUA,EAAQkE,QAzUxBL,EAyUwCI,EAxU/CE,MAAMC,UAAUC,MAAMC,KAAKT,MAAY,KAyU1BG,KAGAvE,EAAG,KAAMO,IAEbG,IAER6D,KACD7D,GAMPjB,UAAUO,GACN,MAAMsB,EAAWrB,IACbH,KAAKG,GAAKA,EACVD,KAEEU,EAAS9B,IACXoB,EAAGrB,EAAaC,EAAK,KAAK,KAE1BkB,KAAKH,OAASnB,OAAOoB,WA1XjC,SAAuBD,EAAMD,EAAM4B,EAASwD,GAMxC,QAAoD,IAAzCC,UAAmC,wBAC1C,OAAQpF,GACJ,KAAKnB,OAAOoB,WACRmF,UAAUC,wBAAwBC,aAAavF,EAAM4B,EAASwD,GAC9D,MACJ,KAAKtG,OAAO0G,UACRH,UAAUI,uBAAuBF,aAAavF,EAAM4B,EAASwD,GAC7D,MACJ,QACIA,EAAc,IAAIM,mCAAmCzF,WAK7DnB,OAAO6G,kBAAkBJ,aAAatF,EAAMD,EAAM4B,EAASwD,GAuWvDQ,CAAcxF,KAAKH,KAAMG,KAAKJ,KAAO6F,IACjChH,EAAOuB,KAAKH,KAAM4F,EAASjE,EAASZ,IACrCA,GAGHnC,EAAOuB,KAAKH,KAAMG,KAAKJ,KAAM4B,EAASZ,GAS9CjB,QAAQuC,EAAMhC,EAAIwF,GACd,MAAMlE,EAAWd,IAObA,EAAMM,OANO,KACTd,KAESpB,IACToB,EAAGrB,EAAaC,EAAKoD,GAAOwD,OAI9B9E,EAAS9B,IACXoB,EAAGrB,EAAaC,EAAKoD,GAAOwD,KAG1BzF,GACFmC,QAAQ,GAERsD,EACA1F,KAAKG,GAAGmB,KAAKW,QAAQC,EAAMjC,EAAMuB,EAASZ,GAG1CZ,KAAKG,GAAGmB,KAAKK,aAAaO,EAAMjC,EAAMuB,EAASZ,IAuB3D,OAnBAlB,EAAiBY,KAAO,mBACxBZ,EAAiBiG,SACb/F,MACIC,KAAM,SACN+F,UAAU,EACVC,YAAa,uFAEjBhG,MACIA,KAAM,SACN+F,UAAU,EACVC,YAAa,mEAIrBnG,EAAiBtB,aAAeA,EAEhCT,EAASmI,IAAI,WAAWpG,GAGjBA","file":"../../../providers/html5/html5-lfs-provider.js","sourcesContent":["define([\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    \"../../files\",\n    \"../registry\",\n    '../../preload-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    \"./html5-lfs-file\"\n], function (async,paths, files,registry, PreloadFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType, utils,Html5LfsFile) {\n    'use strict';\n\n    const asyncEach = async.each;\n\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\n\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n\n    /**\n     * @hidden\n     */\n    const _getFS = window.webkitRequestProvider || window.requestProvider || null;\n\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for Provider.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case window.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case window.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            window.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate FileError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return FileError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return FileError.FileError(ErrorCodes.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return FileError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return FileError.FileError(ErrorCodes.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return FileError.FileError(ErrorCodes.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return FileError.FileError(expectedDir ? ErrorCodes.ENOTDIR : ErrorCodes.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return FileError.FileError(ErrorCodes.EINVAL, p);\n        }\n    }\n\n    /**\n     * A read-write filesystem backed by the HTML5 Provider API.\n     *\n     * As the HTML5 Provider is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class Html5LfsProvider extends BaseProvider {\n\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = window.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n\n        /**\n         * Creates an Html5LfsProvider instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new Html5LfsProvider(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n\n        static isAvailable() {\n            return !!_getFS;\n        }\n\n        getName() {\n            return Html5LfsProvider.Name;\n        }\n\n        isReadOnly() {\n            return false;\n        }\n\n        supportsSymlinks() {\n            return false;\n        }\n\n        supportsProps() {\n            return false;\n        }\n\n        supportsSynch() {\n            return false;\n        }\n\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new FileError(ErrorCodes.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = paths.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = paths.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(FileError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(FileError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new Html5LfsFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        \n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === window.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    Html5LfsProvider.Name = \"Html5LfsProvider\";\n    Html5LfsProvider.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    Html5LfsProvider.Html5LfsFile = Html5LfsFile;\n\n    registry.add(\"html5Lfs\",Html5LfsProvider);\n\n\n    return Html5LfsProvider;\n});"]}