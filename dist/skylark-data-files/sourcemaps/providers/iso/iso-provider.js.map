{"version":3,"sources":["providers/iso/iso-provider.js"],"names":["define","paths","SynchronousProvider","NoSyncFile","Stats","FileType","ActionType","FileError","ErrorCodes","utils","copyingSlice","bufferValidator","IsoProvider","[object Object]","data","name","super","this","_data","vdTerminatorFound","i","candidateVDs","Array","slice","VolumeDescriptor","type","push","PrimaryVolumeDescriptor","SupplementaryVolumeDescriptor","length","EIO","forEach","v","_pvd","_root","rootDirectoryEntry","_name","opts","cb","e","hasRockRidge","path","p","isLstat","record","_getDirectoryRecord","ENOENT","_getStats","flags","mode","isWriteable","EPERM","isSymlink","openSync","resolve","getSymlinkPath","isDirectory","EISDIR","getFile","stats","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","EINVAL","getDirectory","getFileList","ENOTDIR","fname","encoding","flag","fd","fdBuff","getBuffer","toString","closeSync","components","split","dir","component","getRecord","newP","dirRec","len","dataLength","date","recordingDate","getTime","atime","mtime","ctime","entries","getSUEntries","entry","PXEntry","TFEntry","access","modify","creation","DIRECTORY","FILE","Name","Options","description","validator"],"mappings":"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","file":"../../../providers/iso/iso-provider.js","sourcesContent":["define([\n    \"skylark-langx-paths\",\n    '../synchronous-provider',\n    \"../../no-sync-file\",\n    '../../stats',\n    '../../file-type',\n    '../../action-type',\n    '../../file-error',\n    '../../error-codes',\n    '../../utils'\n], function (paths,SynchronousProvider,NoSyncFile, Stats,FileType, ActionType,FileError, ErrorCodes, utils) {\n\n    'use strict';\n\n    const { copyingSlice, bufferValidator }  = utils;\n\n\n\n    /**\n     * Mounts an ISO file as a read-only file system.\n     *\n     * Supports:\n     * * Vanilla ISO9660 ISOs\n     * * Microsoft Joliet and Rock Ridge extensions to the ISO9660 standard\n     */\n    class IsoProvider extends SynchronousProvider {\n        /**\n         * **Deprecated. Please use IsoProvider.Create() method instead.**\n         *\n         * Constructs a read-only file system from the given ISO.\n         * @param data The ISO file in a buffer.\n         * @param name The name of the ISO (optional; used for debug messages / identification via getName()).\n         */\n        constructor(data, name = \"\") {\n            super();\n            this._data = data;\n            // Skip first 16 sectors.\n            let vdTerminatorFound = false;\n            let i = 16 * 2048;\n            const candidateVDs = new Array();\n            while (!vdTerminatorFound) {\n                const slice = data.slice(i);\n                const vd = new VolumeDescriptor(slice);\n                switch (vd.type()) {\n                    case 1 /* PrimaryVolumeDescriptor */:\n                        candidateVDs.push(new PrimaryVolumeDescriptor(slice));\n                        break;\n                    case 2 /* SupplementaryVolumeDescriptor */:\n                        candidateVDs.push(new SupplementaryVolumeDescriptor(slice));\n                        break;\n                    case 255 /* VolumeDescriptorSetTerminator */:\n                        vdTerminatorFound = true;\n                        break;\n                }\n                i += 2048;\n            }\n            if (candidateVDs.length === 0) {\n                throw new FileError(ErrorCodes.EIO, `Unable to find a suitable volume descriptor.`);\n            }\n            candidateVDs.forEach((v) => {\n                // Take an SVD over a PVD.\n                if (!this._pvd || this._pvd.type() !== 2 /* SupplementaryVolumeDescriptor */) {\n                    this._pvd = v;\n                }\n            });\n            this._root = this._pvd.rootDirectoryEntry(data);\n            this._name = name;\n        }\n        /**\n         * Creates an IsoProvider instance with the given options.\n         */\n        static Create(opts, cb) {\n            try {\n                cb(null, new IsoProvider(opts.data, opts.name));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        static isAvailable() {\n            return true;\n        }\n        getName() {\n            let name = `IsoProvider${this._name}${this._pvd ? `-${this._pvd.name()}` : ''}`;\n            if (this._root && this._root.hasRockRidge()) {\n                name += `-RockRidge`;\n            }\n            return name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system.\n            cb(this._data.length, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return true;\n        }\n        statSync(p, isLstat) {\n            const record = this._getDirectoryRecord(p);\n            if (record === null) {\n                throw FileError.ENOENT(p);\n            }\n            return this._getStats(p, record);\n        }\n        openSync(p, flags, mode) {\n            // INVARIANT: Cannot write to RO file systems.\n            if (flags.isWriteable()) {\n                throw new FileError(ErrorCodes.EPERM, p);\n            }\n            // Check if the path exists, and is a file.\n            const record = this._getDirectoryRecord(p);\n            if (!record) {\n                throw FileError.ENOENT(p);\n            }\n            else if (record.isSymlink(this._data)) {\n                return this.openSync(paths.resolve(p, record.getSymlinkPath(this._data)), flags, mode);\n            }\n            else if (!record.isDirectory(this._data)) {\n                const data = record.getFile(this._data);\n                const stats = this._getStats(p, record);\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw FileError.EEXIST(p);\n                    case ActionType.NOP:\n                        return new NoSyncFile(this, p, flags, stats, data);\n                    default:\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw FileError.EISDIR(p);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const record = this._getDirectoryRecord(path);\n            if (!record) {\n                throw FileError.ENOENT(path);\n            }\n            else if (record.isDirectory(this._data)) {\n                return record.getDirectory(this._data).getFileList().slice(0);\n            }\n            else {\n                throw FileError.ENOTDIR(path);\n            }\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getDirectoryRecord(path) {\n            // Special case.\n            if (path === '/') {\n                return this._root;\n            }\n            const components = path.split('/').slice(1);\n            let dir = this._root;\n            for (const component of components) {\n                if (dir.isDirectory(this._data)) {\n                    dir = dir.getDirectory(this._data).getRecord(component);\n                    if (!dir) {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n            return dir;\n        }\n        _getStats(p, record) {\n            if (record.isSymlink(this._data)) {\n                const newP = paths.resolve(p, record.getSymlinkPath(this._data));\n                const dirRec = this._getDirectoryRecord(newP);\n                if (!dirRec) {\n                    return null;\n                }\n                return this._getStats(newP, dirRec);\n            }\n            else {\n                const len = record.dataLength();\n                let mode = 0x16D;\n                const date = record.recordingDate().getTime();\n                let atime = date;\n                let mtime = date;\n                let ctime = date;\n                if (record.hasRockRidge()) {\n                    const entries = record.getSUEntries(this._data);\n                    for (const entry of entries) {\n                        if (entry instanceof PXEntry) {\n                            mode = entry.mode();\n                        }\n                        else if (entry instanceof TFEntry) {\n                            const flags = entry.flags();\n                            if (flags & 4 /* ACCESS */) {\n                                atime = entry.access().getTime();\n                            }\n                            if (flags & 2 /* MODIFY */) {\n                                mtime = entry.modify().getTime();\n                            }\n                            if (flags & 1 /* CREATION */) {\n                                ctime = entry.creation().getTime();\n                            }\n                        }\n                    }\n                }\n                // Mask out writeable flags. This is a RO file system.\n                mode = mode & 0x16D;\n                return new Stats(record.isDirectory(this._data) ? FileType.DIRECTORY : FileType.FILE, len, mode, atime, mtime, ctime);\n            }\n        }\n    }\n    IsoProvider.Name = \"Iso\";\n    IsoProvider.Options = {\n        data: {\n            type: \"object\",\n            description: \"The ISO file in a buffer\",\n            validator: bufferValidator\n        }\n    };\n\n\n    return IsoProvider;\n});"]}