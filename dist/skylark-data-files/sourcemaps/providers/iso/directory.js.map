{"version":3,"sources":["providers/iso/directory.js"],"names":["define","[object Object]","record","isoData","this","_fileList","_fileMap","_record","i","lba","iLimit","dataLength","fileFlags","getSUEntries","filter","e","CLEntry","childDirectoryLba","Infinity","r","_constructDirectoryRecord","slice","fname","fileName","hasRockRidge","REEntry","length","push","name"],"mappings":";;;;;;;AAAAA,UACG,WACC,aA2DA,aArDIC,YAAYC,EAAQC,GAChBC,KAAKC,aACLD,KAAKE,YACLF,KAAKG,QAAUL,EACf,IAAIM,EAAIN,EAAOO,MACXC,EAASF,EAAIN,EAAOS,aAOxB,IAN2B,EAArBT,EAAOU,cAGTJ,EAA6B,KADlBN,EAAOW,aAAaV,GAASW,OAAQC,GAAMA,aAAaC,SAAS,GACrEC,oBACPP,EAASQ,EAAAA,GAENV,EAAIE,GAAQ,CAKf,GAAY,IAJAP,EAAQK,GAIL,CACXA,IACA,SAEJ,MAAMW,EAAIf,KAAKgB,0BAA0BjB,EAAQkB,MAAMb,IACjDc,EAAQH,EAAEI,SAASpB,GAEX,OAAVmB,GAAgC,MAAVA,EAEjBH,EAAEK,gBAAyF,IAAvEL,EAAEN,aAAaV,GAASW,OAAQC,GAAMA,aAAaU,SAASC,SACjFtB,KAAKE,SAASgB,GAASH,EACvBf,KAAKC,UAAUsB,KAAKL,IAGnBZ,IAAWQ,EAAAA,IAEhBR,EAASF,EAAIW,EAAER,cAEnBH,GAAKW,EAAEO,UAOfzB,UAAU2B,GACN,OAAOxB,KAAKE,SAASsB,GAEzB3B,cACI,OAAOG,KAAKC,UAEhBJ,YAAYE,GACR,OAAOC,KAAKgB,0BAA0BjB,EAAQkB,MAAMjB,KAAKG,QAAQE","file":"../../../providers/iso/directory.js","sourcesContent":["define([\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class Directory {\r\n        constructor(record, isoData) {\r\n            this._fileList = [];\r\n            this._fileMap = {};\r\n            this._record = record;\r\n            let i = record.lba();\r\n            let iLimit = i + record.dataLength();\r\n            if (!(record.fileFlags() & 2 /* Directory */)) {\r\n                // Must have a CL entry.\r\n                const cl = record.getSUEntries(isoData).filter((e) => e instanceof CLEntry)[0];\r\n                i = cl.childDirectoryLba() * 2048;\r\n                iLimit = Infinity;\r\n            }\r\n            while (i < iLimit) {\r\n                const len = isoData[i];\r\n                // Zero-padding between sectors.\r\n                // TODO: Could optimize this to seek to nearest-sector upon\r\n                // seeing a 0.\r\n                if (len === 0) {\r\n                    i++;\r\n                    continue;\r\n                }\r\n                const r = this._constructDirectoryRecord(isoData.slice(i));\r\n                const fname = r.fileName(isoData);\r\n                // Skip '.' and '..' entries.\r\n                if (fname !== '\\u0000' && fname !== '\\u0001') {\r\n                    // Skip relocated entries.\r\n                    if (!r.hasRockRidge() || r.getSUEntries(isoData).filter((e) => e instanceof REEntry).length === 0) {\r\n                        this._fileMap[fname] = r;\r\n                        this._fileList.push(fname);\r\n                    }\r\n                }\r\n                else if (iLimit === Infinity) {\r\n                    // First entry contains needed data.\r\n                    iLimit = i + r.dataLength();\r\n                }\r\n                i += r.length();\r\n            }\r\n        }\r\n        /**\r\n         * Get the record with the given name.\r\n         * Returns undefined if not present.\r\n         */\r\n        getRecord(name) {\r\n            return this._fileMap[name];\r\n        }\r\n        getFileList() {\r\n            return this._fileList;\r\n        }\r\n        getDotEntry(isoData) {\r\n            return this._constructDirectoryRecord(isoData.slice(this._record.lba()));\r\n        }\r\n    }\r\n\r\n    return Directory;\r\n});"]}