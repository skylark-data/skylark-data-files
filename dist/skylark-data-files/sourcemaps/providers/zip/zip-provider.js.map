{"version":3,"sources":["providers/zip/zip-provider.js"],"names":["define","setImmediate","async","paths","inflateRaw","DirInode","FileInode","FIleIndex","NoSyncFile","BaseProvider","ErrorCodes","FileError","ActionType","Stats","FileType","global","util","ExtendedASCII","CentralDirectory","CompressionMethod","EndOfCentralDirectory","ZipTOC","arrayish2Buffer","copyingSlice","bufferValidator","ZipProvider","SynchronousProvider","[object Object]","input","name","super","this","_index","FileIndex","_directoryEntries","_eocd","index","directoryEntries","eocd","data","opts","cb","_computeIndex","zipData","e","zipTOC","fs","endOffset","Math","min","startOffset","length","i","readUInt32LE","slice","EINVAL","cd","filename","fileName","charAt","EPERM","substr","isDirectory","addPathFast","_getEOCD","diskNumber","cdDiskNumber","cdPtr","cdOffset","cdEnd","cdSize","_computeIndexResponsive","cdEntries","count","_addToIndex","totalSize","push","_computeIndexResponsiveTrampoline","Name","path","inode","getInode","ENOENT","isFileInode","getData","isDirInode","dirEntry","RangeError","isLstat","stats","getStats","flags","mode","isWriteable","EISDIR","cdRecord","pathExistsAction","THROW_EXCEPTION","TRUNCATE_FILE","EEXIST","NOP","getListing","ENOTDIR","fname","encoding","flag","fd","openSync","fdBuff","getBuffer","toString","closeSync","Options","type","description","validator","optional","RegisterDecompressionMethod","DEFLATE","compressedSize","uncompressedSize","chunkSize","STORED","registry","add"],"mappings":"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","file":"../../../providers/zip/zip-provider.js","sourcesContent":["define([\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-async\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-compression/inflate-raw\",\r\n    \"../../inodes/dir-inode\",\r\n    \"../../inodes/file-inode\",    \r\n    \"../../inodes/file-index\",    \r\n    '../../no-sync-file',\r\n    \"../synchronous-provider\",\r\n    '../../error-codes',\r\n    '../../file-error',\r\n    '../../action-type',\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../core/global',\r\n    '../core/util',\r\n    \"./extended_ascii\",\r\n    \"./central-directory\",\r\n    \"./compression-method\",\r\n    \"./end-of-central-directory\",\r\n    \"./zip-toc\"\r\n], function (\r\n    setImmediate,\r\n    async,\r\n    paths,\r\n    inflateRaw,\r\n    DirInode,\r\n    FileInode,\r\n    FIleIndex,\r\n    NoSyncFile, \r\n    BaseProvider, \r\n    ErrorCodes, \r\n    FileError,\r\n    ActionType, \r\n    Stats,\r\n    FileType, \r\n    global, \r\n    util,\r\n    ExtendedASCII,\r\n    CentralDirectory,\r\n    CompressionMethod,\r\n    EndOfCentralDirectory,\r\n    ZipTOC\r\n) {\r\n\r\n    const { arrayish2Buffer, copyingSlice, bufferValidator }  = util;\r\n\r\n\r\n    /*\r\n       4.3.6 Overall .ZIP file format:\r\n\r\n          [local file header 1]\r\n          [encryption header 1]\r\n          [file data 1]\r\n          [data descriptor 1]\r\n          .\r\n          .\r\n          .\r\n          [local file header n]\r\n          [encryption header n]\r\n          [file data n]\r\n          [data descriptor n]\r\n          [archive decryption header]\r\n          [archive extra data record]\r\n          [central directory header 1]\r\n          .\r\n          .\r\n          .\r\n          [central directory header n]\r\n          [zip64 end of central directory record]\r\n          [zip64 end of central directory locator]\r\n          [end of central directory record]\r\n    */\r\n\r\n\r\n\r\n    /**\r\n     * Zip file-backed filesystem\r\n     * Implemented according to the standard:\r\n     * http://www.pkware.com/documents/casestudies/APPNOTE.TXT\r\n     *\r\n     * While there are a few zip libraries for JavaScript (e.g. JSZip and zip.js),\r\n     * they are not a good match for BrowserFS. In particular, these libraries\r\n     * perform a lot of unneeded data copying, and eagerly decompress every file\r\n     * in the zip file upon loading to check the CRC32. They also eagerly decode\r\n     * strings. Furthermore, these libraries duplicate functionality already present\r\n     * in BrowserFS (e.g. UTF-8 decoding and binary data manipulation).\r\n     *\r\n     * This filesystem takes advantage of BrowserFS's Buffer implementation, which\r\n     * efficiently represents the zip file in memory (in both ArrayBuffer-enabled\r\n     * browsers *and* non-ArrayBuffer browsers), and which can neatly be 'sliced'\r\n     * without copying data. Each struct defined in the standard is represented with\r\n     * a buffer slice pointing to an offset in the zip file, and has getters for\r\n     * each field. As we anticipate that this data will not be read often, we choose\r\n     * not to store each struct field in the JavaScript object; instead, to reduce\r\n     * memory consumption, we retrieve it directly from the binary data each time it\r\n     * is requested.\r\n     *\r\n     * When the filesystem is instantiated, we determine the directory structure\r\n     * of the zip file as quickly as possible. We lazily decompress and check the\r\n     * CRC32 of files. We do not cache decompressed files; if this is a desired\r\n     * feature, it is best implemented as a generic file system wrapper that can\r\n     * cache data from arbitrary file systems.\r\n     *\r\n     * For inflation, we use `pako`'s implementation:\r\n     * https://github.com/nodeca/pako\r\n     *\r\n     * Current limitations:\r\n     * * No encryption.\r\n     * * No ZIP64 support.\r\n     * * Read-only.\r\n     *   Write support would require that we:\r\n     *   - Keep track of changed/new files.\r\n     *   - Compress changed files, and generate appropriate metadata for each.\r\n     *   - Update file offsets for other files in the zip file.\r\n     *   - Stream it out to a location.\r\n     *   This isn't that bad, so we might do this at a later date.\r\n     */\r\n    class ZipProvider extends SynchronousProvider {\r\n        constructor(input, name = '') {\r\n            super();\r\n            this.name = name;\r\n            this._index = new FileIndex();\r\n            this._directoryEntries = [];\r\n            this._eocd = null;\r\n            this._index = input.index;\r\n            this._directoryEntries = input.directoryEntries;\r\n            this._eocd = input.eocd;\r\n            this.data = input.data;\r\n        }\r\n        /**\r\n         * Constructs a ZipProvider instance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                ZipProvider._computeIndex(opts.zipData, (e, zipTOC) => {\r\n                    if (zipTOC) {\r\n                        const fs = new ZipProvider(zipTOC, opts.name);\r\n                        cb(null, fs);\r\n                    }\r\n                    else {\r\n                        cb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() { return true; }\r\n\r\n        /**\r\n         * Locates the end of central directory record at the end of the file.\r\n         * Throws an exception if it cannot be found.\r\n         */\r\n        static _getEOCD(data) {\r\n            // Unfortunately, the comment is variable size and up to 64K in size.\r\n            // We assume that the magic signature does not appear in the comment, and\r\n            // in the bytes between the comment and the signature. Other ZIP\r\n            // implementations make this same assumption, since the alternative is to\r\n            // read thread every entry in the file to get to it. :(\r\n            // These are *negative* offsets from the end of the file.\r\n            const startOffset = 22;\r\n            const endOffset = Math.min(startOffset + 0xFFFF, data.length - 1);\r\n            // There's not even a byte alignment guarantee on the comment so we need to\r\n            // search byte by byte. *grumble grumble*\r\n            for (let i = startOffset; i < endOffset; i++) {\r\n                // Magic number: EOCD Signature\r\n                if (data.readUInt32LE(data.length - i) === 0x06054b50) {\r\n                    return new EndOfCentralDirectory(data.slice(data.length - i));\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EINVAL, \"Invalid ZIP file: Could not locate End of Central Directory signature.\");\r\n        }\r\n        static _addToIndex(cd, index) {\r\n            // Paths must be absolute, yet zip file paths are always relative to the\r\n            // zip root. So we append '/' and call it a day.\r\n            let filename = cd.fileName();\r\n            if (filename.charAt(0) === '/') {\r\n                throw new FileError(ErrorCodes.EPERM, `Unexpectedly encountered an absolute path in a zip file. Please file a bug.`);\r\n            }\r\n            // XXX: For the file index, strip the trailing '/'.\r\n            if (filename.charAt(filename.length - 1) === '/') {\r\n                filename = filename.substr(0, filename.length - 1);\r\n            }\r\n            if (cd.isDirectory()) {\r\n                index.addPathFast('/' + filename, new DirInode(cd));\r\n            }\r\n            else {\r\n                index.addPathFast('/' + filename, new FileInode(cd));\r\n            }\r\n        }\r\n        static _computeIndex(data, cb) {\r\n            try {\r\n                const index = new FileIndex();\r\n                const eocd = ZipProvider._getEOCD(data);\r\n                if (eocd.diskNumber() !== eocd.cdDiskNumber()) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"ZipProvider does not support spanned zip files.\"));\r\n                }\r\n                const cdPtr = eocd.cdOffset();\r\n                if (cdPtr === 0xFFFFFFFF) {\r\n                    return cb(new FileError(ErrorCodes.EINVAL, \"ZipProvider does not support Zip64.\"));\r\n                }\r\n                const cdEnd = cdPtr + eocd.cdSize();\r\n                ZipProvider._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, [], eocd);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static _computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\r\n            try {\r\n                ZipProvider._computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static _computeIndexResponsive(data, index, cdPtr, cdEnd, cb, cdEntries, eocd) {\r\n            if (cdPtr < cdEnd) {\r\n                let count = 0;\r\n                while (count++ < 200 && cdPtr < cdEnd) {\r\n                    const cd = new CentralDirectory(data, data.slice(cdPtr));\r\n                    ZipProvider._addToIndex(cd, index);\r\n                    cdPtr += cd.totalSize();\r\n                    cdEntries.push(cd);\r\n                }\r\n                setImmediate(() => {\r\n                    ZipProvider._computeIndexResponsiveTrampoline(data, index, cdPtr, cdEnd, cb, cdEntries, eocd);\r\n                });\r\n            }\r\n            else {\r\n                cb(null, new ZipTOC(index, cdEntries, eocd, data));\r\n            }\r\n        }\r\n        getName() {\r\n            return ZipProvider.Name + (this.name !== '' ? ` ${this.name}` : '');\r\n        }\r\n        /**\r\n         * Get the CentralDirectory object for the given path.\r\n         */\r\n        getCentralDirectoryEntry(path) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            if (FileInode.isFileInode(inode)) {\r\n                return inode.getData();\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                return inode.getData();\r\n            }\r\n            else {\r\n                // Should never occur.\r\n                throw FileError.EPERM(`Invalid inode: ${inode}`);\r\n            }\r\n        }\r\n        getCentralDirectoryEntryAt(index) {\r\n            const dirEntry = this._directoryEntries[index];\r\n            if (!dirEntry) {\r\n                throw new RangeError(`Invalid directory index: ${index}.`);\r\n            }\r\n            return dirEntry;\r\n        }\r\n        getNumberOfCentralDirectoryEntries() {\r\n            return this._directoryEntries.length;\r\n        }\r\n        getEndOfCentralDirectory() {\r\n            return this._eocd;\r\n        }\r\n        diskSpace(path, cb) {\r\n            // Read-only file system.\r\n            cb(this.data.length, 0);\r\n        }\r\n        isReadOnly() {\r\n            return true;\r\n        }\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        supportsProps() {\r\n            return false;\r\n        }\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        statSync(path, isLstat) {\r\n            const inode = this._index.getInode(path);\r\n            if (inode === null) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            let stats;\r\n            if (FileInode.isFileInode(inode)) {\r\n                stats = inode.getData().getStats();\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                stats = inode.getStats();\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid inode.\");\r\n            }\r\n            return stats;\r\n        }\r\n        openSync(path, flags, mode) {\r\n            // INVARIANT: Cannot write to RO file systems.\r\n            if (flags.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, path);\r\n            }\r\n            // Check if the path exists, and is a file.\r\n            const inode = this._index.getInode(path);\r\n            if (!inode) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (FileInode.isFileInode(inode)) {\r\n                const cdRecord = inode.getData();\r\n                const stats = cdRecord.getStats();\r\n                switch (flags.pathExistsAction()) {\r\n                    case ActionType.THROW_EXCEPTION:\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        throw FileError.EEXIST(path);\r\n                    case ActionType.NOP:\r\n                        return new NoSyncFile(this, path, flags, stats, cdRecord.getData());\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\r\n                }\r\n            }\r\n            else {\r\n                throw FileError.EISDIR(path);\r\n            }\r\n        }\r\n        readdirSync(path) {\r\n            // Check if it exists.\r\n            const inode = this._index.getInode(path);\r\n            if (!inode) {\r\n                throw FileError.ENOENT(path);\r\n            }\r\n            else if (DirInode.isDirInode(inode)) {\r\n                return inode.getListing();\r\n            }\r\n            else {\r\n                throw FileError.ENOTDIR(path);\r\n            }\r\n        }\r\n        /**\r\n         * Specially-optimized readfile.\r\n         */\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const fdCast = fd;\r\n                const fdBuff = fdCast.getBuffer();\r\n                if (encoding === null) {\r\n                    return copyingSlice(fdBuff);\r\n                }\r\n                return fdBuff.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n    }\r\n    \r\n    ZipProvider.Name = \"ZipProvider\";\r\n    ZipProvider.Options = {\r\n        zipData: {\r\n            type: \"object\",\r\n            description: \"The zip file as a Buffer object.\",\r\n            validator: bufferValidator\r\n        },\r\n        name: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"The name of the zip file (optional).\"\r\n        }\r\n    };\r\n    ZipProvider.CompressionMethod = CompressionMethod;\r\n    ZipProvider.RegisterDecompressionMethod(CompressionMethod.DEFLATE, (data, compressedSize, uncompressedSize) => {\r\n        return arrayish2Buffer(inflateRaw(data.slice(0, compressedSize), { chunkSize: uncompressedSize }));\r\n    });\r\n    ZipProvider.RegisterDecompressionMethod(CompressionMethod.STORED, (data, compressedSize, uncompressedSize) => {\r\n        return copyingSlice(data, 0, uncompressedSize);\r\n    });\r\n\r\n\r\n    registry.add(\"zip\",ZipProvider);\r\n\r\n\r\n    return ZipProvider;\r\n\r\n});"]}