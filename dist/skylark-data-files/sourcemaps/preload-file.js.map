{"version":3,"sources":["preload-file.js"],"names":["define","Buffer","file","ErrorCodes","FileError","Stats","BaseFile","utils","emptyBuffer","files","PreloadFile","[object Object]","_fs","_path","_flag","_stat","contents","super","this","_pos","_dirty","_buffer","size","length","isReadable","Error","isAppendable","delta","newPos","cb","syncSync","e","ENOTSUP","closeSync","clone","len","truncateSync","isSynchronous","fs","getRootFS","supportsSynch","sync","isWriteable","EPERM","mtimeMs","Date","now","buf","alloc","writeSync","newBuff","copy","buffer","offset","position","undefined","getPos","endFp","setPos","readSync","rv","atimeMs","mode","chmodSync","supportsProps","chmod"],"mappings":"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","file":"../preload-file.js","sourcesContent":["define([\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,file,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});"]}