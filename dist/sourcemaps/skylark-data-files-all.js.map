{"version":3,"sources":["skylark-data-files-all.js"],"names":["define","obj1","path","obj2","split","length","ns","i","name","Error","_attach","root","attach","obj","skylark","main","providers","files","ActionType","ErrorCodes","fromBase64","str","a","b","c","d","encoding","arraybuffer","ArrayBuffer","view","Uint8Array","j","indexOf","charAt","fromBinaryString","charCodeAt","fromBuffer","buffer","array","exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","arr","Arr","_byteLength","curByte","len","revLookup","fromByteArray","uint8","extraBytes","parts","len2","push","encodeChunk","lookup","join","Array","code","start","end","num","output","read","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","s","NaN","Infinity","Math","pow","write","value","rt","abs","isNaN","floor","log","LN2","binary","base64","ieee754","Buffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","__proto__","prototype","arg","encodingOrOffset","allocUnsafe","from","TypeError","isArrayBuffer","byteOffset","undefined","fromArrayBuffer","string","isEncoding","actual","slice","fromString","isBuffer","checked","copy","isView","numberIsNaN","fromArrayLike","type","isArray","data","fromObject","assertSize","size","toString","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","swap","n","bidirectionalIndexOf","val","dir","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","found","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","utf8Slice","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","foo","typedArraySupport","console","error","Object","defineProperty","get","this","Symbol","species","configurable","enumerable","writable","poolSize","alloc","fill","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","arguments","hexSlice","asciiSlice","latin1Slice","utf16leSlice","toLocaleString","equals","inspect","max","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","INVALID_BASE64_RE","leadSurrogate","trim","replace","base64clean","src","dst","constructor","ErrorStrings","EPERM","ENOENT","EIO","EBADF","EACCES","EBUSY","EEXIST","ENOTDIR","EISDIR","EINVAL","EFBIG","ENOSPC","EROFS","ENOTEMPTY","ENOTSUP","FileError","[object Object]","message","super","syscall","errno","stack","json","err","fromJSON","JSON","parse","p","create","bufferSize","bytesWritten","stringify","BaseFile","cb","sync","syncSync","uid","gid","mode","atime","mtime","FileFlag","flagStr","validFlagStrs","flagCache","hasOwnProperty","isExclusive","THROW_EXCEPTION","isTruncating","TRUNCATE_FILE","NOP","isWriteable","isAppendable","CREATE_FILE","class2type","nativeIsArray","forEach","object","isEmptyObject","isFunction","isHtmlNode","nodeType","isNumber","isObject","isString","isWindow","window","isSymbol","isObjectLike","objectToString","symbolTag","INFINITY","MAX_INTEGER","NAN","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","toFinite","toNumber","sign","other","valueOf","isBinary","test","isArrayLike","isBoolean","isDefined","isDocument","DOCUMENT_NODE","isElement","isEmpty","isNull","isNumeric","isPlainObject","getPrototypeOf","isSameOrigin","href","origin","location","protocol","hostname","port","startsWith","isUndefined","toInteger","result","remainder","types","objects","noop","returnTrue","returnFalse","funcs","defer","fn","trigger","args","context","cancel","fn1","canceled","id","requestAnimationFrame","cancelAnimationFrame","setTimeout","clearTimeout","paths","_makeLong","_removeDuplicateSeps","_replaceRegex","sep","RegExp","delimiter","posix","win32","normalize","absolute","components","goodComponents","idx","pop","unshift","basename","sections","lastPart","lastPartExt","dirname","extname","format","pathObject","base","isAbsolute","segs","_i","processed","segment","constructs","inherit","ctor","setPrototypeOf","keysFunc","defaults","allKeys","keys","key","has","index","source","l","isMatch","attrs","removeItem","items","item","splice","values","clone","checkCloneMethod","each","callback","isForEach","undef","_mixin","deep","safe","params","shift","sources","_parseMixinArgs","mixin","extend","collection","fromIndex","guard","nativeMax","baseIndexOf","eq","deepEq","SymbolProto","aStack","bStack","className","areArrays","aCtor","bCtor","isEqual","omit","prop1","prop2","pn","pick","fallback","prop","safeMixin","scall","method","arg1","arg2","shadow","filter","find","baseFindIndex","predicate","fromRight","baseIsNaN","flatten","makeArray","startWith","compact","first","func","grep","inArray","toArray","last","merge","second","map","elements","reduce","initialValue","uniq","arrays","createClass","_constructor","_construct","init","props","parent","mixins","options","innerParent","clss","superclass","cls","clsMixines","serialMixins","newCtor","xtor","Function","__mixin__","mergeMixins","klassName","__mixins__","partial","proto","_super","noOverrided","overrides","superFn","overrided","extendClass","f1","klass","Path","_","segments","hasLeading","hasTrailing","_parse","_canonicalize","doIt","_length","anotherPath","append","tail","appendPathStr","appendPath","mySegments","tailSegments","newSegments","endsWith","another","anotherSegments","firstSegment","getExtension","extension","textension","getSegments","getParentPath","parentPath","parentSegments","getRoot","lastSegment","matchingFirstSegments","pathSegments","count","removeFirstSegments","removeLastSegments","removeMatchingFirstSegments","removeMatchingLastSegments","removeRelative","relativeTo","ignoreFilename","baseSegments","commonLength","baseSegmentLength","differenceLength","newSegmentLength","EMPTY","resolve","resolved","relative","to","fromSegs","toSegs","upCount","downSegs","seg","rv","FileType","Stats","itemType","atimeMs","mtimeMs","ctimeMs","birthtimeMs","dev","ino","rdev","nlink","blksize","fileData","currentTime","Date","now","FILE","DIRECTORY","blocks","ceil","ctime","birthtime","getTime","SYMLINK","setImmediate","wrapCbHook","numArgs","wrapCb","hookedCb","arg3","assertRoot","fs","normalizeMode","def","trueMode","normalizeTime","time","normalizePath","normalizeOptions","defEnc","defFlag","defMode","flag","nopCb","FileSystem","F_OK","R_OK","W_OK","X_OK","fdMap","nextFd","rootFS","isAvailable","oldPath","newPath","newCb","rename","renameSync","exists","existsSync","stat","statSync","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","datasync","datasyncSync","arg4","arg5","position","getPos","writeSync","bytesRead","shenanigans","readSync","chown","chownSync","numMode","chmod","chmodSync","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","cbWrapper","isIE","navigator","exec","userAgent","isWebWorker","buffer2Uint8array","buff","uint8Array2Buffer","u8","arrayBuffer2Buffer","ab","emptyBuff","emptyBuffer","deprecationMessage","print","fsName","opts","warn","fail","mkdirpSync","buffer2ArrayBuffer","u8offset","u8Len","arrayish2Buffer","copyingSlice","s0","newS0","bufferValidator","v","checkOptions","fsType","optsInfo","Options","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","optName","opt","providedValue","optional","incorrectOptions","o","distance","levenshtein","sort","description","typeMatches","validator","utils","PreloadFile","_fs","_path","_flag","_stat","contents","_pos","_dirty","_buffer","delta","newPos","isSynchronous","getRootFS","supportsSynch","newBuff","endFp","setPos","endRead","supportsProps","NoSyncFile","registry","add","provider","initialize","rootfs","configure","config","getFileSystem","waitCount","called","finish","fsc","Create","finishedIterating","k","Bufer","BaseProvider","stats","pathNotExistsAction","parentStats","isDirectory","createFile","pathExistsAction","openFile","isLstat","createFileSync","openFileSync","supportsLinks","splitPath","addPaths","doesExist","er","er2","fname","oldCb","err2","isLchmod","isLchown","_syncFile","getPath","getBuffer","DropboxFile","FixPath","ExtractTheFuckingError","reason","GetErrorMessage","user_message","text","error_summary","LookupErrorToError","msg","WriteErrorToError","FilesDeleteWrapped","client","filesDeleteV2","then","catch","path_lookup","path_write","random","DropboxProvider","_client","Dropbox","mainCb","next","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","filesGetMetadata","ref","fileMetadata","flags","downloadArg","filesDownload","fileBlob","fr","FileReader","onload","readAsArrayBuffer","dpError","blob","Blob","commitInfo","filesUpload","metadata","upError","filesCreateFolderV2","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","path_display","has_more","cursor","filesListFolderContinue","ProcessListFolderError",".tag","pathError","debounce","wait","useAnimationFrame","timeout","defered","debounced","delegate","TMP","AnimationTimer","running","self","run","stop","loop","negate","bind","proxy","templateSettings","evaluate","interpolate","escape","noMatch","escapes","'","\\","\r","\n","\t"," "," ","escaper","template","settings","render","matcher","variable","argument","throttle","performance","Promise","always","handler","done","Deferred","promise","makePromise2","reject","_resolve","_reject","isResolved","isPending","isRejected","state","notified","listeners","onResolved","onRejected","onProgress","progress","__ctx__","pipe","notify","resolveWith","_resolved","rejectWith","_rejected","errback","progback","all","race","when","valueOrPromise","receivedPromise","nativePromise","deferred","immediate","async","parallel","ctx","rets","series","waterful","entry","_entry","isDirty","createWriter","writer","onwriteend","onerror","resetDirty","convertError","Html5LfsFile","asyncEach","_getFS","webkitRequestProvider","requestProvider","expectedDir","Html5LfsProvider","PERSISTENT","_allocate","_readdir","finished","deleteEntry","succ","fullPath","removeRecursively","remove","semaphore","successCount","currentPath","success","getDirectory","parentDir","moveTo","getFile","loadAsDir","failedToLoad","exclusive","reader","onloadend","event","bfsFile","_makeFile","ev","_remove","dirEntry","createReader","readEntries","results","errorCallback","webkitPersistentStorage","requestQuota","TEMPORARY","webkitTemporaryStorage","webkitStorageInfo","_requestQuota","granted","isFile","xhrIsAvailable","XMLHttpRequest","getFileSize","req","onreadystatechange","readyState","status","getResponseHeader","send","asyncDownloadFile","jsonSupported","responseType","response","responseText","syncDownloadFile","overrideMimeType","getFileSizeSync","getFileSizeAsync","fetchIsAvailable","fetch","fetchFileAsync","request","ok","arrayBuffer","fetchFileSizeAsync","headers","DirInode","_ls","inode","isDirInode","isDir","FileInode","isFileInode","FileINode","FileIndex","_index","addPath","listing","rootInode","queue","pwd","tree","node","children","getListing","getItem","getData","_split_path","dirpath","itemname","addItem","itemNameMark","substring","itemName","addPathFast","remItem","child","removePath","xhr","syncNotAvailableError","HttpProvider","prefixUrl","preferXHR","fromListing","_requestFileAsyncInternal","_requestFileSizeAsyncInternal","_requestFileSyncInternal","_requestFileSizeSyncInternal","baseUrl","fileIterator","getInode","_requestFileSizeAsync","getStats","_requestFileSizeSync","_requestFileAsync","_requestFileSync","fdCast","fdBuff","tryToString","filePath","_getHTTPPath","strings","generateUUID","r","collections","List","LruNode","prev","LruCache","head","setHead","Inode","getSize","hasChanged","AsyncKeyValueFile","_sync","GenerateRandomID","LRUCache","ROOT_NODE_ID","emptyDirNode","noError","noErrorTx","tx","abort","AsyncKeyValueProvider","cacheSize","_cache","store","makeRootDirectory","removeAll","clear","beginTransaction","oldParent","oldName","newParent","newName","inodes","lists","errorOccurred","theOleSwitcharoo","oldParentList","oldParentINode","newParentList","newParentINode","fileId","completeRename","put","commit","getINode","del","processInodeAndListings","findINodeAndDirListing","dirList","findINode","toStats","commitNewFile","newFile","removeEntry","getDirListing","dirListing","_findINode","fileInodeId","fileInode","inodeChanged","update","toBuffer","currTime","dirInode","getEmptyDirNode","handleDirectoryListings","currId","retries","reroll","committed","parentNode","addNewNode","dataId","fileName","parentListing","fileNodeId","fileNode","preventDefault","onErrorHandler","onsuccess","IndexedDBROTransaction","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","overwrite","_e","IndexedDBRWTransaction","IndexedDBStore","db","storeName","openReq","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","IndexedDBProvider","transaction","objectStore","idbfs","SynchronousProvider","SyncKeyValueProvider","oldDirNode","oldDirList","nodeId","newDirNode","newDirList","newNameNode","SyncKeyValueFile","readDirectory","SimpleSyncRWTransaction","originalData","modifiedKeys","stashOldValue","markModified","InMemoryStore","InMemoryProvider","LocalStorageProvider","localStorage","binaryEncoding","setItem","LocalStorageStore","supportsBinaryString","_locked","_waiters","Mutex","LockedProvider","_mu","getName","diskSpace","isReadOnly","lock","unlock","isLocked","resolvedPath","linkString","_syncAsync","_syncSync","OverlayFile","deletionLogPath","makeModeWritable","getFlag","f","readable","_isInitialized","_initializeCallbacks","_deletedFiles","_deleteLog","_deleteLogUpdatePending","_deleteLogUpdateNeeded","_deleteLogError","_writable","_readable","ApiError","ErrorCode","createParentDirectoriesAsync","createParentDirectories","OverlayFS","callbackArray","_reparseDeletionLog","updateLog","checkInitAsync","checkPathAsync","oldErr","oldStats","newErr","newStats","copyDirContents","oldFile","mkdirErr","readdirErr","checkInitialized","checkPath","oldStat","readFileErr","writableExists","readableExists","deletePath","rmdirLower","dirStats","wFiles","rFiles","seenMap","filtered","fPath","fileP","existsWritable","existsReadable","operateOnWritableAsync","operateOnWritable","addition","toCreate","statDone","createParents","reverse","copyToWritable","copyToWritableAsync","pStats","UnlockedOverlayProvider","OverlayProvider","_initialize","getFSUnlocked","getOverlayedProviders"],"mappings":"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","file":"../skylark-data-files-all.js","sourcesContent":["define('skylark-langx-ns/_attach',[],function(){\r\n    return  function attach(obj1,path,obj2) {\r\n        if (typeof path == \"string\") {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length,\r\n            ns=obj1,\r\n            i=0,\r\n            name = path[i++];\r\n\r\n        while (i < length) {\r\n            ns = ns[name] = ns[name] || {};\r\n            name = path[i++];\r\n        }\r\n\r\n        if (ns[name]) {\r\n            if (obj2) {\r\n                throw new Error(\"This namespace already exists:\" + path);\r\n            }\r\n\r\n        } else {\r\n            ns[name] = obj2 || {};\r\n        }\r\n        return ns[name];\r\n    }\r\n});\ndefine('skylark-langx-ns/ns',[\r\n    \"./_attach\"\r\n], function(_attach) {\r\n    var root = {\r\n    \tattach : function(path,obj) {\r\n    \t\treturn _attach(root,path,obj);\r\n    \t}\r\n    };\r\n    return root;\r\n});\r\n\ndefine('skylark-langx-ns/main',[\r\n\t\"./ns\"\r\n],function(skylark){\r\n\treturn skylark;\r\n});\ndefine('skylark-langx-ns', ['skylark-langx-ns/main'], function (main) { return main; });\n\ndefine('skylark-data-files/files',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"data.files\",{\r\n\t\tproviders : {\r\n\t\t\t\r\n\t\t}\r\n\t});\r\n});\ndefine('skylark-data-files/action-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  var ActionType;\r\n  (function (ActionType) {\r\n      // Indicates that the code should not do anything.\r\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\r\n      // Indicates that the code should throw an exception.\r\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\r\n      // Indicates that the code should truncate the file, but only if it is a file.\r\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\r\n      // Indicates that the code should create the file.\r\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\r\n  })(ActionType || (ActionType = {}));\r\n\r\n  return files.ActionType = ActionType;\r\n});\r\n  \ndefine('skylark-data-files/error-codes',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Standard libc error codes. Add more to this enum and ErrorStrings as they are\r\n   * needed.\r\n   * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\r\n   */\r\n  var ErrorCodes;\r\n  (function (ErrorCodes) {\r\n      ErrorCodes[ErrorCodes[\"EPERM\"] = 1] = \"EPERM\";\r\n      ErrorCodes[ErrorCodes[\"ENOENT\"] = 2] = \"ENOENT\";\r\n      ErrorCodes[ErrorCodes[\"EIO\"] = 5] = \"EIO\";\r\n      ErrorCodes[ErrorCodes[\"EBADF\"] = 9] = \"EBADF\";\r\n      ErrorCodes[ErrorCodes[\"EACCES\"] = 13] = \"EACCES\";\r\n      ErrorCodes[ErrorCodes[\"EBUSY\"] = 16] = \"EBUSY\";\r\n      ErrorCodes[ErrorCodes[\"EEXIST\"] = 17] = \"EEXIST\";\r\n      ErrorCodes[ErrorCodes[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\r\n      ErrorCodes[ErrorCodes[\"EISDIR\"] = 21] = \"EISDIR\";\r\n      ErrorCodes[ErrorCodes[\"EINVAL\"] = 22] = \"EINVAL\";\r\n      ErrorCodes[ErrorCodes[\"EFBIG\"] = 27] = \"EFBIG\";\r\n      ErrorCodes[ErrorCodes[\"ENOSPC\"] = 28] = \"ENOSPC\";\r\n      ErrorCodes[ErrorCodes[\"EROFS\"] = 30] = \"EROFS\";\r\n      ErrorCodes[ErrorCodes[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\r\n      ErrorCodes[ErrorCodes[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\r\n  })(ErrorCodes || (ErrorCodes = {}));\r\n\r\n  return files.ErrorCodes = ErrorCodes;\r\n});\r\n  \ndefine('skylark-langx-binary/binary',[\r\n  \"skylark-langx-ns\",\r\n],function(skylark){\r\n\t\"use strict\";\r\n\r\n\r\n\t/**\r\n\t * Create arraybuffer from binary string\r\n\t *\r\n\t * @method fromBinaryString\r\n\t * @param {String} str\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBinaryString(str) {\r\n\t\tvar length = str.length;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tfor(var i = 0; i < length; i++)\r\n\t\t{\r\n\t\t\tview[i] = str.charCodeAt(i);\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from base64 string\r\n\t *\r\n\t * @method fromBase64\r\n\t * @param {String} base64\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBase64(str){\r\n\t\tvar encoding = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\t\tvar length = str.length / 4 * 3;\r\n\t\tvar arraybuffer = new ArrayBuffer(length);\r\n\t\tvar view = new Uint8Array(arraybuffer);\r\n\r\n\t\tvar a, b, c, d;\r\n\r\n\t\tfor(var i = 0, j = 0; i < length; i += 3)\r\n\t\t{\r\n\t\t\ta = encoding.indexOf(str.charAt(j++));\r\n\t\t\tb = encoding.indexOf(str.charAt(j++));\r\n\t\t\tc = encoding.indexOf(str.charAt(j++));\r\n\t\t\td = encoding.indexOf(str.charAt(j++));\r\n\r\n\t\t\tview[i] = (a << 2) | (b >> 4);\r\n\t\t\tif(c !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+1] = ((b & 15) << 4) | (c >> 2);\r\n\t\t\t}\r\n\t\t\tif(d !== 64)\r\n\t\t\t{\r\n\t\t\t\tview[i+2] = ((c & 3) << 6) | d;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn arraybuffer;\r\n\t}\r\n\r\n\t/**\r\n\t * Create arraybuffer from Nodejs buffer\r\n\t *\r\n\t * @method fromBuffer\r\n\t * @param {Buffer} buffer\r\n\t * @return {Arraybuffer} data\r\n\t */\r\n\tfunction fromBuffer(buffer)\t{\r\n\t\tvar array = new ArrayBuffer(buffer.length);\r\n\t\tvar view = new Uint8Array(array);\r\n\r\n\t\tfor(var i = 0; i < buffer.length; i++)\r\n\t\t{\r\n\t\t\tview[i] = buffer[i];\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t\t//Faster but the results is failing the \"instanceof ArrayBuffer\" test\r\n\t\t//return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n\t};\r\n\r\n\treturn skylark.attach(\"langx.binary\",{\r\n\t\tfromBase64,\r\n\t\tfromBinaryString,\r\n\t\tfromBuffer\r\n\t});\r\n});\ndefine('skylark-langx-binary/base64',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.byteLength = byteLength\r\n  exports.toByteArray = toByteArray\r\n  exports.fromByteArray = fromByteArray\r\n\r\n  var lookup = []\r\n  var revLookup = []\r\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    lookup[i] = code[i]\r\n    revLookup[code.charCodeAt(i)] = i\r\n  }\r\n\r\n  // Support decoding URL-safe base64 strings, as Node.js does.\r\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\n  revLookup['-'.charCodeAt(0)] = 62\r\n  revLookup['_'.charCodeAt(0)] = 63\r\n\r\n  function getLens (b64) {\r\n    var len = b64.length\r\n\r\n    if (len % 4 > 0) {\r\n      throw new Error('Invalid string. Length must be a multiple of 4')\r\n    }\r\n\r\n    // Trim off extra bytes after placeholder bytes are found\r\n    // See: https://github.com/beatgammit/base64-js/issues/42\r\n    var validLen = b64.indexOf('=')\r\n    if (validLen === -1) validLen = len\r\n\r\n    var placeHoldersLen = validLen === len\r\n      ? 0\r\n      : 4 - (validLen % 4)\r\n\r\n    return [validLen, placeHoldersLen]\r\n  }\r\n\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  function byteLength (b64) {\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function _byteLength (b64, validLen, placeHoldersLen) {\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function toByteArray (b64) {\r\n    var tmp\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n\r\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n    var curByte = 0\r\n\r\n    // if there are placeholders, only get up to the last complete 4 chars\r\n    var len = placeHoldersLen > 0\r\n      ? validLen - 4\r\n      : validLen\r\n\r\n    var i\r\n    for (i = 0; i < len; i += 4) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 18) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n        (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n        revLookup[b64.charCodeAt(i + 3)]\r\n      arr[curByte++] = (tmp >> 16) & 0xFF\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 2) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 2) |\r\n        (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 1) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 10) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n        (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    return arr\r\n  }\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] +\r\n      lookup[num >> 12 & 0x3F] +\r\n      lookup[num >> 6 & 0x3F] +\r\n      lookup[num & 0x3F]\r\n  }\r\n\r\n  function encodeChunk (uint8, start, end) {\r\n    var tmp\r\n    var output = []\r\n    for (var i = start; i < end; i += 3) {\r\n      tmp =\r\n        ((uint8[i] << 16) & 0xFF0000) +\r\n        ((uint8[i + 1] << 8) & 0xFF00) +\r\n        (uint8[i + 2] & 0xFF)\r\n      output.push(tripletToBase64(tmp))\r\n    }\r\n    return output.join('')\r\n  }\r\n\r\n  function fromByteArray (uint8) {\r\n    var tmp\r\n    var len = uint8.length\r\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n    var parts = []\r\n    var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n    // go through the array every three bytes, we'll deal with trailing stuff later\r\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n      parts.push(encodeChunk(\r\n        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n      ))\r\n    }\r\n\r\n    // pad the end with zeros, but make sure to not forget the extra bytes\r\n    if (extraBytes === 1) {\r\n      tmp = uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 2] +\r\n        lookup[(tmp << 4) & 0x3F] +\r\n        '=='\r\n      )\r\n    } else if (extraBytes === 2) {\r\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 10] +\r\n        lookup[(tmp >> 4) & 0x3F] +\r\n        lookup[(tmp << 2) & 0x3F] +\r\n        '='\r\n      )\r\n    }\r\n\r\n    return parts.join('')\r\n  }\r\n\r\n  return exports;\r\n});\ndefine('skylark-langx-binary/ieee754',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n    var e, m\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var nBits = -7\r\n    var i = isLE ? (nBytes - 1) : 0\r\n    var d = isLE ? -1 : 1\r\n    var s = buffer[offset + i]\r\n\r\n    i += d\r\n\r\n    e = s & ((1 << (-nBits)) - 1)\r\n    s >>= (-nBits)\r\n    nBits += eLen\r\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    m = e & ((1 << (-nBits)) - 1)\r\n    e >>= (-nBits)\r\n    nBits += mLen\r\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    if (e === 0) {\r\n      e = 1 - eBias\r\n    } else if (e === eMax) {\r\n      return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n    } else {\r\n      m = m + Math.pow(2, mLen)\r\n      e = e - eBias\r\n    }\r\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n  }\r\n\r\n  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n    var e, m, c\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n    var i = isLE ? 0 : (nBytes - 1)\r\n    var d = isLE ? 1 : -1\r\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n    value = Math.abs(value)\r\n\r\n    if (isNaN(value) || value === Infinity) {\r\n      m = isNaN(value) ? 1 : 0\r\n      e = eMax\r\n    } else {\r\n      e = Math.floor(Math.log(value) / Math.LN2)\r\n      if (value * (c = Math.pow(2, -e)) < 1) {\r\n        e--\r\n        c *= 2\r\n      }\r\n      if (e + eBias >= 1) {\r\n        value += rt / c\r\n      } else {\r\n        value += rt * Math.pow(2, 1 - eBias)\r\n      }\r\n      if (value * c >= 2) {\r\n        e++\r\n        c /= 2\r\n      }\r\n\r\n      if (e + eBias >= eMax) {\r\n        m = 0\r\n        e = eMax\r\n      } else if (e + eBias >= 1) {\r\n        m = ((value * c) - 1) * Math.pow(2, mLen)\r\n        e = e + eBias\r\n      } else {\r\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n        e = 0\r\n      }\r\n    }\r\n\r\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n    e = (e << mLen) | m\r\n    eLen += mLen\r\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n    buffer[offset + i - d] |= s * 128\r\n  }\r\n\r\n  return exports;\r\n});\r\n\ndefine('skylark-langx-binary/buffer',[\r\n  \"./binary\",\r\n  \"./base64\",\r\n  \"./ieee754\"\r\n],function(binary,base64,ieee754){\r\n  /*!\r\n   * The buffer module from node.js, for the browser.\r\n   *\r\n   * @author   Feross Aboukhadijeh <https://feross.org>\r\n   * @license  MIT\r\n   */\r\n  /* eslint-disable no-proto */\r\n\r\n  'use strict'\r\n\r\n\r\n  Buffer.INSPECT_MAX_BYTES = 50\r\n\r\n  var K_MAX_LENGTH = 0x7fffffff\r\n  Buffer.kMaxLength = K_MAX_LENGTH\r\n\r\n  /**\r\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n   *   === true    Use Uint8Array implementation (fastest)\r\n   *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n   *               implementation (most compatible, even IE6)\r\n   *\r\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n   * Opera 11.6+, iOS 4.2+.\r\n   *\r\n   * We report that the browser does not support typed arrays if the are not subclassable\r\n   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n   * for __proto__ and has a buggy typed array implementation.\r\n   */\r\n  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n      typeof console.error === 'function') {\r\n    console.error(\r\n      'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n    )\r\n  }\r\n\r\n  function typedArraySupport () {\r\n    // Can typed array instances can be augmented?\r\n    try {\r\n      var arr = new Uint8Array(1)\r\n      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n      return arr.foo() === 42\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Buffer.prototype, 'parent', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.buffer\r\n    }\r\n  })\r\n\r\n  Object.defineProperty(Buffer.prototype, 'offset', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.byteOffset\r\n    }\r\n  })\r\n\r\n  function createBuffer (length) {\r\n    if (length > K_MAX_LENGTH) {\r\n      throw new RangeError('Invalid typed array length')\r\n    }\r\n    // Return an augmented `Uint8Array` instance\r\n    var buf = new Uint8Array(length)\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  /**\r\n   * The Buffer constructor returns instances of `Uint8Array` that have their\r\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n   * returns a single octet.\r\n   *\r\n   * The `Uint8Array` prototype remains unmodified.\r\n   */\r\n\r\n  function Buffer (arg, encodingOrOffset, length) {\r\n    // Common case.\r\n    if (typeof arg === 'number') {\r\n      if (typeof encodingOrOffset === 'string') {\r\n        throw new Error(\r\n          'If encoding is specified then the first argument must be a string'\r\n        )\r\n      }\r\n      return allocUnsafe(arg)\r\n    }\r\n    return from(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false\r\n    })\r\n  }\r\n\r\n  Buffer.poolSize = 8192 // not used by this implementation\r\n\r\n  function from (value, encodingOrOffset, length) {\r\n    if (typeof value === 'number') {\r\n      throw new TypeError('\"value\" argument must not be a number')\r\n    }\r\n\r\n    if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\r\n      return fromArrayBuffer(value, encodingOrOffset, length)\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return fromString(value, encodingOrOffset)\r\n    }\r\n\r\n    return fromObject(value)\r\n  }\r\n\r\n  /**\r\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n   * if value is a number.\r\n   * Buffer.from(str[, encoding])\r\n   * Buffer.from(array)\r\n   * Buffer.from(buffer)\r\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n   **/\r\n  Buffer.from = function (value, encodingOrOffset, length) {\r\n    return from(value, encodingOrOffset, length)\r\n  }\r\n\r\n  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n  // https://github.com/feross/buffer/pull/148\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n\r\n  function assertSize (size) {\r\n    if (typeof size !== 'number') {\r\n      throw new TypeError('\"size\" argument must be of type number')\r\n    } else if (size < 0) {\r\n      throw new RangeError('\"size\" argument must not be negative')\r\n    }\r\n  }\r\n\r\n  function alloc (size, fill, encoding) {\r\n    assertSize(size)\r\n    if (size <= 0) {\r\n      return createBuffer(size)\r\n    }\r\n    if (fill !== undefined) {\r\n      // Only pay attention to encoding if it's a string. This\r\n      // prevents accidentally sending in a number that would\r\n      // be interpretted as a start offset.\r\n      return typeof encoding === 'string'\r\n        ? createBuffer(size).fill(fill, encoding)\r\n        : createBuffer(size).fill(fill)\r\n    }\r\n    return createBuffer(size)\r\n  }\r\n\r\n  /**\r\n   * Creates a new filled Buffer instance.\r\n   * alloc(size[, fill[, encoding]])\r\n   **/\r\n  Buffer.alloc = function (size, fill, encoding) {\r\n    return alloc(size, fill, encoding)\r\n  }\r\n\r\n  function allocUnsafe (size) {\r\n    assertSize(size)\r\n    return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n  }\r\n\r\n  /**\r\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n   * */\r\n  Buffer.allocUnsafe = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n  /**\r\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n   */\r\n  Buffer.allocUnsafeSlow = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n\r\n  function fromString (string, encoding) {\r\n    if (typeof encoding !== 'string' || encoding === '') {\r\n      encoding = 'utf8'\r\n    }\r\n\r\n    if (!Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n\r\n    var length = byteLength(string, encoding) | 0\r\n    var buf = createBuffer(length)\r\n\r\n    var actual = buf.write(string, encoding)\r\n\r\n    if (actual !== length) {\r\n      // Writing a hex string, for example, that contains invalid characters will\r\n      // cause everything after the first invalid character to be ignored. (e.g.\r\n      // 'abxxcd' will be treated as 'ab')\r\n      buf = buf.slice(0, actual)\r\n    }\r\n\r\n    return buf\r\n  }\r\n\r\n  function fromArrayLike (array) {\r\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n    var buf = createBuffer(length)\r\n    for (var i = 0; i < length; i += 1) {\r\n      buf[i] = array[i] & 255\r\n    }\r\n    return buf\r\n  }\r\n\r\n  function fromArrayBuffer (array, byteOffset, length) {\r\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n      throw new RangeError('\"offset\" is outside of buffer bounds')\r\n    }\r\n\r\n    if (array.byteLength < byteOffset + (length || 0)) {\r\n      throw new RangeError('\"length\" is outside of buffer bounds')\r\n    }\r\n\r\n    var buf\r\n    if (byteOffset === undefined && length === undefined) {\r\n      buf = new Uint8Array(array)\r\n    } else if (length === undefined) {\r\n      buf = new Uint8Array(array, byteOffset)\r\n    } else {\r\n      buf = new Uint8Array(array, byteOffset, length)\r\n    }\r\n\r\n    // Return an augmented `Uint8Array` instance\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  function fromObject (obj) {\r\n    if (Buffer.isBuffer(obj)) {\r\n      var len = checked(obj.length) | 0\r\n      var buf = createBuffer(len)\r\n\r\n      if (buf.length === 0) {\r\n        return buf\r\n      }\r\n\r\n      obj.copy(buf, 0, 0, len)\r\n      return buf\r\n    }\r\n\r\n    if (obj) {\r\n      if (ArrayBuffer.isView(obj) || 'length' in obj) {\r\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n          return createBuffer(0)\r\n        }\r\n        return fromArrayLike(obj)\r\n      }\r\n\r\n      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n        return fromArrayLike(obj.data)\r\n      }\r\n    }\r\n\r\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\r\n  }\r\n\r\n  function checked (length) {\r\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n    // length is NaN (which is otherwise coerced to zero.)\r\n    if (length >= K_MAX_LENGTH) {\r\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n    }\r\n    return length | 0\r\n  }\r\n\r\n  function SlowBuffer (length) {\r\n    if (+length != length) { // eslint-disable-line eqeqeq\r\n      length = 0\r\n    }\r\n    return Buffer.alloc(+length)\r\n  }\r\n\r\n  Buffer.isBuffer = function isBuffer (b) {\r\n    return b != null && b._isBuffer === true\r\n  }\r\n\r\n  Buffer.compare = function compare (a, b) {\r\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n      throw new TypeError('Arguments must be Buffers')\r\n    }\r\n\r\n    if (a === b) return 0\r\n\r\n    var x = a.length\r\n    var y = b.length\r\n\r\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n      if (a[i] !== b[i]) {\r\n        x = a[i]\r\n        y = b[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  Buffer.isEncoding = function isEncoding (encoding) {\r\n    switch (String(encoding).toLowerCase()) {\r\n      case 'hex':\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n      case 'base64':\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return true\r\n      default:\r\n        return false\r\n    }\r\n  }\r\n\r\n  Buffer.concat = function concat (list, length) {\r\n    if (!Array.isArray(list)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n\r\n    if (list.length === 0) {\r\n      return Buffer.alloc(0)\r\n    }\r\n\r\n    var i\r\n    if (length === undefined) {\r\n      length = 0\r\n      for (i = 0; i < list.length; ++i) {\r\n        length += list[i].length\r\n      }\r\n    }\r\n\r\n    var buffer = Buffer.allocUnsafe(length)\r\n    var pos = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      var buf = list[i]\r\n      if (ArrayBuffer.isView(buf)) {\r\n        buf = Buffer.from(buf)\r\n      }\r\n      if (!Buffer.isBuffer(buf)) {\r\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n      }\r\n      buf.copy(buffer, pos)\r\n      pos += buf.length\r\n    }\r\n    return buffer\r\n  }\r\n\r\n  function byteLength (string, encoding) {\r\n    if (Buffer.isBuffer(string)) {\r\n      return string.length\r\n    }\r\n    if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\r\n      return string.byteLength\r\n    }\r\n    if (typeof string !== 'string') {\r\n      string = '' + string\r\n    }\r\n\r\n    var len = string.length\r\n    if (len === 0) return 0\r\n\r\n    // Use a for loop to avoid recursion\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'ascii':\r\n        case 'latin1':\r\n        case 'binary':\r\n          return len\r\n        case 'utf8':\r\n        case 'utf-8':\r\n        case undefined:\r\n          return utf8ToBytes(string).length\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return len * 2\r\n        case 'hex':\r\n          return len >>> 1\r\n        case 'base64':\r\n          return base64ToBytes(string).length\r\n        default:\r\n          if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n  Buffer.byteLength = byteLength\r\n\r\n  function slowToString (encoding, start, end) {\r\n    var loweredCase = false\r\n\r\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n    // property of a typed array.\r\n\r\n    // This behaves neither like String nor Uint8Array in that we set start/end\r\n    // to their upper/lower bounds if the value passed is out of range.\r\n    // undefined is handled specially as per ECMA-262 6th Edition,\r\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n    if (start === undefined || start < 0) {\r\n      start = 0\r\n    }\r\n    // Return early if start > this.length. Done here to prevent potential uint32\r\n    // coercion fail below.\r\n    if (start > this.length) {\r\n      return ''\r\n    }\r\n\r\n    if (end === undefined || end > this.length) {\r\n      end = this.length\r\n    }\r\n\r\n    if (end <= 0) {\r\n      return ''\r\n    }\r\n\r\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n    end >>>= 0\r\n    start >>>= 0\r\n\r\n    if (end <= start) {\r\n      return ''\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    while (true) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexSlice(this, start, end)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Slice(this, start, end)\r\n\r\n        case 'ascii':\r\n          return asciiSlice(this, start, end)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Slice(this, start, end)\r\n\r\n        case 'base64':\r\n          return base64Slice(this, start, end)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return utf16leSlice(this, start, end)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = (encoding + '').toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n  // reliably in a browserify context because there could be multiple different\r\n  // copies of the 'buffer' package in use. This method works even for Buffer\r\n  // instances that were created from another copy of the `buffer` package.\r\n  // See: https://github.com/feross/buffer/issues/154\r\n  Buffer.prototype._isBuffer = true\r\n\r\n  function swap (b, n, m) {\r\n    var i = b[n]\r\n    b[n] = b[m]\r\n    b[m] = i\r\n  }\r\n\r\n  Buffer.prototype.swap16 = function swap16 () {\r\n    var len = this.length\r\n    if (len % 2 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 2) {\r\n      swap(this, i, i + 1)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap32 = function swap32 () {\r\n    var len = this.length\r\n    if (len % 4 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 4) {\r\n      swap(this, i, i + 3)\r\n      swap(this, i + 1, i + 2)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap64 = function swap64 () {\r\n    var len = this.length\r\n    if (len % 8 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 8) {\r\n      swap(this, i, i + 7)\r\n      swap(this, i + 1, i + 6)\r\n      swap(this, i + 2, i + 5)\r\n      swap(this, i + 3, i + 4)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.toString = function toString () {\r\n    var length = this.length\r\n    if (length === 0) return ''\r\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n    return slowToString.apply(this, arguments)\r\n  }\r\n\r\n  Buffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\n  Buffer.prototype.equals = function equals (b) {\r\n    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n    if (this === b) return true\r\n    return Buffer.compare(this, b) === 0\r\n  }\r\n\r\n  Buffer.prototype.inspect = function inspect () {\r\n    var str = ''\r\n    var max = Buffer.INSPECT_MAX_BYTES\r\n    if (this.length > 0) {\r\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n      if (this.length > max) str += ' ... '\r\n    }\r\n    return '<Buffer ' + str + '>'\r\n  }\r\n\r\n  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n    if (!Buffer.isBuffer(target)) {\r\n      throw new TypeError('Argument must be a Buffer')\r\n    }\r\n\r\n    if (start === undefined) {\r\n      start = 0\r\n    }\r\n    if (end === undefined) {\r\n      end = target ? target.length : 0\r\n    }\r\n    if (thisStart === undefined) {\r\n      thisStart = 0\r\n    }\r\n    if (thisEnd === undefined) {\r\n      thisEnd = this.length\r\n    }\r\n\r\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n      throw new RangeError('out of range index')\r\n    }\r\n\r\n    if (thisStart >= thisEnd && start >= end) {\r\n      return 0\r\n    }\r\n    if (thisStart >= thisEnd) {\r\n      return -1\r\n    }\r\n    if (start >= end) {\r\n      return 1\r\n    }\r\n\r\n    start >>>= 0\r\n    end >>>= 0\r\n    thisStart >>>= 0\r\n    thisEnd >>>= 0\r\n\r\n    if (this === target) return 0\r\n\r\n    var x = thisEnd - thisStart\r\n    var y = end - start\r\n    var len = Math.min(x, y)\r\n\r\n    var thisCopy = this.slice(thisStart, thisEnd)\r\n    var targetCopy = target.slice(start, end)\r\n\r\n    for (var i = 0; i < len; ++i) {\r\n      if (thisCopy[i] !== targetCopy[i]) {\r\n        x = thisCopy[i]\r\n        y = targetCopy[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n  //\r\n  // Arguments:\r\n  // - buffer - a Buffer to search\r\n  // - val - a string, Buffer, or number\r\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\r\n  // - encoding - an optional encoding, relevant is val is a string\r\n  // - dir - true for indexOf, false for lastIndexOf\r\n  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n    // Empty buffer means no match\r\n    if (buffer.length === 0) return -1\r\n\r\n    // Normalize byteOffset\r\n    if (typeof byteOffset === 'string') {\r\n      encoding = byteOffset\r\n      byteOffset = 0\r\n    } else if (byteOffset > 0x7fffffff) {\r\n      byteOffset = 0x7fffffff\r\n    } else if (byteOffset < -0x80000000) {\r\n      byteOffset = -0x80000000\r\n    }\r\n    byteOffset = +byteOffset  // Coerce to Number.\r\n    if (numberIsNaN(byteOffset)) {\r\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n      byteOffset = dir ? 0 : (buffer.length - 1)\r\n    }\r\n\r\n    // Normalize byteOffset: negative offsets start from the end of the buffer\r\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n    if (byteOffset >= buffer.length) {\r\n      if (dir) return -1\r\n      else byteOffset = buffer.length - 1\r\n    } else if (byteOffset < 0) {\r\n      if (dir) byteOffset = 0\r\n      else return -1\r\n    }\r\n\r\n    // Normalize val\r\n    if (typeof val === 'string') {\r\n      val = Buffer.from(val, encoding)\r\n    }\r\n\r\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n    if (Buffer.isBuffer(val)) {\r\n      // Special case: looking for empty string/buffer always fails\r\n      if (val.length === 0) {\r\n        return -1\r\n      }\r\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n    } else if (typeof val === 'number') {\r\n      val = val & 0xFF // Search for a byte value [0-255]\r\n      if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n        if (dir) {\r\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n        } else {\r\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n        }\r\n      }\r\n      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n    }\r\n\r\n    throw new TypeError('val must be string, number or Buffer')\r\n  }\r\n\r\n  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n    var indexSize = 1\r\n    var arrLength = arr.length\r\n    var valLength = val.length\r\n\r\n    if (encoding !== undefined) {\r\n      encoding = String(encoding).toLowerCase()\r\n      if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n          encoding === 'utf16le' || encoding === 'utf-16le') {\r\n        if (arr.length < 2 || val.length < 2) {\r\n          return -1\r\n        }\r\n        indexSize = 2\r\n        arrLength /= 2\r\n        valLength /= 2\r\n        byteOffset /= 2\r\n      }\r\n    }\r\n\r\n    function read (buf, i) {\r\n      if (indexSize === 1) {\r\n        return buf[i]\r\n      } else {\r\n        return buf.readUInt16BE(i * indexSize)\r\n      }\r\n    }\r\n\r\n    var i\r\n    if (dir) {\r\n      var foundIndex = -1\r\n      for (i = byteOffset; i < arrLength; i++) {\r\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n          if (foundIndex === -1) foundIndex = i\r\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n        } else {\r\n          if (foundIndex !== -1) i -= i - foundIndex\r\n          foundIndex = -1\r\n        }\r\n      }\r\n    } else {\r\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n      for (i = byteOffset; i >= 0; i--) {\r\n        var found = true\r\n        for (var j = 0; j < valLength; j++) {\r\n          if (read(arr, i + j) !== read(val, j)) {\r\n            found = false\r\n            break\r\n          }\r\n        }\r\n        if (found) return i\r\n      }\r\n    }\r\n\r\n    return -1\r\n  }\r\n\r\n  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n    return this.indexOf(val, byteOffset, encoding) !== -1\r\n  }\r\n\r\n  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n  }\r\n\r\n  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n  }\r\n\r\n  function hexWrite (buf, string, offset, length) {\r\n    offset = Number(offset) || 0\r\n    var remaining = buf.length - offset\r\n    if (!length) {\r\n      length = remaining\r\n    } else {\r\n      length = Number(length)\r\n      if (length > remaining) {\r\n        length = remaining\r\n      }\r\n    }\r\n\r\n    var strLen = string.length\r\n\r\n    if (length > strLen / 2) {\r\n      length = strLen / 2\r\n    }\r\n    for (var i = 0; i < length; ++i) {\r\n      var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n      if (numberIsNaN(parsed)) return i\r\n      buf[offset + i] = parsed\r\n    }\r\n    return i\r\n  }\r\n\r\n  function utf8Write (buf, string, offset, length) {\r\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  function asciiWrite (buf, string, offset, length) {\r\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function latin1Write (buf, string, offset, length) {\r\n    return asciiWrite(buf, string, offset, length)\r\n  }\r\n\r\n  function base64Write (buf, string, offset, length) {\r\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function ucs2Write (buf, string, offset, length) {\r\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  Buffer.prototype.write = function write (string, offset, length, encoding) {\r\n    // Buffer#write(string)\r\n    if (offset === undefined) {\r\n      encoding = 'utf8'\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, encoding)\r\n    } else if (length === undefined && typeof offset === 'string') {\r\n      encoding = offset\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, offset[, length][, encoding])\r\n    } else if (isFinite(offset)) {\r\n      offset = offset >>> 0\r\n      if (isFinite(length)) {\r\n        length = length >>> 0\r\n        if (encoding === undefined) encoding = 'utf8'\r\n      } else {\r\n        encoding = length\r\n        length = undefined\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n      )\r\n    }\r\n\r\n    var remaining = this.length - offset\r\n    if (length === undefined || length > remaining) length = remaining\r\n\r\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n      throw new RangeError('Attempt to write outside buffer bounds')\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexWrite(this, string, offset, length)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Write(this, string, offset, length)\r\n\r\n        case 'ascii':\r\n          return asciiWrite(this, string, offset, length)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Write(this, string, offset, length)\r\n\r\n        case 'base64':\r\n          // Warning: maxLength not taken into account in base64Write\r\n          return base64Write(this, string, offset, length)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return ucs2Write(this, string, offset, length)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  Buffer.prototype.toJSON = function toJSON () {\r\n    return {\r\n      type: 'Buffer',\r\n      data: Array.prototype.slice.call(this._arr || this, 0)\r\n    }\r\n  }\r\n\r\n  function base64Slice (buf, start, end) {\r\n    if (start === 0 && end === buf.length) {\r\n      return base64.fromByteArray(buf)\r\n    } else {\r\n      return base64.fromByteArray(buf.slice(start, end))\r\n    }\r\n  }\r\n\r\n  function utf8Slice (buf, start, end) {\r\n    end = Math.min(buf.length, end)\r\n    var res = []\r\n\r\n    var i = start\r\n    while (i < end) {\r\n      var firstByte = buf[i]\r\n      var codePoint = null\r\n      var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n        : (firstByte > 0xDF) ? 3\r\n        : (firstByte > 0xBF) ? 2\r\n        : 1\r\n\r\n      if (i + bytesPerSequence <= end) {\r\n        var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n        switch (bytesPerSequence) {\r\n          case 1:\r\n            if (firstByte < 0x80) {\r\n              codePoint = firstByte\r\n            }\r\n            break\r\n          case 2:\r\n            secondByte = buf[i + 1]\r\n            if ((secondByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n              if (tempCodePoint > 0x7F) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 3:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 4:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            fourthByte = buf[i + 3]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n        }\r\n      }\r\n\r\n      if (codePoint === null) {\r\n        // we did not generate a valid codePoint so insert a\r\n        // replacement char (U+FFFD) and advance only 1 byte\r\n        codePoint = 0xFFFD\r\n        bytesPerSequence = 1\r\n      } else if (codePoint > 0xFFFF) {\r\n        // encode to utf16 (surrogate pair dance)\r\n        codePoint -= 0x10000\r\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n        codePoint = 0xDC00 | codePoint & 0x3FF\r\n      }\r\n\r\n      res.push(codePoint)\r\n      i += bytesPerSequence\r\n    }\r\n\r\n    return decodeCodePointsArray(res)\r\n  }\r\n\r\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n  // the lowest limit is Chrome, with 0x10000 args.\r\n  // We go 1 magnitude less, for safety\r\n  var MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\n  function decodeCodePointsArray (codePoints) {\r\n    var len = codePoints.length\r\n    if (len <= MAX_ARGUMENTS_LENGTH) {\r\n      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n    }\r\n\r\n    // Decode in chunks to avoid \"call stack size exceeded\".\r\n    var res = ''\r\n    var i = 0\r\n    while (i < len) {\r\n      res += String.fromCharCode.apply(\r\n        String,\r\n        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n      )\r\n    }\r\n    return res\r\n  }\r\n\r\n  function asciiSlice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i] & 0x7F)\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function latin1Slice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i])\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function hexSlice (buf, start, end) {\r\n    var len = buf.length\r\n\r\n    if (!start || start < 0) start = 0\r\n    if (!end || end < 0 || end > len) end = len\r\n\r\n    var out = ''\r\n    for (var i = start; i < end; ++i) {\r\n      out += toHex(buf[i])\r\n    }\r\n    return out\r\n  }\r\n\r\n  function utf16leSlice (buf, start, end) {\r\n    var bytes = buf.slice(start, end)\r\n    var res = ''\r\n    for (var i = 0; i < bytes.length; i += 2) {\r\n      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n    }\r\n    return res\r\n  }\r\n\r\n  Buffer.prototype.slice = function slice (start, end) {\r\n    var len = this.length\r\n    start = ~~start\r\n    end = end === undefined ? len : ~~end\r\n\r\n    if (start < 0) {\r\n      start += len\r\n      if (start < 0) start = 0\r\n    } else if (start > len) {\r\n      start = len\r\n    }\r\n\r\n    if (end < 0) {\r\n      end += len\r\n      if (end < 0) end = 0\r\n    } else if (end > len) {\r\n      end = len\r\n    }\r\n\r\n    if (end < start) end = start\r\n\r\n    var newBuf = this.subarray(start, end)\r\n    // Return an augmented `Uint8Array` instance\r\n    newBuf.__proto__ = Buffer.prototype\r\n    return newBuf\r\n  }\r\n\r\n  /*\r\n   * Need to make sure that buffer isn't trying to write out of bounds.\r\n   */\r\n  function checkOffset (offset, ext, length) {\r\n    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n  }\r\n\r\n  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      checkOffset(offset, byteLength, this.length)\r\n    }\r\n\r\n    var val = this[offset + --byteLength]\r\n    var mul = 1\r\n    while (byteLength > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --byteLength] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    return this[offset]\r\n  }\r\n\r\n  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return this[offset] | (this[offset + 1] << 8)\r\n  }\r\n\r\n  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return (this[offset] << 8) | this[offset + 1]\r\n  }\r\n\r\n  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return ((this[offset]) |\r\n        (this[offset + 1] << 8) |\r\n        (this[offset + 2] << 16)) +\r\n        (this[offset + 3] * 0x1000000)\r\n  }\r\n\r\n  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] * 0x1000000) +\r\n      ((this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var i = byteLength\r\n    var mul = 1\r\n    var val = this[offset + --i]\r\n    while (i > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    if (!(this[offset] & 0x80)) return (this[offset])\r\n    return ((0xff - this[offset] + 1) * -1)\r\n  }\r\n\r\n  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset] | (this[offset + 1] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset + 1] | (this[offset] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16) |\r\n      (this[offset + 3] << 24)\r\n  }\r\n\r\n  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] << 24) |\r\n      (this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      (this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, true, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, false, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, true, 52, 8)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, false, 52, 8)\r\n  }\r\n\r\n  function checkInt (buf, value, offset, ext, max, min) {\r\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var mul = 1\r\n    var i = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = 0\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n    if (value < 0) value = 0xff + value + 1\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    if (value < 0) value = 0xffffffff + value + 1\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  function checkIEEE754 (buf, value, offset, ext, max, min) {\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n    if (offset < 0) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  function writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  function writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n    return offset + 8\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\n  Buffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n    if (!start) start = 0\r\n    if (!end && end !== 0) end = this.length\r\n    if (targetStart >= target.length) targetStart = target.length\r\n    if (!targetStart) targetStart = 0\r\n    if (end > 0 && end < start) end = start\r\n\r\n    // Copy 0 bytes; we're done\r\n    if (end === start) return 0\r\n    if (target.length === 0 || this.length === 0) return 0\r\n\r\n    // Fatal error conditions\r\n    if (targetStart < 0) {\r\n      throw new RangeError('targetStart out of bounds')\r\n    }\r\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n    // Are we oob?\r\n    if (end > this.length) end = this.length\r\n    if (target.length - targetStart < end - start) {\r\n      end = target.length - targetStart + start\r\n    }\r\n\r\n    var len = end - start\r\n\r\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n      // Use built-in when available, missing from IE11\r\n      this.copyWithin(targetStart, start, end)\r\n    } else if (this === target && start < targetStart && targetStart < end) {\r\n      // descending copy from end\r\n      for (var i = len - 1; i >= 0; --i) {\r\n        target[i + targetStart] = this[i + start]\r\n      }\r\n    } else {\r\n      Uint8Array.prototype.set.call(\r\n        target,\r\n        this.subarray(start, end),\r\n        targetStart\r\n      )\r\n    }\r\n\r\n    return len\r\n  }\r\n\r\n  // Usage:\r\n  //    buffer.fill(number[, offset[, end]])\r\n  //    buffer.fill(buffer[, offset[, end]])\r\n  //    buffer.fill(string[, offset[, end]][, encoding])\r\n  Buffer.prototype.fill = function fill (val, start, end, encoding) {\r\n    // Handle string cases:\r\n    if (typeof val === 'string') {\r\n      if (typeof start === 'string') {\r\n        encoding = start\r\n        start = 0\r\n        end = this.length\r\n      } else if (typeof end === 'string') {\r\n        encoding = end\r\n        end = this.length\r\n      }\r\n      if (encoding !== undefined && typeof encoding !== 'string') {\r\n        throw new TypeError('encoding must be a string')\r\n      }\r\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n        throw new TypeError('Unknown encoding: ' + encoding)\r\n      }\r\n      if (val.length === 1) {\r\n        var code = val.charCodeAt(0)\r\n        if ((encoding === 'utf8' && code < 128) ||\r\n            encoding === 'latin1') {\r\n          // Fast path: If `val` fits into a single byte, use that numeric value.\r\n          val = code\r\n        }\r\n      }\r\n    } else if (typeof val === 'number') {\r\n      val = val & 255\r\n    }\r\n\r\n    // Invalid ranges are not set to a default, so can range check early.\r\n    if (start < 0 || this.length < start || this.length < end) {\r\n      throw new RangeError('Out of range index')\r\n    }\r\n\r\n    if (end <= start) {\r\n      return this\r\n    }\r\n\r\n    start = start >>> 0\r\n    end = end === undefined ? this.length : end >>> 0\r\n\r\n    if (!val) val = 0\r\n\r\n    var i\r\n    if (typeof val === 'number') {\r\n      for (i = start; i < end; ++i) {\r\n        this[i] = val\r\n      }\r\n    } else {\r\n      var bytes = Buffer.isBuffer(val)\r\n        ? val\r\n        : new Buffer(val, encoding)\r\n      var len = bytes.length\r\n      if (len === 0) {\r\n        throw new TypeError('The value \"' + val +\r\n          '\" is invalid for argument \"value\"')\r\n      }\r\n      for (i = 0; i < end - start; ++i) {\r\n        this[i + start] = bytes[i % len]\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // HELPER FUNCTIONS\r\n  // ================\r\n\r\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\n  function base64clean (str) {\r\n    // Node takes equal signs as end of the Base64 encoding\r\n    str = str.split('=')[0]\r\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n    str = str.trim().replace(INVALID_BASE64_RE, '')\r\n    // Node converts strings with length < 2 to ''\r\n    if (str.length < 2) return ''\r\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n    while (str.length % 4 !== 0) {\r\n      str = str + '='\r\n    }\r\n    return str\r\n  }\r\n\r\n  function toHex (n) {\r\n    if (n < 16) return '0' + n.toString(16)\r\n    return n.toString(16)\r\n  }\r\n\r\n  function utf8ToBytes (string, units) {\r\n    units = units || Infinity\r\n    var codePoint\r\n    var length = string.length\r\n    var leadSurrogate = null\r\n    var bytes = []\r\n\r\n    for (var i = 0; i < length; ++i) {\r\n      codePoint = string.charCodeAt(i)\r\n\r\n      // is surrogate component\r\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n        // last char was a lead\r\n        if (!leadSurrogate) {\r\n          // no lead yet\r\n          if (codePoint > 0xDBFF) {\r\n            // unexpected trail\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          } else if (i + 1 === length) {\r\n            // unpaired lead\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          }\r\n\r\n          // valid lead\r\n          leadSurrogate = codePoint\r\n\r\n          continue\r\n        }\r\n\r\n        // 2 leads in a row\r\n        if (codePoint < 0xDC00) {\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          leadSurrogate = codePoint\r\n          continue\r\n        }\r\n\r\n        // valid surrogate pair\r\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n      } else if (leadSurrogate) {\r\n        // valid bmp char, but last char was a lead\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n      }\r\n\r\n      leadSurrogate = null\r\n\r\n      // encode utf8\r\n      if (codePoint < 0x80) {\r\n        if ((units -= 1) < 0) break\r\n        bytes.push(codePoint)\r\n      } else if (codePoint < 0x800) {\r\n        if ((units -= 2) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x6 | 0xC0,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x10000) {\r\n        if ((units -= 3) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0xC | 0xE0,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x110000) {\r\n        if ((units -= 4) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x12 | 0xF0,\r\n          codePoint >> 0xC & 0x3F | 0x80,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else {\r\n        throw new Error('Invalid code point')\r\n      }\r\n    }\r\n\r\n    return bytes\r\n  }\r\n\r\n  function asciiToBytes (str) {\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      // Node's code seems to be doing this and not & 0x7F..\r\n      byteArray.push(str.charCodeAt(i) & 0xFF)\r\n    }\r\n    return byteArray\r\n  }\r\n\r\n  function utf16leToBytes (str, units) {\r\n    var c, hi, lo\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      if ((units -= 2) < 0) break\r\n\r\n      c = str.charCodeAt(i)\r\n      hi = c >> 8\r\n      lo = c % 256\r\n      byteArray.push(lo)\r\n      byteArray.push(hi)\r\n    }\r\n\r\n    return byteArray\r\n  }\r\n\r\n  function base64ToBytes (str) {\r\n    return base64.toByteArray(base64clean(str))\r\n  }\r\n\r\n  function blitBuffer (src, dst, offset, length) {\r\n    for (var i = 0; i < length; ++i) {\r\n      if ((i + offset >= dst.length) || (i >= src.length)) break\r\n      dst[i + offset] = src[i]\r\n    }\r\n    return i\r\n  }\r\n\r\n  // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\r\n  // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\r\n  function isArrayBuffer (obj) {\r\n    return obj instanceof ArrayBuffer ||\r\n      (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\r\n        typeof obj.byteLength === 'number')\r\n  }\r\n\r\n  function numberIsNaN (obj) {\r\n    return obj !== obj // eslint-disable-line no-self-compare\r\n  }\r\n\r\n  return binary.Buffer = Buffer;\r\n\r\n});\ndefine('skylark-data-files/error-strings',[\r\n  \"./files\",\r\n  \"./error-codes\"\r\n],function (files,ErrorCodes) {\r\n  'use strict';\r\n\r\n  /* tslint:disable:variable-name */\r\n  /**\r\n   * Strings associated with each error code.\r\n   * @hidden\r\n   */\r\n  const ErrorStrings = {};\r\n  ErrorStrings[ErrorCodes.EPERM] = 'Operation not permitted.';\r\n  ErrorStrings[ErrorCodes.ENOENT] = 'No such file or directory.';\r\n  ErrorStrings[ErrorCodes.EIO] = 'Input/output error.';\r\n  ErrorStrings[ErrorCodes.EBADF] = 'Bad file descriptor.';\r\n  ErrorStrings[ErrorCodes.EACCES] = 'Permission denied.';\r\n  ErrorStrings[ErrorCodes.EBUSY] = 'Resource busy or locked.';\r\n  ErrorStrings[ErrorCodes.EEXIST] = 'File exists.';\r\n  ErrorStrings[ErrorCodes.ENOTDIR] = 'File is not a directory.';\r\n  ErrorStrings[ErrorCodes.EISDIR] = 'File is a directory.';\r\n  ErrorStrings[ErrorCodes.EINVAL] = 'Invalid argument.';\r\n  ErrorStrings[ErrorCodes.EFBIG] = 'File is too big.';\r\n  ErrorStrings[ErrorCodes.ENOSPC] = 'No space left on disk.';\r\n  ErrorStrings[ErrorCodes.EROFS] = 'Cannot modify a read-only file system.';\r\n  ErrorStrings[ErrorCodes.ENOTEMPTY] = 'Directory is not empty.';\r\n  ErrorStrings[ErrorCodes.ENOTSUP] = 'Operation is not supported.';\r\n\r\n  return files.ErrorStrings = ErrorStrings;\r\n});\r\n  \ndefine('skylark-data-files/file-error',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    \"./error-strings\"\r\n],function (Buffer,files,ErrorCodes,ErrorStrings) {\r\n   'use strict';\r\n   \r\n\r\n    /* tslint:enable:variable-name */\r\n    /**\r\n     * Represents a BrowserFS error. Passed back to applications after a failed\r\n     * call to the BrowserFS API.\r\n     */\r\n    class FileError extends Error {\r\n        /**\r\n         * Represents a BrowserFS error. Passed back to applications after a failed\r\n         * call to the BrowserFS API.\r\n         *\r\n         * Error codes mirror those returned by regular Unix file operations, which is\r\n         * what Node returns.\r\n         * @constructor FileError\r\n         * @param type The type of the error.\r\n         * @param [message] A descriptive error message.\r\n         */\r\n        constructor(type, message = ErrorStrings[type], path) {\r\n            super(message);\r\n            // Unsupported.\r\n            this.syscall = \"\";\r\n            this.errno = type;\r\n            this.code = ErrorCodes[type];\r\n            this.path = path;\r\n            this.stack = new Error().stack;\r\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\r\n        }\r\n        static fromJSON(json) {\r\n            const err = new FileError(0);\r\n            err.errno = json.errno;\r\n            err.code = json.code;\r\n            err.path = json.path;\r\n            err.stack = json.stack;\r\n            err.message = json.message;\r\n            return err;\r\n        }\r\n        /**\r\n         * Creates an FileError object from a buffer.\r\n         */\r\n        static fromBuffer(buffer, i = 0) {\r\n            return FileError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\r\n        }\r\n        static create(code, p) {\r\n            return new FileError(code, ErrorStrings[code], p);\r\n        }\r\n        static ENOENT(path) {\r\n            return this.create(ErrorCodes.ENOENT, path);\r\n        }\r\n        static EEXIST(path) {\r\n            return this.create(ErrorCodes.EEXIST, path);\r\n        }\r\n        static EISDIR(path) {\r\n            return this.create(ErrorCodes.EISDIR, path);\r\n        }\r\n        static ENOTDIR(path) {\r\n            return this.create(ErrorCodes.ENOTDIR, path);\r\n        }\r\n        static EPERM(path) {\r\n            return this.create(ErrorCodes.EPERM, path);\r\n        }\r\n        static ENOTEMPTY(path) {\r\n            return this.create(ErrorCodes.ENOTEMPTY, path);\r\n        }\r\n        /**\r\n         * @return A friendly error message.\r\n         */\r\n        toString() {\r\n            return this.message;\r\n        }\r\n        toJSON() {\r\n            return {\r\n                errno: this.errno,\r\n                code: this.code,\r\n                path: this.path,\r\n                stack: this.stack,\r\n                message: this.message\r\n            };\r\n        }\r\n        /**\r\n         * Writes the API error into a buffer.\r\n         */\r\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\r\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\r\n            buffer.writeUInt32LE(bytesWritten, i);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * The size of the API error in buffer-form in bytes.\r\n         */\r\n        bufferSize() {\r\n            // 4 bytes for string length.\r\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\r\n        }\r\n    }\r\n\r\n    return files.FileError = FileError;\r\n\r\n});\ndefine('skylark-data-files/base-file',[\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\"\r\n], function (files,ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Base class that contains shared implementations of functions for the file\r\n     * object.\r\n     */\r\n    class BaseFile {\r\n        sync(cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        datasync(cb) {\r\n            this.sync(cb);\r\n        }\r\n        datasyncSync() {\r\n            return this.syncSync();\r\n        }\r\n        chown(uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chmod(mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n    return files.BaseFile = BaseFile;\r\n});\ndefine('skylark-data-files/file-flag',[\r\n  \"./files\",\r\n  './error-codes',\r\n  \"./file-error\",\r\n  \"./action-type\"\r\n], function (files,ErrorCodes,FileError,ActionType) {\r\n    'use strict';\r\n\r\n\r\n\r\n  /**\r\n   * Represents one of the following file flags. A convenience object.\r\n   *\r\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\r\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\r\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\r\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\r\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\r\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\r\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\r\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\r\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\r\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\r\n   *\r\n   * Exclusive mode ensures that the file path is newly created.\r\n   */\r\n  class FileFlag {\r\n      /**\r\n       * This should never be called directly.\r\n       * @param modeStr The string representing the mode\r\n       * @throw when the mode string is invalid\r\n       */\r\n      constructor(flagStr) {\r\n          this.flagStr = flagStr;\r\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\r\n              throw new FileError(ErrorCodes.EINVAL, \"Invalid flag: \" + flagStr);\r\n          }\r\n      }\r\n      /**\r\n       * Get an object representing the given file flag.\r\n       * @param modeStr The string representing the flag\r\n       * @return The FileFlag object representing the flag\r\n       * @throw when the flag string is invalid\r\n       */\r\n      static getFileFlag(flagStr) {\r\n          // Check cache first.\r\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\r\n              return FileFlag.flagCache[flagStr];\r\n          }\r\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\r\n      }\r\n      /**\r\n       * Get the underlying flag string for this flag.\r\n       */\r\n      getFlagString() {\r\n          return this.flagStr;\r\n      }\r\n      /**\r\n       * Returns true if the file is readable.\r\n       */\r\n      isReadable() {\r\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is writeable.\r\n       */\r\n      isWriteable() {\r\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file mode should truncate.\r\n       */\r\n      isTruncating() {\r\n          return this.flagStr.indexOf('w') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is appendable.\r\n       */\r\n      isAppendable() {\r\n          return this.flagStr.indexOf('a') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in synchronous mode.\r\n       */\r\n      isSynchronous() {\r\n          return this.flagStr.indexOf('s') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in exclusive mode.\r\n       */\r\n      isExclusive() {\r\n          return this.flagStr.indexOf('x') !== -1;\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path existing.\r\n       */\r\n      pathExistsAction() {\r\n          if (this.isExclusive()) {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n          else if (this.isTruncating()) {\r\n              return ActionType.TRUNCATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.NOP;\r\n          }\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path not existing.\r\n       */\r\n      pathNotExistsAction() {\r\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\r\n              return ActionType.CREATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n      }\r\n  }\r\n  // Contains cached FileMode instances.\r\n  FileFlag.flagCache = {};\r\n  // Array of valid mode strings.\r\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\r\n\r\n\r\n\r\n  return files.FileFlag = FileFlag;\r\n});\ndefine('skylark-langx-types/types',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n    var nativeIsArray = Array.isArray, \r\n        toString = {}.toString;\r\n    \r\n    var type = (function() {\r\n        var class2type = {};\r\n\r\n        // Populate the class2type map\r\n        \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \").forEach(function(name) {\r\n            class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\r\n        });\r\n\r\n        return function type(obj) {\r\n            return obj == null ? String(obj) :\r\n                class2type[toString.call(obj)] || \"object\";\r\n        };\r\n    })();\r\n\r\n \r\n    var  isArray = nativeIsArray || function(obj) {\r\n        return object && object.constructor === Array;\r\n    };\r\n\r\n\r\n    /**\r\n     * Checks if `value` is array-like. A value is considered array-like if it's\r\n     * not a function/string/element and has a `value.length` that's an integer greater than or\r\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n     *\r\n     * @category Lang\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n     * @example\r\n     *\r\n     * isArrayLike([1, 2, 3])\r\n     * // => true\r\n     *\r\n     * isArrayLike(document.body.children)\r\n     * // => false\r\n     *\r\n     * isArrayLike('abc')\r\n     * // => true\r\n     *\r\n     * isArrayLike(Function)\r\n     * // => false\r\n     */    \r\n    function isArrayLike(obj) {\r\n        return !isString(obj) && !isHtmlNode(obj) && typeof obj.length == 'number' && !isFunction(obj);\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a boolean primitive or object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\r\n     * @example\r\n     *\r\n     * isBoolean(false)\r\n     * // => true\r\n     *\r\n     * isBoolean(null)\r\n     * // => false\r\n     */\r\n    function isBoolean(obj) {\r\n       return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\r\n       //return typeof(obj) === \"boolean\";\r\n    }\r\n\r\n    function isDefined(obj) {\r\n        return typeof obj !== 'undefined';\r\n    }\r\n\r\n    function isDocument(obj) {\r\n        return obj != null && obj.nodeType == obj.DOCUMENT_NODE;\r\n    }\r\n\r\n   // Is a given value a DOM element?\r\n    function isElement(obj) {\r\n        return !!(obj && obj.nodeType === 1);\r\n    }   \r\n\r\n    function isEmptyObject(obj) {\r\n        var name;\r\n        for (name in obj) {\r\n            if (obj[name] !== null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Function` object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n     * @example\r\n     *\r\n     * isFunction(parseInt)\r\n     * // => true\r\n     *\r\n     * isFunction(/abc/)\r\n     * // => false\r\n     */\r\n    function isFunction(value) {\r\n        return type(value) == \"function\";\r\n    }\r\n\r\n\r\n\r\n    function isHtmlNode(obj) {\r\n        return obj && obj.nodeType; // obj instanceof Node; //Consider the elements in IFRAME\r\n    }\r\n\r\n    function isInstanceOf( /*Object*/ value, /*Type*/ type) {\r\n        //Tests whether the value is an instance of a type.\r\n        if (value === undefined) {\r\n            return false;\r\n        } else if (value === null || type == Object) {\r\n            return true;\r\n        } else if (typeof value === \"number\") {\r\n            return type === Number;\r\n        } else if (typeof value === \"string\") {\r\n            return type === String;\r\n        } else if (typeof value === \"boolean\") {\r\n            return type === Boolean;\r\n        } else if (typeof value === \"string\") {\r\n            return type === String;\r\n        } else {\r\n            return (value instanceof type) || (value && value.isInstanceOf ? value.isInstanceOf(type) : false);\r\n        }\r\n    }\r\n\r\n    function isNull(obj) {\r\n        return obj === null;\r\n    }\r\n\r\n    function isNumber(obj) {\r\n        return typeof obj == 'number';\r\n    }\r\n\r\n    function isObject(obj) {\r\n        var type = typeof obj;\r\n        return type === 'function' || type === 'object' && !!obj;        \r\n        //return type(obj) == \"object\";\r\n    }\r\n\r\n    function isPlainObject(obj) {\r\n        return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;\r\n    }\r\n\r\n    function isString(obj) {\r\n        return typeof obj === 'string';\r\n    }\r\n\r\n    function isWindow(obj) {\r\n        return obj && obj == obj.window;\r\n    }\r\n\r\n    function isSameOrigin(href) {\r\n        if (href) {\r\n            var origin = location.protocol + '//' + location.hostname;\r\n            if (location.port) {\r\n                origin += ':' + location.port;\r\n            }\r\n            return href.startsWith(origin);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if `value` is classified as a `Symbol` primitive or object.\r\n     *\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n     * @example\r\n     *\r\n     * _.isSymbol(Symbol.iterator);\r\n     * // => true\r\n     *\r\n     * _.isSymbol('abc');\r\n     * // => false\r\n     */\r\n    function isSymbol(value) {\r\n      return typeof value == 'symbol' ||\r\n        (isObjectLike(value) && objectToString.call(value) == symbolTag);\r\n    }\r\n\r\n    // Is a given variable undefined?\r\n    function isUndefined(obj) {\r\n        return obj === void 0;\r\n    }\r\n\r\n\r\n    var INFINITY = 1 / 0,\r\n        MAX_SAFE_INTEGER = 9007199254740991,\r\n        MAX_INTEGER = 1.7976931348623157e+308,\r\n        NAN = 0 / 0;\r\n\r\n    /** Used to match leading and trailing whitespace. */\r\n    var reTrim = /^\\s+|\\s+$/g;\r\n\r\n    /** Used to detect bad signed hexadecimal string values. */\r\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\r\n\r\n    /** Used to detect binary string values. */\r\n    var reIsBinary = /^0b[01]+$/i;\r\n\r\n    /** Used to detect octal string values. */\r\n    var reIsOctal = /^0o[0-7]+$/i;\r\n\r\n    /** Used to detect unsigned integer values. */\r\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n\r\n    /** Built-in method references without a dependency on `root`. */\r\n    var freeParseInt = parseInt;\r\n\r\n    /**\r\n     * Converts `value` to a finite number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.12.0\r\n     * @category Lang\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted number.\r\n     * @example\r\n     *\r\n     * _.toFinite(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toFinite(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toFinite(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toFinite('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toFinite(value) {\r\n      if (!value) {\r\n        return value === 0 ? value : 0;\r\n      }\r\n      value = toNumber(value);\r\n      if (value === INFINITY || value === -INFINITY) {\r\n        var sign = (value < 0 ? -1 : 1);\r\n        return sign * MAX_INTEGER;\r\n      }\r\n      return value === value ? value : 0;\r\n    }\r\n\r\n    /**\r\n     * Converts `value` to an integer.\r\n     *\r\n     * **Note:** This method is loosely based on\r\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @param {*} value The value to convert.\r\n     * @returns {number} Returns the converted integer.\r\n     * @example\r\n     *\r\n     * _.toInteger(3.2);\r\n     * // => 3\r\n     *\r\n     * _.toInteger(Number.MIN_VALUE);\r\n     * // => 0\r\n     *\r\n     * _.toInteger(Infinity);\r\n     * // => 1.7976931348623157e+308\r\n     *\r\n     * _.toInteger('3.2');\r\n     * // => 3\r\n     */\r\n    function toInteger(value) {\r\n      var result = toFinite(value),\r\n          remainder = result % 1;\r\n\r\n      return result === result ? (remainder ? result - remainder : result) : 0;\r\n    }   \r\n\r\n    /**\r\n     * Converts `value` to a number.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 4.0.0\r\n     * @category Lang\r\n     * @param {*} value The value to process.\r\n     * @returns {number} Returns the number.\r\n     * @example\r\n     *\r\n     * _.toNumber(3.2);\r\n     * // => 3.2\r\n     *\r\n     * _.toNumber(Number.MIN_VALUE);\r\n     * // => 5e-324\r\n     *\r\n     * _.toNumber(Infinity);\r\n     * // => Infinity\r\n     *\r\n     * _.toNumber('3.2');\r\n     * // => 3.2\r\n     */\r\n    function toNumber(value) {\r\n      if (typeof value == 'number') {\r\n        return value;\r\n      }\r\n      if (isSymbol(value)) {\r\n        return NAN;\r\n      }\r\n      if (isObject(value)) {\r\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\r\n        value = isObject(other) ? (other + '') : other;\r\n      }\r\n      if (typeof value != 'string') {\r\n        return value === 0 ? value : +value;\r\n      }\r\n      value = value.replace(reTrim, '');\r\n      var isBinary = reIsBinary.test(value);\r\n      return (isBinary || reIsOctal.test(value))\r\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\r\n        : (reIsBadHex.test(value) ? NAN : +value);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    return skylark.attach(\"langx.types\",{\r\n\r\n        isArray: isArray,\r\n\r\n        isArrayLike: isArrayLike,\r\n\r\n        isBoolean: isBoolean,\r\n\r\n        isDefined: isDefined,\r\n\r\n        isDocument: isDocument,\r\n\r\n        isElement,\r\n\r\n        isEmpty : isEmptyObject,\r\n\r\n        isEmptyObject: isEmptyObject,\r\n\r\n        isFunction: isFunction,\r\n\r\n        isHtmlNode: isHtmlNode,\r\n\r\n        isNaN : function (obj) {\r\n            return isNaN(obj);\r\n        },\r\n\r\n        isNull: isNull,\r\n\r\n\r\n        isNumber: isNumber,\r\n\r\n        isNumeric: isNumber,\r\n\r\n        isObject: isObject,\r\n\r\n        isPlainObject: isPlainObject,\r\n\r\n        isString: isString,\r\n\r\n        isSameOrigin: isSameOrigin,\r\n\r\n        isSymbol : isSymbol,\r\n\r\n        isUndefined: isUndefined,\r\n\r\n        isWindow: isWindow,\r\n\r\n        type: type,\r\n\r\n        toFinite : toFinite,\r\n        toNumber : toNumber,\r\n        toInteger : toInteger\r\n        \r\n    });\r\n\r\n});\ndefine('skylark-langx-types/main',[\r\n\t\"./types\"\r\n],function(types){\r\n\treturn types;\r\n});\ndefine('skylark-langx-types', ['skylark-langx-types/main'], function (main) { return main; });\n\ndefine('skylark-langx-funcs/funcs',[\r\n  \"skylark-langx-ns\",\r\n],function(skylark,types,objects){\r\n        \r\n\r\n\r\n\r\n    function noop() {\r\n    }\r\n\r\n\r\n\r\n\r\n    return skylark.attach(\"langx.funcs\",{\r\n        noop : noop,\r\n\r\n        returnTrue: function() {\r\n            return true;\r\n        },\r\n\r\n        returnFalse: function() {\r\n            return false;\r\n        }\r\n\r\n    });\r\n});\ndefine('skylark-langx-funcs/defer',[\r\n    \"skylark-langx-types\",\r\n    \"./funcs\"\r\n],function(types,funcs){\r\n\r\n    function defer(fn,trigger,args,context) {\r\n        var ret = {\r\n            cancel : null\r\n        },\r\n        fn1 = fn;\r\n\r\n        if (!types.isNumber(trigger) && !types.isFunction(trigger)) {\r\n            context = args;\r\n            args = trigger;\r\n            trigger = 0;\r\n        }\r\n\r\n        if (args) {\r\n            fn1 = function() {\r\n                fn.apply(context,args);\r\n            };\r\n        }\r\n\r\n        if (types.isFunction(trigger)) {\r\n            var canceled = false;\r\n            trigger(function(){\r\n                if (!canceled) {\r\n                    fn1();\r\n                }\r\n            });\r\n\r\n            ret.cancel = function() {\r\n                canceled = true;\r\n            }\r\n\r\n        } else {\r\n            var  id;\r\n            if (trigger == 0 && requestAnimationFrame) {\r\n                id = requestAnimationFrame(fn1);\r\n                ret.cancel = function() {\r\n                    return cancelAnimationFrame(id);\r\n                };\r\n            } else {\r\n                id = setTimeout(fn1,trigger);\r\n                ret.cancel = function() {\r\n                    return clearTimeout(id);\r\n                };\r\n            }            \r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    return funcs.defer = defer;\r\n});\ndefine('skylark-langx-paths/paths',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\tvar splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\r\n\r\n\tfunction posixSplitPath(filename) {\r\n\t    var out = splitPathRe.exec(filename);\r\n\t    out.shift();\r\n\t    return out;\r\n\t}\r\n\t/**\r\n\t * Emulates Node's `path` module. This module contains utilities for handling and\r\n\t * transforming file paths. **All** of these methods perform only string\r\n\t * transformations. The file system is not consulted to check whether paths are\r\n\t * valid.\r\n\t * @see http://nodejs.org/api/path.html\r\n\t * @class\r\n\t */\r\n\tvar paths = {};\r\n\r\n\r\n    /**\r\n     * Unknown. Undocumented.\r\n     */\r\n    paths._makeLong = function (p) {\r\n        return p;\r\n    };\r\n\r\n\r\n    paths._removeDuplicateSeps = function (p) {\r\n        p = p.replace(this._replaceRegex, this.sep);\r\n        return p;\r\n    };\r\n\r\n    // The platform-specific file separator. BrowserFS uses `/`.\r\n    paths.sep = '/';\r\n    paths._replaceRegex = new RegExp(\"//+\", 'g');\r\n    // The platform-specific path delimiter. BrowserFS uses `:`.\r\n    paths.delimiter = ':';\r\n    paths.posix = paths;\r\n    // XXX: Typing hack. We don't actually support win32.\r\n    paths.win32 = paths;\r\n\r\n\r\n\treturn skylark.attach(\"langx.paths\",paths);\r\n});\ndefine('skylark-langx-paths/normalize',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Normalize a string path, taking care of '..' and '.' parts.\r\n     *\r\n     * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.\r\n     * @example Usage example\r\n     *   paths.normalize('/foo/bar//baz/asdf/quux/..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to normalize.\r\n     * @return [String]\r\n     */\r\n     function normalize(p) {\r\n        // Special case: '' -> '.'\r\n        if (p === '') {\r\n            p = '.';\r\n        }\r\n        // It's very important to know if the path is relative or not, since it\r\n        // changes how we process .. and reconstruct the split string.\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        // Remove repeated //s\r\n        p = paths._removeDuplicateSeps(p);\r\n        // Try to remove as many '../' as possible, and remove '.' completely.\r\n        var components = p.split(paths.sep);\r\n        var goodComponents = [];\r\n        for (var idx = 0; idx < components.length; idx++) {\r\n            var c = components[idx];\r\n            if (c === '.') {\r\n                continue;\r\n            }\r\n            else if (c === '..' && (absolute || (!absolute && goodComponents.length > 0 && goodComponents[0] !== '..'))) {\r\n                // In the absolute case: Path is relative to root, so we may pop even if\r\n                // goodComponents is empty (e.g. /../ => /)\r\n                // In the relative case: We're getting rid of a directory that preceded\r\n                // it (e.g. /foo/../bar -> /bar)\r\n                goodComponents.pop();\r\n            }\r\n            else {\r\n                goodComponents.push(c);\r\n            }\r\n        }\r\n        // Add in '.' when it's a relative path with no other nonempty components.\r\n        // Possible results: '.' and './' (input: [''] or [])\r\n        // @todo Can probably simplify this logic.\r\n        if (!absolute && goodComponents.length < 2) {\r\n            switch (goodComponents.length) {\r\n                case 1:\r\n                    if (goodComponents[0] === '') {\r\n                        goodComponents.unshift('.');\r\n                    }\r\n                    break;\r\n                default:\r\n                    goodComponents.push('.');\r\n            }\r\n        }\r\n        p = goodComponents.join(paths.sep);\r\n        if (absolute && p.charAt(0) !== paths.sep) {\r\n            p = paths.sep + p;\r\n        }\r\n        return p;\r\n    }\r\n\r\n    return paths.normalize = normalize;\r\n});\ndefine('skylark-langx-paths/basename',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Return the last portion of a path. Similar to the Unix basename command.\r\n     * @example Usage example\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html')\r\n     *   // returns\r\n     *   'quux.html'\r\n     *\r\n     *   paths.basename('/foo/bar/baz/asdf/quux.html', '.html')\r\n     *   // returns\r\n     *   'quux'\r\n     * @param [String] p\r\n     * @param [String?] ext\r\n     * @return [String]\r\n     */\r\n    function basename(p, ext) {\r\n        if (ext === void 0) { ext = \"\"; }\r\n        // Special case: Normalize will modify this to '.'\r\n        if (p === '') {\r\n            return p;\r\n        }\r\n        // Normalize the string first to remove any weirdness.\r\n        p = normalize(p);\r\n        // Get the last part of the string.\r\n        var sections = p.split(paths.sep);\r\n        var lastPart = sections[sections.length - 1];\r\n        // Special case: If it's empty, then we have a string like so: foo/\r\n        // Meaning, 'foo' is guaranteed to be a directory.\r\n        if (lastPart === '' && sections.length > 1) {\r\n            return sections[sections.length - 2];\r\n        }\r\n        // Remove the extension, if need be.\r\n        if (ext.length > 0) {\r\n            var lastPartExt = lastPart.substr(lastPart.length - ext.length);\r\n            if (lastPartExt === ext) {\r\n                return lastPart.substr(0, lastPart.length - ext.length);\r\n            }\r\n        }\r\n        return lastPart;\r\n    }\r\n\r\n    return paths.basename = basename;\r\n});\ndefine('skylark-langx-paths/dirname',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    /**\r\n     * Return the directory name of a path. Similar to the Unix `dirname` command.\r\n     *\r\n     * Note that BrowserFS does not validate if the path is actually a valid\r\n     * directory.\r\n     * @example Usage example\r\n     *   paths.dirname('/foo/bar/baz/asdf/quux')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     * @param [String] p The path to get the directory name of.\r\n     * @return [String]\r\n     */\r\n    function dirname(p) {\r\n        // We get rid of //, but we don't modify anything else (e.g. any extraneous .\r\n        // and ../ are kept intact)\r\n        p = paths._removeDuplicateSeps(p);\r\n        var absolute = p.charAt(0) === paths.sep;\r\n        var sections = p.split(paths.sep);\r\n        // Do 1 if it's /foo/bar, 2 if it's /foo/bar/\r\n        if (sections.pop() === '' && sections.length > 0) {\r\n            sections.pop();\r\n        }\r\n        // # of sections needs to be > 1 if absolute, since the first section is '' for '/'.\r\n        // If not absolute, the first section is the first part of the path, and is OK\r\n        // to return.\r\n        if (sections.length > 1 || (sections.length === 1 && !absolute)) {\r\n            return sections.join(paths.sep);\r\n        }\r\n        else if (absolute) {\r\n            return paths.sep;\r\n        }\r\n        else {\r\n            return '.';\r\n        }\r\n    }\r\n\r\n    return paths.dirname = dirname;\r\n});\ndefine('skylark-langx-paths/extname',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Return the extension of the path, from the last '.' to end of string in the\r\n     * last portion of the path. If there is no '.' in the last portion of the path\r\n     * or the first character of it is '.', then it returns an empty string.\r\n     * @example Usage example\r\n     *   paths.extname('index.html')\r\n     *   // returns\r\n     *   '.html'\r\n     *\r\n     *   paths.extname('index.')\r\n     *   // returns\r\n     *   '.'\r\n     *\r\n     *   paths.extname('index')\r\n     *   // returns\r\n     *   ''\r\n     * @param [String] p\r\n     * @return [String]\r\n     */\r\n    function extname(p) {\r\n        p = normalize(p);\r\n        var sections = p.split(paths.sep);\r\n        p = sections.pop();\r\n        // Special case: foo/file.ext/ should return '.ext'\r\n        if (p === '' && sections.length > 0) {\r\n            p = sections.pop();\r\n        }\r\n        if (p === '..') {\r\n            return '';\r\n        }\r\n        var i = p.lastIndexOf('.');\r\n        if (i === -1 || i === 0) {\r\n            return '';\r\n        }\r\n        return p.substr(i);\r\n    }\r\n\r\n    return paths.extname = extname;\r\n});\ndefine('skylark-langx-paths/format',[\r\n\t\"./paths\"\r\n],function(paths){\r\n    function format(pathObject) {\r\n        if (pathObject === null || typeof pathObject !== 'object') {\r\n            throw new TypeError(\"Parameter 'pathObject' must be an object, not \" + typeof pathObject);\r\n        }\r\n        var root = pathObject.root || '';\r\n        if (typeof root !== 'string') {\r\n            throw new TypeError(\"'pathObject.root' must be a string or undefined, not \" +\r\n                typeof pathObject.root);\r\n        }\r\n        var dir = pathObject.dir ? pathObject.dir + paths.sep : '';\r\n        var base = pathObject.base || '';\r\n        return dir + base;\r\n    }\r\n\r\n    return paths.format = format;\r\n});\ndefine('skylark-langx-paths/is-absolute',[\r\n\t\"./paths\"\r\n],function(paths){\r\n\r\n    /**\r\n     * Checks if the given path is an absolute path.\r\n     *\r\n     * Despite not being documented, this is a tested part of Node's path API.\r\n     * @param [String] p\r\n     * @return [Boolean] True if the path appears to be an absolute path.\r\n     */\r\n    function isAbsolute(p) {\r\n        return p.length > 0 && p.charAt(0) === paths.sep;\r\n    }\r\n\r\n    return paths.isAbsolute = isAbsolute;\r\n\r\n});\ndefine('skylark-langx-paths/join',[\r\n\t\"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Join all arguments together and normalize the resulting path.\r\n     *\r\n     * Arguments must be strings.\r\n     * @example Usage\r\n     *   paths.join('/foo', 'bar', 'baz/asdf', 'quux', '..')\r\n     *   // returns\r\n     *   '/foo/bar/baz/asdf'\r\n     *\r\n     *   paths.join('foo', {}, 'bar')\r\n     *   // throws exception\r\n     *   TypeError: Arguments to paths.join must be strings\r\n     * @param [String,...] segs Each component of the path\r\n     * @return [String]\r\n     */\r\n    function join() {\r\n        var segs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            segs[_i - 0] = arguments[_i];\r\n        }\r\n        // Required: Prune any non-strings from the path. I also prune empty segments\r\n        // so we can do a simple join of the array.\r\n        var processed = [];\r\n        for (var i = 0; i < segs.length; i++) {\r\n            var segment = segs[i];\r\n            if (typeof segment !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to segs.join: \" + (typeof segment));\r\n            }\r\n            else if (segment !== '') {\r\n                processed.push(segment);\r\n            }\r\n        }\r\n        return normalize(processed.join(paths.sep));\r\n    }\r\n\r\n    return paths.join = join;\r\n});\ndefine('skylark-langx-constructs/constructs',[\r\n  \"skylark-langx-ns\"\r\n],function(skylark){\r\n\r\n    return skylark.attach(\"langx.constructs\",{});\r\n});\ndefine('skylark-langx-constructs/inherit',[\r\n\t\"./constructs\"\r\n],function(constructs){\r\n\r\n    function inherit(ctor,base) {\r\n        ///var f = function() {};\r\n        ///f.prototype = base.prototype;\r\n        ///\r\n        ///ctor.prototype = new f();\r\n\r\n\t    if ((typeof base !== \"function\") && base) {\r\n\t      throw new TypeError(\"Super expression must either be null or a function\");\r\n\t    }\r\n\r\n\t    ctor.prototype = Object.create(base && base.prototype, {\r\n\t      constructor: {\r\n\t        value: ctor,\r\n\t        writable: true,\r\n\t        configurable: true\r\n\t      }\r\n\t    });\r\n\r\n\t    if (base) {\r\n\t    \t//tor.__proto__ = base;\r\n\t    \tObject.setPrototypeOf(ctor, base);\r\n\t    } \r\n    }\r\n\r\n    return constructs.inherit = inherit\r\n});\ndefine('skylark-langx-objects/objects',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-types\"\r\n],function(skylark,types){\r\n    var hasOwnProperty = Object.prototype.hasOwnProperty,\r\n        slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean,\r\n        isFunction = types.isFunction,\r\n        isObject = types.isObject,\r\n        isPlainObject = types.isPlainObject,\r\n        isArray = types.isArray,\r\n        isArrayLike = types.isArrayLike,\r\n        isString = types.isString,\r\n        toInteger = types.toInteger;\r\n\r\n     // An internal function for creating assigner functions.\r\n    function createAssigner(keysFunc, defaults) {\r\n        return function(obj) {\r\n          var length = arguments.length;\r\n          if (defaults) obj = Object(obj);  \r\n          if (length < 2 || obj == null) return obj;\r\n          for (var index = 1; index < length; index++) {\r\n            var source = arguments[index],\r\n                keys = keysFunc(source),\r\n                l = keys.length;\r\n            for (var i = 0; i < l; i++) {\r\n              var key = keys[i];\r\n              if (!defaults || obj[key] === void 0) obj[key] = source[key];\r\n            }\r\n          }\r\n          return obj;\r\n       };\r\n    }\r\n\r\n\r\n    // Retrieve all the property names of an object.\r\n    function allKeys(obj) {\r\n        if (!isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    // Retrieve the names of an object's own properties.\r\n    // Delegates to **ECMAScript 5**'s native `Object.keys`.\r\n    function keys(obj) {\r\n        if (isObject(obj)) return [];\r\n        var keys = [];\r\n        for (var key in obj) if (has(obj, key)) keys.push(key);\r\n        return keys;\r\n    }\r\n\r\n    function has(obj, path) {\r\n        if (!isArray(path)) {\r\n            return obj != null && hasOwnProperty.call(obj, path);\r\n        }\r\n        var length = path.length;\r\n        for (var i = 0; i < length; i++) {\r\n            var key = path[i];\r\n            if (obj == null || !hasOwnProperty.call(obj, key)) {\r\n                return false;\r\n            }\r\n            obj = obj[key];\r\n        }\r\n        return !!length;\r\n    }\r\n\r\n\r\n    // Returns whether an object has a given set of `key:value` pairs.\r\n    function isMatch(object, attrs) {\r\n        var keys = keys(attrs), length = keys.length;\r\n        if (object == null) return !length;\r\n        var obj = Object(object);\r\n        for (var i = 0; i < length; i++) {\r\n          var key = keys[i];\r\n          if (attrs[key] !== obj[key] || !(key in obj)) return false;\r\n        }\r\n        return true;\r\n    }    \r\n\r\n\r\n    function removeItem(items, item) {\r\n        if (isArray(items)) {\r\n            var idx = items.indexOf(item);\r\n            if (idx != -1) {\r\n                items.splice(idx, 1);\r\n            }\r\n        } else if (isPlainObject(items)) {\r\n            for (var key in items) {\r\n                if (items[key] == item) {\r\n                    delete items[key];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n\r\n\r\n    // Retrieve the values of an object's properties.\r\n    function values(obj) {\r\n        var keys = allKeys(obj);\r\n        var length = keys.length;\r\n        var values = Array(length);\r\n        for (var i = 0; i < length; i++) {\r\n            values[i] = obj[keys[i]];\r\n        }\r\n        return values;\r\n    }\r\n\r\n\r\n    return skylark.attach(\"langx.objects\",{\r\n        allKeys: allKeys,\r\n\r\n        attach : skylark.attach,\r\n\r\n        defaults : createAssigner(allKeys, true),\r\n\r\n        has: has,\r\n\r\n        isMatch: isMatch,\r\n\r\n        keys: keys,\r\n\r\n        removeItem: removeItem,\r\n\r\n        values: values\r\n    });\r\n\r\n\r\n});\ndefine('skylark-langx-objects/clone',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n    var isPlainObject = types.isPlainObject,\r\n        isArray = types.isArray;\r\n\r\n    function clone( /*anything*/ src,checkCloneMethod) {\r\n        var copy;\r\n        if (src === undefined || src === null) {\r\n            copy = src;\r\n        } else if (checkCloneMethod && src.clone) {\r\n            copy = src.clone();\r\n        } else if (isArray(src)) {\r\n            copy = [];\r\n            for (var i = 0; i < src.length; i++) {\r\n                copy.push(clone(src[i]));\r\n            }\r\n        } else if (isPlainObject(src)) {\r\n            copy = {};\r\n            for (var key in src) {\r\n                copy[key] = clone(src[key]);\r\n            }\r\n        } else {\r\n            copy = src;\r\n        }\r\n\r\n        return copy;\r\n\r\n    }\r\n\r\n    return objects.clone = clone;\r\n});\ndefine('skylark-langx-objects/each',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    function each(obj, callback,isForEach) {\r\n        var length, key, i, undef, value;\r\n\r\n        if (obj) {\r\n            length = obj.length;\r\n\r\n            if (length === undef) {\r\n                // Loop object items\r\n                for (key in obj) {\r\n                    if (obj.hasOwnProperty(key)) {\r\n                        value = obj[key];\r\n                        if ((isForEach ? callback.call(value, value, key) : callback.call(value, key, value) ) === false) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Loop array items\r\n                for (i = 0; i < length; i++) {\r\n                    value = obj[i];\r\n                    if ((isForEach ? callback.call(value, value, i) : callback.call(value, i, value) )=== false) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return objects.each = each;\r\n});\ndefine('skylark-langx-objects/_mixin',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var isPlainObject = types.isPlainObject;\r\n\r\n    function _mixin(target, source, deep, safe) {\r\n        for (var key in source) {\r\n            //if (!source.hasOwnProperty(key)) {\r\n            //    continue;\r\n            //}\r\n            if (safe && target[key] !== undefined) {\r\n                continue;\r\n            }\r\n            // if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\r\n            //    if (isPlainObject(source[key]) && !isPlainObject(target[key])) {\r\n            if (deep && isPlainObject(source[key])) {\r\n                if (!isPlainObject(target[key])) {\r\n                    target[key] = {};\r\n                }\r\n                //if (isArray(source[key]) && !isArray(target[key])) {\r\n                //    target[key] = [];\r\n                //}\r\n                _mixin(target[key], source[key], deep, safe);\r\n            } else if (source[key] !== undefined) {\r\n                target[key] = source[key]\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    return _mixin;\r\n});\ndefine('skylark-langx-objects/_parse_mixin_args',[\r\n    \"skylark-langx-types\",\r\n    \"./objects\"\r\n],function(types,objects) {\r\n\r\n    var slice = Array.prototype.slice,\r\n        isBoolean = types.isBoolean;\r\n\r\n    function _parseMixinArgs(args) {\r\n        var params = slice.call(arguments, 0),\r\n            target = params.shift(),\r\n            deep = false;\r\n        if (isBoolean(params[params.length - 1])) {\r\n            deep = params.pop();\r\n        }\r\n\r\n        return {\r\n            target: target,\r\n            sources: params,\r\n            deep: deep\r\n        };\r\n    }\r\n    \r\n    return _parseMixinArgs;\r\n});\ndefine('skylark-langx-objects/mixin',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(types,objects,_mixin,_parseMixinArgs) {\r\n\r\n\r\n    function mixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, false);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n\r\n    return objects.mixin = mixin;\r\n\t\r\n});\ndefine('skylark-langx-objects/extend',[\r\n    \"./objects\",\r\n    \"./mixin\"\r\n],function(objects,mixin) {\r\n    var slice = Array.prototype.slice;\r\n\r\n    function extend(target) {\r\n        var deep, args = slice.call(arguments, 1);\r\n        if (typeof target == 'boolean') {\r\n            deep = target\r\n            target = args.shift()\r\n        }\r\n        if (args.length == 0) {\r\n            args = [target];\r\n            target = this;\r\n        }\r\n        args.forEach(function(arg) {\r\n            mixin(target, arg, deep);\r\n        });\r\n        return target;\r\n    }\r\n\r\n    return objects.extend = extend;\r\n});\ndefine('skylark-langx-objects/includes',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    /**\r\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n     * checked for a substring of `value`, otherwise\r\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n     * the offset from the end of `collection`.\r\n     *\r\n     * @static\r\n     * @memberOf _\r\n     * @since 0.1.0\r\n     * @category Collection\r\n     * @param {Array|Object|string} collection The collection to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} [fromIndex=0] The index to search from.\r\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n     * @example\r\n     *\r\n     * _.includes([1, 2, 3], 1);\r\n     * // => true\r\n     *\r\n     * _.includes([1, 2, 3], 1, 2);\r\n     * // => false\r\n     *\r\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n     * // => true\r\n     *\r\n     * _.includes('abcd', 'bc');\r\n     * // => true\r\n     */\r\n    function includes(collection, value, fromIndex, guard) {\r\n      collection = isArrayLike(collection) ? collection : values(collection);\r\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n      var length = collection.length;\r\n      if (fromIndex < 0) {\r\n        fromIndex = nativeMax(length + fromIndex, 0);\r\n      }\r\n      return isString(collection)\r\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n    }\r\n\r\n\r\n\r\n    return objects.includes = includes;\r\n});\ndefine('skylark-langx-objects/is-equal',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n    var isFunction = types.isFunction;\r\n\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    var eq, deepEq;\r\n    var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\r\n\r\n    eq = function(a, b, aStack, bStack) {\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) return a !== 0 || 1 / a === 1 / b;\r\n        // `null` or `undefined` only equal to itself (strict comparison).\r\n        if (a == null || b == null) return false;\r\n        // `NaN`s are equivalent, but non-reflexive.\r\n        if (a !== a) return b !== b;\r\n        // Exhaust primitive checks\r\n        var type = typeof a;\r\n        if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\r\n        return deepEq(a, b, aStack, bStack);\r\n    };\r\n\r\n    // Internal recursive comparison function for `isEqual`.\r\n    deepEq = function(a, b, aStack, bStack) {\r\n        // Unwrap any wrapped objects.\r\n        //if (a instanceof _) a = a._wrapped;\r\n        //if (b instanceof _) b = b._wrapped;\r\n        // Compare `[[Class]]` names.\r\n        var className = toString.call(a);\r\n        if (className !== toString.call(b)) return false;\r\n        switch (className) {\r\n            // Strings, numbers, regular expressions, dates, and booleans are compared by value.\r\n            case '[object RegExp]':\r\n            // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return '' + a === '' + b;\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive.\r\n                // Object(NaN) is equivalent to NaN.\r\n                if (+a !== +a) return +b !== +b;\r\n                // An `egal` comparison is performed for other numeric values.\r\n                return +a === 0 ? 1 / +a === 1 / b : +a === +b;\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a === +b;\r\n            case '[object Symbol]':\r\n                return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\r\n        }\r\n\r\n        var areArrays = className === '[object Array]';\r\n        if (!areArrays) {\r\n            if (typeof a != 'object' || typeof b != 'object') return false;\r\n            // Objects with different constructors are not equivalent, but `Object`s or `Array`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor &&\r\n                               isFunction(bCtor) && bCtor instanceof bCtor)\r\n                          && ('constructor' in a && 'constructor' in b)) {\r\n                return false;\r\n            }\r\n        }\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n\r\n        // Initializing stack of traversed objects.\r\n        // It's done here since we only need them for objects and arrays comparison.\r\n        aStack = aStack || [];\r\n        bStack = bStack || [];\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] === a) return bStack[length] === b;\r\n        }\r\n\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n\r\n        // Recursively compare objects and arrays.\r\n        if (areArrays) {\r\n            // Compare array lengths to determine if a deep comparison is necessary.\r\n            length = a.length;\r\n            if (length !== b.length) return false;\r\n            // Deep compare the contents, ignoring non-numeric properties.\r\n            while (length--) {\r\n                if (!eq(a[length], b[length], aStack, bStack)) return false;\r\n            }\r\n        } else {\r\n            // Deep compare objects.\r\n            var keys = Object.keys(a), key;\r\n            length = keys.length;\r\n            // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n            if (Object.keys(b).length !== length) return false;\r\n            while (length--) {\r\n                // Deep compare each member\r\n                key = keys[length];\r\n                if (!(b[key]!==undefined && eq(a[key], b[key], aStack, bStack))) return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n        return true;\r\n    };\r\n\r\n\r\n   // Perform a deep comparison to check if two objects are equal.\r\n    function isEqual(a, b) {\r\n        return eq(a, b);\r\n    }\r\n\r\n    return objects.isEqual = isEqual;\r\n\t\r\n});\ndefine('skylark-langx-objects/omit',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n   // Return a copy of the object without the blacklisted properties.\r\n    function omit(obj, prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = mixin({},obj);\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                delete result[pn];\r\n            }\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    return objects.omit = omit;\r\n});\ndefine('skylark-langx-objects/pick',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n   // Return a copy of the object only containing the whitelisted properties.\r\n    function pick(obj,prop1,prop2) {\r\n        if (!obj) {\r\n            return null;\r\n        }\r\n        var result = {};\r\n        for(var i=1;i<arguments.length;i++) {\r\n            var pn = arguments[i];\r\n            if (pn in obj) {\r\n                result[pn] = obj[pn];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    return objects.pick = pick;\r\n});\ndefine('skylark-langx-objects/result',[\r\n\t\"skylark-langx-types\",\r\n\t\"./objects\"\r\n],function(types,objects) {\r\n\tvar isArray = types.isArray,\r\n\t\tisFunction = types.isFunction;\r\n\r\n    function result(obj, path, fallback) {\r\n        if (!isArray(path)) {\r\n            path = path.split(\".\");//[path]\r\n        };\r\n        var length = path.length;\r\n        if (!length) {\r\n          return isFunction(fallback) ? fallback.call(obj) : fallback;\r\n        }\r\n        for (var i = 0; i < length; i++) {\r\n          var prop = obj == null ? void 0 : obj[path[i]];\r\n          if (prop === void 0) {\r\n            prop = fallback;\r\n            i = length; // Ensure we don't continue iterating.\r\n          }\r\n          obj = isFunction(prop) ? prop.call(obj) : prop;\r\n        }\r\n\r\n        return obj;\r\n    }\r\n\r\n    return objects.result = result;\r\n\t\r\n});\ndefine('skylark-langx-objects/safe-mixin',[\r\n\t\"./objects\",\r\n  \"./_mixin\",\r\n  \"./_parse_mixin_args\"\r\n],function(objects,_mixin,_parseMixinArgs) {\r\n\r\n    function safeMixin() {\r\n        var args = _parseMixinArgs.apply(this, arguments);\r\n\r\n        args.sources.forEach(function(source) {\r\n            _mixin(args.target, source, args.deep, true);\r\n        });\r\n        return args.target;\r\n    }\r\n\r\n    return objects.safeMixin = safeMixin;\r\n});\ndefine('skylark-langx-objects/scall',[\r\n    \"./objects\"\r\n],function(objects) {\r\n\r\n    function scall(obj,method,arg1,arg2) {\r\n        if (obj && obj[method]) {\r\n            var args = slice.call(arguments, 2);\r\n\r\n            return obj[method].apply(obj,args);\r\n        }\r\n    }\r\n\r\n    return objects.scall = scall;\r\n});\n define('skylark-langx-objects/shadow',[\r\n\t\"./objects\"\r\n],function(objects) {\r\n\r\n    function shadow(obj, prop, value) {\r\n        Object.defineProperty(obj, prop, {\r\n            value,\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: false\r\n        });\r\n        return value;\r\n    }\r\n\r\n    return objects.shadow = shadow;\r\n});\ndefine('skylark-langx-objects/main',[\r\n\t\"./objects\",\r\n\t\"./clone\",\r\n\t\"./each\",\r\n\t\"./extend\",\r\n\t\"./includes\",\r\n\t\"./is-equal\",\r\n\t\"./mixin\",\r\n\t\"./omit\",\r\n\t\"./pick\",\r\n\t\"./result\",\r\n\t\"./safe-mixin\",\r\n\t\"./scall\",\r\n\t\"./shadow\"\r\n],function(objects){\r\n\treturn objects;\r\n});\ndefine('skylark-langx-objects', ['skylark-langx-objects/main'], function (main) { return main; });\n\ndefine('skylark-langx-arrays/arrays',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\"\r\n],function(skylark,types,objects){\r\n    var filter = Array.prototype.filter,\r\n        find = Array.prototype.find,\r\n        isArrayLike = types.isArrayLike;\r\n\r\n    /**\r\n     * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n     * support for iteratee shorthands.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {Function} predicate The function invoked per iteration.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @param {boolean} [fromRight] Specify iterating from right to left.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n      var length = array.length,\r\n          index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n      while ((fromRight ? index-- : ++index < length)) {\r\n        if (predicate(array[index], index, array)) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n     *\r\n     * @param {Array} array The array to inspect.\r\n     * @param {*} value The value to search for.\r\n     * @param {number} fromIndex The index to search from.\r\n     * @returns {number} Returns the index of the matched value, else `-1`.\r\n     */\r\n    function baseIndexOf(array, value, fromIndex) {\r\n      if (value !== value) {\r\n        return baseFindIndex(array, baseIsNaN, fromIndex);\r\n      }\r\n      var index = fromIndex - 1,\r\n          length = array.length;\r\n\r\n      while (++index < length) {\r\n        if (array[index] === value) {\r\n          return index;\r\n        }\r\n      }\r\n      return -1;\r\n    }\r\n\r\n    /**\r\n     * The base implementation of `isNaN` without support for number objects.\r\n     *\r\n     * @private\r\n     * @param {*} value The value to check.\r\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n     */\r\n    function baseIsNaN(value) {\r\n      return value !== value;\r\n    }\r\n\r\n\r\n    function compact(array) {\r\n        return filter.call(array, function(item) {\r\n            return item != null;\r\n        });\r\n    }\r\n\r\n    function filter2(array,func) {\r\n      return filter.call(array,func);\r\n    }\r\n\r\n    function flatten(array) {\r\n        if (isArrayLike(array)) {\r\n            var result = [];\r\n            for (var i = 0; i < array.length; i++) {\r\n                var item = array[i];\r\n                if (isArrayLike(item)) {\r\n                    for (var j = 0; j < item.length; j++) {\r\n                        result.push(item[j]);\r\n                    }\r\n                } else {\r\n                    result.push(item);\r\n                }\r\n            }\r\n            return result;\r\n        } else {\r\n            return array;\r\n        }\r\n        //return array.length > 0 ? concat.apply([], array) : array;\r\n    }\r\n\r\n    function grep(array, callback) {\r\n        var out = [];\r\n\r\n        objects.each(array, function(i, item) {\r\n            if (callback(item, i)) {\r\n                out.push(item);\r\n            }\r\n        });\r\n\r\n        return out;\r\n    }\r\n\r\n    function inArray(item, array) {\r\n        if (!array) {\r\n            return -1;\r\n        }\r\n        var i;\r\n\r\n        if (array.indexOf) {\r\n            return array.indexOf(item);\r\n        }\r\n\r\n        i = array.length;\r\n        while (i--) {\r\n            if (array[i] === item) {\r\n                return i;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function indexOf(array,item) {\r\n      return array.indexOf(item);\r\n    }\r\n\r\n    function makeArray(obj, offset, startWith) {\r\n       if (isArrayLike(obj) ) {\r\n        return (startWith || []).concat(Array.prototype.slice.call(obj, offset || 0));\r\n      }\r\n\r\n      // array of single index\r\n      return [ obj ];             \r\n    }\r\n\r\n\r\n    function forEach (arr, fn) {\r\n      if (arr.forEach) return arr.forEach(fn)\r\n      for (var i = 0; i < arr.length; i++) fn(arr[i], i);\r\n    }\r\n\r\n    function last(arr) {\r\n        return arr[arr.length - 1];     \r\n    }\r\n\r\n    function map(elements, callback) {\r\n        var value, values = [],\r\n            i, key\r\n        if (isArrayLike(elements))\r\n            for (i = 0; i < elements.length; i++) {\r\n                value = callback.call(elements[i], elements[i], i);\r\n                if (value != null) values.push(value)\r\n            }\r\n        else\r\n            for (key in elements) {\r\n                value = callback.call(elements[key], elements[key], key);\r\n                if (value != null) values.push(value)\r\n            }\r\n        return flatten(values)\r\n    }\r\n\r\n\r\n    function merge( first, second ) {\r\n      var l = second.length,\r\n          i = first.length,\r\n          j = 0;\r\n\r\n      if ( typeof l === \"number\" ) {\r\n        for ( ; j < l; j++ ) {\r\n          first[ i++ ] = second[ j ];\r\n        }\r\n      } else {\r\n        while ( second[j] !== undefined ) {\r\n          first[ i++ ] = second[ j++ ];\r\n        }\r\n      }\r\n\r\n      first.length = i;\r\n\r\n      return first;\r\n    }\r\n\r\n    function reduce(array,callback,initialValue) {\r\n        return Array.prototype.reduce.call(array,callback,initialValue);\r\n    }\r\n\r\n    function uniq(array) {\r\n        return filter.call(array, function(item, idx) {\r\n            return array.indexOf(item) == idx;\r\n        })\r\n    }\r\n\r\n    function find2(array,func) {\r\n      return find.call(array,func);\r\n    }\r\n\r\n    return skylark.attach(\"langx.arrays\",{\r\n        baseFindIndex: baseFindIndex,\r\n\r\n        baseIndexOf : baseIndexOf,\r\n        \r\n        compact: compact,\r\n\r\n        first : function(items,n) {\r\n            if (n) {\r\n                return items.slice(0,n);\r\n            } else {\r\n                return items[0];\r\n            }\r\n        },\r\n\r\n        filter : filter2,\r\n\r\n        find : find2,\r\n        \r\n        flatten: flatten,\r\n\r\n        grep: grep,\r\n\r\n        inArray: inArray,\r\n\r\n        indexOf : indexOf,\r\n\r\n        makeArray: makeArray, // \r\n\r\n        toArray : makeArray,\r\n\r\n        last : last,\r\n\r\n        merge : merge,\r\n\r\n        forEach : forEach,\r\n\r\n        map : map,\r\n        \r\n        reduce : reduce,\r\n\r\n        uniq : uniq\r\n\r\n    });\r\n});\ndefine('skylark-langx-arrays/main',[\r\n\t\"./arrays\"\r\n],function(arrays){\r\n\treturn arrays;\r\n});\ndefine('skylark-langx-arrays', ['skylark-langx-arrays/main'], function (main) { return main; });\n\ndefine('skylark-langx-constructs/klass',[\r\n  \"skylark-langx-ns\",\r\n  \"skylark-langx-types\",\r\n  \"skylark-langx-objects\",\r\n  \"skylark-langx-arrays\",\r\n  \"./constructs\",\r\n  \"./inherit\"\r\n],function(skylark,types,objects,arrays,constructs,inherit){\r\n    var uniq = arrays.uniq,\r\n        has = objects.has,\r\n        mixin = objects.mixin,\r\n        isArray = types.isArray,\r\n        isDefined = types.isDefined;\r\n\r\n/* for reference \r\n function klass(props,parent) {\r\n    var ctor = function(){\r\n        this._construct();\r\n    };\r\n    ctor.prototype = props;\r\n    if (parent) {\r\n        ctor._proto_ = parent;\r\n        props.__proto__ = parent.prototype;\r\n    }\r\n    return ctor;\r\n}\r\n\r\n// Type some JavaScript code here.\r\nlet animal = klass({\r\n  _construct(){\r\n      this.name = this.name + \",hi\";\r\n  },\r\n    \r\n  name: \"Animal\",\r\n  eat() {         // [[HomeObject]] == animal\r\n    alert(`${this.name} eats.`);\r\n  }\r\n    \r\n    \r\n});\r\n\r\n\r\nlet rabbit = klass({\r\n  name: \"Rabbit\",\r\n  _construct(){\r\n      super._construct();\r\n  },\r\n  eat() {         // [[HomeObject]] == rabbit\r\n    super.eat();\r\n  }\r\n},animal);\r\n\r\nlet longEar = klass({\r\n  name: \"Long Ear\",\r\n  eat() {         // [[HomeObject]] == longEar\r\n    super.eat();\r\n  }\r\n},rabbit);\r\n*/\r\n    \r\n\r\n\r\n    var f1 = function() {\r\n        function extendClass(ctor, props, options) {\r\n            // Copy the properties to the prototype of the class.\r\n            var proto = ctor.prototype,\r\n                _super = ctor.superclass.prototype,\r\n                noOverrided = options && options.noOverrided,\r\n                overrides = options && options.overrides || {};\r\n\r\n            for (var name in props) {\r\n                if (name === \"constructor\") {\r\n                    continue;\r\n                }\r\n\r\n                // Check if we're overwriting an existing function\r\n                var prop = props[name];\r\n                if (typeof props[name] == \"function\") {\r\n                    proto[name] =  !prop._constructor && !noOverrided && typeof _super[name] == \"function\" ?\r\n                          (function(name, fn, superFn) {\r\n                            return function() {\r\n                                var tmp = this.overrided;\r\n\r\n                                // Add a new ._super() method that is the same method\r\n                                // but on the super-class\r\n                                this.overrided = superFn;\r\n\r\n                                // The method only need to be bound temporarily, so we\r\n                                // remove it when we're done executing\r\n                                var ret = fn.apply(this, arguments);\r\n\r\n                                this.overrided = tmp;\r\n\r\n                                return ret;\r\n                            };\r\n                        })(name, prop, _super[name]) :\r\n                        prop;\r\n                } else if (types.isPlainObject(prop) && prop!==null && (prop.get)) {\r\n                    Object.defineProperty(proto,name,prop);\r\n                } else {\r\n                    proto[name] = prop;\r\n                }\r\n            }\r\n            return ctor;\r\n        }\r\n\r\n        function serialMixins(ctor,mixins) {\r\n            var result = [];\r\n\r\n            mixins.forEach(function(mixin){\r\n                if (has(mixin,\"__mixins__\")) {\r\n                     throw new Error(\"nested mixins\");\r\n                }\r\n                var clss = [];\r\n                while (mixin) {\r\n                    clss.unshift(mixin);\r\n                    mixin = mixin.superclass;\r\n                }\r\n                result = result.concat(clss);\r\n            });\r\n\r\n            result = uniq(result);\r\n\r\n            result = result.filter(function(mixin){\r\n                var cls = ctor;\r\n                while (cls) {\r\n                    if (mixin === cls) {\r\n                        return false;\r\n                    }\r\n                    if (has(cls,\"__mixins__\")) {\r\n                        var clsMixines = cls[\"__mixins__\"];\r\n                        for (var i=0; i<clsMixines.length;i++) {\r\n                            if (clsMixines[i]===mixin) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                    cls = cls.superclass;\r\n                }\r\n                return true;\r\n            });\r\n\r\n            if (result.length>0) {\r\n                return result;\r\n            } else {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        function mergeMixins(ctor,mixins) {\r\n            var newCtor =ctor;\r\n            for (var i=0;i<mixins.length;i++) {\r\n                var xtor = new Function();\r\n\r\n                inherit(xtor,newCtor)\r\n                //xtor.prototype = Object.create(newCtor.prototype);\r\n                //xtor.__proto__ = newCtor;\r\n                xtor.superclass = null;\r\n                mixin(xtor.prototype,mixins[i].prototype);\r\n                xtor.prototype.__mixin__ = mixins[i];\r\n                newCtor = xtor;\r\n            }\r\n\r\n            return newCtor;\r\n        }\r\n\r\n        function _constructor ()  {\r\n            if (this._construct) {\r\n                return this._construct.apply(this, arguments);\r\n            } else  if (this.init) {\r\n                return this.init.apply(this, arguments);\r\n            }\r\n        }\r\n\r\n        return function createClass(props, parent, mixins,options) {\r\n            if (isArray(parent)) {\r\n                options = mixins;\r\n                mixins = parent;\r\n                parent = null;\r\n            }\r\n            parent = parent || Object;\r\n\r\n            if (isDefined(mixins) && !isArray(mixins)) {\r\n                options = mixins;\r\n                mixins = false;\r\n            }\r\n\r\n            var innerParent = parent;\r\n\r\n            if (mixins) {\r\n                mixins = serialMixins(innerParent,mixins);\r\n            }\r\n\r\n            if (mixins) {\r\n                innerParent = mergeMixins(innerParent,mixins);\r\n            }\r\n\r\n            var klassName = props.klassName || \"\",\r\n                ctor = new Function(\r\n                    \"return function \" + klassName + \"() {\" +\r\n                    \"var inst = this,\" +\r\n                    \" ctor = arguments.callee;\" +\r\n                    \"if (!(inst instanceof ctor)) {\" +\r\n                    \"inst = Object.create(ctor.prototype);\" +\r\n                    \"}\" +\r\n                    \"return ctor._constructor.apply(inst, arguments) || inst;\" + \r\n                    \"}\"\r\n                )();\r\n\r\n\r\n            // Populate our constructed prototype object\r\n            ///ctor.prototype = Object.create(innerParent.prototype);\r\n\r\n            // Enforce the constructor to be what we expect\r\n            ///ctor.prototype.constructor = ctor;\r\n  \r\n            // And make this class extendable\r\n            ///ctor.__proto__ = innerParent;\r\n\r\n            inherit(ctor,innerParent);\r\n\r\n            ctor.superclass = parent;\r\n\r\n            if (!ctor._constructor) {\r\n                ctor._constructor = _constructor;\r\n            } \r\n\r\n            if (mixins) {\r\n                ctor.__mixins__ = mixins;\r\n            }\r\n\r\n            if (!ctor.partial) {\r\n                ctor.partial = function(props, options) {\r\n                    return extendClass(this, props, options);\r\n                };\r\n            }\r\n            if (!ctor.inherit) {\r\n                ctor.inherit = function(props, mixins,options) {\r\n                    return createClass(props, this, mixins,options);\r\n                };\r\n            }\r\n\r\n            ctor.partial(props, options);\r\n\r\n            return ctor;\r\n        };\r\n    }\r\n\r\n    var createClass = f1();\r\n\r\n    return constructs.klass = createClass;\r\n});\ndefine('skylark-langx-constructs/main',[\r\n\t\"./constructs\",\r\n\t\"./inherit\",\r\n\t\"./klass\"\r\n],function(constructs){\r\n\treturn constructs;\r\n});\ndefine('skylark-langx-constructs', ['skylark-langx-constructs/main'], function (main) { return main; });\n\ndefine('skylark-langx-paths/path',[\r\n    \"skylark-langx-types\",\r\n    \"skylark-langx-constructs\",\r\n    \"./paths\"\r\n], function(types,constructs,paths) {\r\n\r\n    /**\r\n     * @class Path\r\n     * @constructor\r\n     */\r\n    var Path =   constructs.klass({\r\n        _construct : function() {\r\n            var _ = this._ = {\r\n                segments : null,\r\n                hasLeading : false,\r\n                hasTrailing : false\r\n            };\r\n            if (arguments.length == 1 && types.isString(arguments[0])) {\r\n                  this._parse(arguments[0]);\r\n            } else  if (types.isArray(arguments[0])){\r\n                _.segments = arguments[0];\r\n                _.hasLeading = arguments[1] || false;\r\n                _.hasTrailing = arguments[2] || false;\r\n                this._canonicalize();                \r\n            }\r\n        },\r\n\r\n        _canonicalize: function() {\r\n            var doIt;\r\n            var segments = this._.segments;\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (segments[i] == \".\" || segments[i] == \"..\") {\r\n                    doIt = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (doIt) {\r\n                var stack = [];\r\n                for (var i = 0; i < segments.length; i++) {\r\n                    if (segments[i] == \"..\") {\r\n                        if (stack.length == 0) {\r\n                            // if the stack is empty we are going out of our scope\r\n                            // so we need to accumulate segments.  But only if the original\r\n                            // path is relative.  If it is absolute then we can't go any higher than\r\n                            // root so simply toss the .. references.\r\n                            if (!this.hasLeading) {\r\n                                stack.push(segments[i]); //stack push\r\n                            }\r\n                        } else {\r\n                            // if the top is '..' then we are accumulating segments so don't pop\r\n                            if (\"..\" == stack[stack.length - 1]) {\r\n                                stack.push(\"..\");\r\n                            } else {\r\n                                stack.pop();\r\n                            }\r\n                        }\r\n                        //collapse current references\r\n                    } else if (segments[i] != \".\" || segments.length == 1) {\r\n                        stack.push(segments[i]); //stack push\r\n                    }\r\n                }\r\n                //if the number of segments hasn't changed, then no modification needed\r\n                if (stack.length == segments.length) {\r\n                    return;\r\n                }\r\n                this._.segments = stack;\r\n            }\r\n        },\r\n\r\n        _length: function(anotherPath) {\r\n            return this._.segments.length;\r\n        },\r\n\r\n\r\n        _parse : function( /*String*/ path) {\r\n            if (!path) {\r\n                path = \".\";\r\n            }\r\n            var _ = this._,\r\n                segments = path.split(\"/\");\r\n\r\n            if (path.charAt(0) == \"/\") {\r\n                _.hasLeading = true;\r\n                segments.shift();\r\n            }\r\n            if (path.charAt(path.length - 1) == \"/\") {\r\n                _.hasTrailing = true;\r\n                // If the path ends in '/', split() will create an array whose last element\r\n                // is an empty string. Remove that here.\r\n                segments.pop();\r\n            }\r\n            _.segments = segments;\r\n            _.path = path;\r\n\r\n            this._canonicalize()\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method append\r\n         *@parameter {Path|String}tail\r\n         *@return {Path}\r\n         */\r\n        append: /*Path*/ function( /*Path*/ tail) {\r\n            if (types.isString(tail)) {\r\n                return this.appendPathStr(tail);\r\n            } else {\r\n                return this.appendPath(tail);\r\n            }\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPath\r\n         *@parameter {Path}tail\r\n         *@return {Path}\r\n         */\r\n        appendPath: /*Path*/ function( /*Path*/ tail) {\r\n            if (tail.isAbsolute()) {\r\n                return tail;\r\n            }\r\n            var mySegments = this.segments,\r\n                tailSegments = tail.segments,\r\n                newSegments = mySegments.concat(tailSegments),\r\n                result = new Path(newSegments, this.hasLeading, tail.hasTrailing);\r\n            return result;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method appendPathStr\r\n         *@parameter {String}tail\r\n         *@return {Path}\r\n         */\r\n        appendPathStr: function( /*String*/ tail) {\r\n            tail = new Path(tail || \"\");\r\n            return this.appendPath(tail);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method clone\r\n         *@return {Path}\r\n         */\r\n        \"clone\": function() {\r\n            return new Path(this.segments, this.hasLeading, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *Tests if this path ends with the given path.\r\n         *@method endsWidth\r\n         *@parameter {String}tail\r\n         *@return {Boolean}\r\n         */\r\n        \"endsWith\": /*Boolean*/ function( /*String*/ tail) {\r\n            var segments = this.segments;\r\n            var tailSegments = (new Path(tail)).segments;\r\n            while (tailSegments.length > 0 && segments.length > 0) {\r\n                if (tailSegments.pop() != segments.pop()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *Tests this path for equality with the given object.\r\n         *@method equals\r\n         *@parameter {Path}another\r\n         *@return {Boolean}\r\n         */\r\n        \"equals\": /*Boolean*/ function( /*Path*/ another) {\r\n            var segments = this._.segments,\r\n                anotherSegments = another._.segments;\r\n            if (segments.length != anotherSegments.length) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (anotherSegments[i] != segments[i]) {\r\n                    return false;\r\n                };\r\n            }\r\n            return true;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method firstSegment\r\n         *@parameter {Number}length\r\n         *@return {String}\r\n         */\r\n        firstSegment: /*String*/ function( /*Number*/ length) {\r\n            var segments = this._.segments;\r\n            return segments[length || 0];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getExtension\r\n         *@return {String}\r\n         */\r\n        getExtension: function() {\r\n            var extension = this._.extension,\r\n                path = this._.path;\r\n            if (!textension) {\r\n                extension = this._.extension = path.substr(path.lastIndexOf('.') + 1);\r\n            }\r\n            return extension;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method getSegments\r\n         *@return {Array}\r\n         */\r\n        getSegments: /*Array*/ function() {\r\n            return this.segments;\r\n        },\r\n\r\n        /*\r\n         *Returns the parent path, or null if this path does not have a parent.\r\n         *@method getParentPath\r\n         *@return {Path}\r\n         */\r\n        getParentPath: /*Path*/ function() {\r\n            var parentPath = this._.parentPath;\r\n            if (!parentPath) {\r\n                var parentSegments = this.segments;\r\n                parentSegments.pop();\r\n                parentPath = this._.parentPath = new Path(parentSegments, this.hasLeading);\r\n            }\r\n            return parentPath;\r\n        },\r\n\r\n\r\n        /*\r\n         *Returns the root component of this path as a Path object, or null if this path does not have a root component.\r\n         *@method getRoot\r\n         *@return {Path}\r\n         */\r\n        \"getRoot\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n        /*\r\n         *Tells whether or not this path is absolute.\r\n         *@method isAbsolute\r\n         *@return {Boolean}\r\n         */\r\n        isAbsolute: /*Boolean*/ function() {\r\n            return this.hasLeading;\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method lastSegment\r\n         *@ return {String}\r\n         */\r\n        lastSegment: /*String*/ function() {\r\n            var segments = this._.segments;\r\n            return segments[segments.length - 1];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method matchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Number}\r\n         */\r\n        matchingFirstSegments: /*Number*/ function( /*Path*/ another) {\r\n            var mySegments = this.segments;\r\n            var pathSegments = another.segments;\r\n            var max = Math.min(mySegments.length, pathSegments.length);\r\n            var count = 0;\r\n            for (var i = 0; i < max; i++) {\r\n                if (mySegments[i] != pathSegments[i]) {\r\n                    return count;\r\n                }\r\n                count++;\r\n            }\r\n            return count;\r\n        },\r\n\r\n        /*\r\n         *Returns a path that is this path with redundant name elements eliminated.\r\n         *@method normalize\r\n         *@return {Path}\r\n         */\r\n        \"normalize\": /*Path*/ function() {\r\n            //TODO: will be implemented\r\n        },\r\n\r\n\r\n        /*\r\n         *\r\n         *@method removeFirstSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeFirstSegments: /*Path*/ function( /*Number*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            return new Path(segments.slice(count, segments.length), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeLastSegments\r\n         *@parameter {Number}count\r\n         *@return {Path}\r\n         */\r\n        removeLastSegments: /*Path*/ function( /*Number?*/ count) {\r\n            var segments = this._.segments,\r\n                hasLeading = this._.hasLeading;\r\n            hasTrailing = this._.hasTrailing;\r\n\r\n            if (!count) {\r\n                count = 1;\r\n            }\r\n\r\n            return new Path(segments.slice(0, segments.length - count), hasLeading, hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingFirstSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingFirstSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(another);\r\n            return this.removeFirstSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeMatchingLastSegments\r\n         *@parameter {Path}another\r\n         *@return {Path}\r\n         */\r\n        removeMatchingLastSegments: /*Path*/ function( /*Path*/ another) {\r\n            var match = this.matchingFirstSegments(anotherPath);\r\n            return this.removeLastSegments(match);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method removeRelative\r\n         *@return {Path}\r\n         */\r\n        removeRelative: function() {\r\n            var segs = this.segments;\r\n            if (segs.length > 0 && segs[1] == \".\")\r\n                return this.removeFirstSegments(1);\r\n            return this;\r\n        },\r\n\r\n        /*\r\n         *Constructs a relative path between this path and a given path.\r\n         *@method relativeTo\r\n         *@parameter {Path}base\r\n         *@return {Path}\r\n         */\r\n        relativeTo: /*Path*/ function( /*Path|String*/ base, /*Boolean*/ ignoreFilename) {\r\n            if (typeof base == 'string') {\r\n                base = new Path(base);\r\n            }\r\n            var mySegments = this.segments;\r\n            if (this.isAbsolute()) {\r\n                return this;\r\n            }\r\n            var baseSegments = base.segments;\r\n            var commonLength = this.matchingFirstSegments(base);\r\n            var baseSegmentLength = baseSegments.length;\r\n            if (ignoreFilename) {\r\n                baseSegmentLength = baseSegmentLength - 1;\r\n            }\r\n            var differenceLength = baseSegmentLength - commonLength;\r\n            var newSegmentLength = differenceLength + mySegments.length - commonLength;\r\n            if (newSegmentLength == 0) {\r\n                return Path.EMPTY;\r\n            }\r\n            var newSegments = [];\r\n            for (var i = 0; i < differenceLength; i++) {\r\n                newSegments.push('..');\r\n            }\r\n            for (var i = commonLength; i < mySegments.length; i++) {\r\n                newSegments.push(mySegments[i]);\r\n            }\r\n            return new Path(newSegments, false, this.hasTrailing);\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method segment\r\n         *@parameter {Number}index\r\n         *@return {String}\r\n         */\r\n        segment: /*String*/ function( /*Number*/ index) {\r\n            var segments = this._.segments;\r\n            if (segments.length < index) return null;\r\n            return segments[index];\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method startsWith\r\n         *@parameter {Path}index\r\n         *@return {Boolean}\r\n         */\r\n        startsWith: /*Boolean*/ function( /*Path*/ another) {\r\n            var count = this.matchingFirstSegments(another);\r\n            return another._length() == count;\r\n        },\r\n\r\n        /*\r\n         *\r\n         *@method toString\r\n         *@return {String}\r\n         */\r\n        toString: function() {\r\n            var result = [],\r\n                segments = this._.segments;\r\n            if (this.hasLeading) {\r\n                result.push(\"/\");\r\n            }\r\n            for (var i = 0; i < segments.length; i++) {\r\n                if (i > 0) {\r\n                    result.push(\"/\");\r\n                }\r\n                result.push(segments[i]);\r\n            }\r\n            if (this.hasTrailing) {\r\n                result.push(\"/\");\r\n            }\r\n            return result.join(\"\");\r\n        },\r\n\r\n        hasLeading : {\r\n            get : function() {\r\n                return this._.hasLeading\r\n            }\r\n        },\r\n\r\n        hasTrailing : {\r\n            get : function() {\r\n                return this._.hasTrailing\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n\r\n    Path.EMPTY = new Path(\"\");\r\n\r\n    return paths.Path = Path;\r\n});\r\n\ndefine('skylark-langx-paths/resolve',[\r\n    \"./paths\",\r\n    \"./normalize\"\r\n],function(paths,normalize){\r\n    /**\r\n     * Resolves to to an absolute path.\r\n     *\r\n     * If to isn't already absolute from arguments are prepended in right to left\r\n     * order, until an absolute path is found. If after using all from paths still\r\n     * no absolute path is found, the current working directory is used as well.\r\n     * The resulting path is normalized, and trailing slashes are removed unless\r\n     * the path gets resolved to the root directory. Non-string arguments are\r\n     * ignored.\r\n     *\r\n     * Another way to think of it is as a sequence of cd commands in a shell.\r\n     *\r\n     *     paths.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile')\r\n     *\r\n     * Is similar to:\r\n     *\r\n     *     cd foo/bar\r\n     *     cd /tmp/file/\r\n     *     cd ..\r\n     *     cd a/../subfile\r\n     *     pwd\r\n     *\r\n     * The difference is that the different paths don't need to exist and may also\r\n     * be files.\r\n     * @example Usage example\r\n     *   paths.resolve('/foo/bar', './baz')\r\n     *   // returns\r\n     *   '/foo/bar/baz'\r\n     *\r\n     *   paths.resolve('/foo/bar', '/tmp/file/')\r\n     *   // returns\r\n     *   '/tmp/file'\r\n     *\r\n     *   paths.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')\r\n     *   // if currently in /home/myself/node, it returns\r\n     *   '/home/myself/node/wwwroot/static_files/gif/image.gif'\r\n     * @param [String,...] segs\r\n     * @return [String]\r\n     */\r\n    function resolve() {\r\n        var segs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            segs[_i - 0] = arguments[_i];\r\n        }\r\n        // Monitor for invalid segs, throw out empty segs, and look for the *last*\r\n        // absolute path that we see.\r\n        var processed = [];\r\n        for (var i = 0; i < segs.length; i++) {\r\n            var p = segs[i];\r\n            if (typeof p !== 'string') {\r\n                throw new TypeError(\"Invalid argument type to paths.join: \" + (typeof p));\r\n            }\r\n            else if (p !== '') {\r\n                // Remove anything that has occurred before this absolute path, as it\r\n                // doesn't matter.\r\n                if (p.charAt(0) === paths.sep) {\r\n                    processed = [];\r\n                }\r\n                processed.push(p);\r\n            }\r\n        }\r\n        // Special: Remove trailing slash unless it's the root\r\n        var resolved = normalize(processed.join(paths.sep));\r\n        if (resolved.length > 1 && resolved.charAt(resolved.length - 1) === paths.sep) {\r\n            return resolved.substr(0, resolved.length - 1);\r\n        }\r\n        /*\r\n        /// \r\n        // Special: If it doesn't start with '/', it's relative and we need to append\r\n        // the current directory.\r\n        if (resolved.charAt(0) !== paths.sep) {\r\n            // Remove ./, since we're going to append the current directory.\r\n            if (resolved.charAt(0) === '.' && (resolved.length === 1 || resolved.charAt(1) === paths.sep)) {\r\n                resolved = resolved.length === 1 ? '' : resolved.substr(2);\r\n            }\r\n            // Append the current directory, which *must* be an absolute path.\r\n            var cwd = process.cwd();\r\n            if (resolved !== '') {\r\n                // cwd will never end in a /... unless it's the root.\r\n                resolved = normalize(cwd + (cwd !== '/' ? paths.sep : '') + resolved);\r\n            }\r\n            else {\r\n                resolved = cwd;\r\n            }\r\n        }\r\n        */\r\n        return resolved;\r\n    }\r\n\r\n    return paths.resolve = resolve;\r\n});\ndefine('skylark-langx-paths/relative',[\r\n\t\"./paths\",\r\n\t\"./resolve\"\r\n],function(paths,resolve){\r\n\r\n    /**\r\n     * Solve the relative path from from to to.\r\n     *\r\n     * At times we have two absolute paths, and we need to derive the relative path\r\n     * from one to the other. This is actually the reverse transform of\r\n     * paths.resolve, which means we see that:\r\n     *\r\n     *    paths.resolve(from, paths.relative(from, to)) == paths.resolve(to)\r\n     *\r\n     * @example Usage example\r\n     *   paths.relative('C:\\\\orandea\\\\test\\\\aaa', 'C:\\\\orandea\\\\impl\\\\bbb')\r\n     *   // returns\r\n     *   '..\\\\..\\\\impl\\\\bbb'\r\n     *\r\n     *   paths.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')\r\n     *   // returns\r\n     *   '../../impl/bbb'\r\n     * @param [String] from\r\n     * @param [String] to\r\n     * @return [String]\r\n     */\r\n    function relative(from, to) {\r\n        var i;\r\n        // Alright. Let's resolve these two to absolute paths and remove any\r\n        // weirdness.\r\n        from = resolve(from);\r\n        to = resolve(to);\r\n        var fromSegs = from.split(paths.sep);\r\n        var toSegs = to.split(paths.sep);\r\n        // Remove the first segment on both, as it's '' (both are absolute paths)\r\n        toSegs.shift();\r\n        fromSegs.shift();\r\n        // There are two segments to this path:\r\n        // * Going *up* the directory hierarchy with '..'\r\n        // * Going *down* the directory hierarchy with foo/baz/bat.\r\n        var upCount = 0;\r\n        var downSegs = [];\r\n        // Figure out how many things in 'from' are shared with 'to'.\r\n        for (i = 0; i < fromSegs.length; i++) {\r\n            var seg = fromSegs[i];\r\n            if (seg === toSegs[i]) {\r\n                continue;\r\n            }\r\n            // The rest of 'from', including the current element, indicates how many\r\n            // directories we need to go up.\r\n            upCount = fromSegs.length - i;\r\n            break;\r\n        }\r\n        // The rest of 'to' indicates where we need to change to. We place this\r\n        // outside of the loop, as toSegs.length may be greater than fromSegs.length.\r\n        downSegs = toSegs.slice(i);\r\n        // Special case: If 'from' is '/'\r\n        if (fromSegs.length === 1 && fromSegs[0] === '') {\r\n            upCount = 0;\r\n        }\r\n        // upCount can't be greater than the number of fromSegs\r\n        // (cd .. from / is still /)\r\n        if (upCount > fromSegs.length) {\r\n            upCount = fromSegs.length;\r\n        }\r\n        // Create the final string!\r\n        var rv = '';\r\n        for (i = 0; i < upCount; i++) {\r\n            rv += '../';\r\n        }\r\n        rv += downSegs.join(paths.sep);\r\n        // Special case: Remove trailing '/'. Happens if it's all up and no down.\r\n        if (rv.length > 1 && rv.charAt(rv.length - 1) === paths.sep) {\r\n            rv = rv.substr(0, rv.length - 1);\r\n        }\r\n        return rv;\r\n    }\r\n\r\n    return paths.relative =  relative;\r\n});\ndefine('skylark-langx-paths/main',[\r\n\t\"./paths\",\r\n\t\"./basename\",\r\n\t\"./dirname\",\r\n\t\"./extname\",\r\n\t\"./format\",\r\n\t\"./is-absolute\",\r\n\t\"./join\",\r\n\t\"./normalize\",\r\n\t\"./path\",\r\n\t\"./relative\",\r\n\t\"./resolve\"\r\n],function(paths){\r\n\treturn paths;\r\n});\ndefine('skylark-langx-paths', ['skylark-langx-paths/main'], function (main) { return main; });\n\ndefine('skylark-data-files/file-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n    * Indicates the type of the given file. Applied to 'mode'.\r\n    */\r\n  var FileType;\r\n  (function (FileType) {\r\n      FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\r\n      FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\r\n      FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\r\n  })(FileType || (FileType = {}));\r\n\r\n  return files.FileType = FileType;\r\n});\r\n  \ndefine('skylark-data-files/stats',[\r\n    'skylark-langx-binary/buffer',\r\n    \"./files\",\r\n    \"./file-type\"\r\n],function (Buffer,files,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Emulation of Node's `fs.Stats` object.\r\n     *\r\n     * Attribute descriptions are from `man 2 stat'\r\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\r\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\r\n     */\r\n    class Stats {\r\n        /**\r\n         * Provides information about a particular entry in the file system.\r\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\r\n         * @param size Size of the item in bytes. For directories/symlinks,\r\n         *   this is normally the size of the struct that represents the item.\r\n         * @param mode Unix-style file mode (e.g. 0o644)\r\n         * @param atimeMs time of last access, in milliseconds since epoch\r\n         * @param mtimeMs time of last modification, in milliseconds since epoch\r\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\r\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\r\n         */\r\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\r\n            /**\r\n             * UNSUPPORTED ATTRIBUTES\r\n             * I assume no one is going to need these details, although we could fake\r\n             * appropriate values if need be.\r\n             */\r\n            // ID of device containing file\r\n            this.dev = 0;\r\n            // inode number\r\n            this.ino = 0;\r\n            // device ID (if special file)\r\n            this.rdev = 0;\r\n            // number of hard links\r\n            this.nlink = 1;\r\n            // blocksize for file system I/O\r\n            this.blksize = 4096;\r\n            // @todo Maybe support these? atm, it's a one-user filesystem.\r\n            // user ID of owner\r\n            this.uid = 0;\r\n            // group ID of owner\r\n            this.gid = 0;\r\n            // XXX: Some file systems stash data on stats objects.\r\n            this.fileData = null;\r\n            this.size = size;\r\n            let currentTime = 0;\r\n            if (typeof (atimeMs) !== 'number') {\r\n                currentTime = Date.now();\r\n                atimeMs = currentTime;\r\n            }\r\n            if (typeof (mtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                mtimeMs = currentTime;\r\n            }\r\n            if (typeof (ctimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                ctimeMs = currentTime;\r\n            }\r\n            if (typeof (birthtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                birthtimeMs = currentTime;\r\n            }\r\n            this.atimeMs = atimeMs;\r\n            this.ctimeMs = ctimeMs;\r\n            this.mtimeMs = mtimeMs;\r\n            this.birthtimeMs = birthtimeMs;\r\n            if (!mode) {\r\n                switch (itemType) {\r\n                    case FileType.FILE:\r\n                        this.mode = 0x1a4;\r\n                        break;\r\n                    case FileType.DIRECTORY:\r\n                    default:\r\n                        this.mode = 0x1ff;\r\n                }\r\n            }\r\n            else {\r\n                this.mode = mode;\r\n            }\r\n            // number of 512B blocks allocated\r\n            this.blocks = Math.ceil(size / 512);\r\n            // Check if mode also includes top-most bits, which indicate the file's\r\n            // type.\r\n            if (this.mode < 0x1000) {\r\n                this.mode |= itemType;\r\n            }\r\n        }\r\n        static fromBuffer(buffer) {\r\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\r\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\r\n        }\r\n        /**\r\n         * Clones the stats object.\r\n         */\r\n        static clone(s) {\r\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\r\n        }\r\n        get atime() {\r\n            return new Date(this.atimeMs);\r\n        }\r\n        get mtime() {\r\n            return new Date(this.mtimeMs);\r\n        }\r\n        get ctime() {\r\n            return new Date(this.ctimeMs);\r\n        }\r\n        get birthtime() {\r\n            return new Date(this.birthtimeMs);\r\n        }\r\n        toBuffer() {\r\n            const buffer = Buffer.alloc(32);\r\n            buffer.writeUInt32LE(this.size, 0);\r\n            buffer.writeUInt32LE(this.mode, 4);\r\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\r\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\r\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\r\n         */\r\n        isSymbolicLink() {\r\n            return (this.mode & 0xF000) === FileType.SYMLINK;\r\n        }\r\n        /**\r\n         * Change the mode of the file. We use this helper function to prevent messing\r\n         * up the type of the file, which is encoded in mode.\r\n         */\r\n        chmod(mode) {\r\n            this.mode = (this.mode & 0xF000) | mode;\r\n        }\r\n        // We don't support the following types of files.\r\n        isSocket() {\r\n            return false;\r\n        }\r\n        isBlockDevice() {\r\n            return false;\r\n        }\r\n        isCharacterDevice() {\r\n            return false;\r\n        }\r\n        isFIFO() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return files.Stats = Stats;\r\n});\ndefine('skylark-data-files/file-system',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, paths, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return paths.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});\ndefine('skylark-data-files/utils',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(paths.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});\ndefine('skylark-data-files/preload-file',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,files,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});\ndefine('skylark-data-files/no-sync-file',[\r\n     \"./files\",\r\n     \"./preload-file\"\r\n], function (files,PreloadFile) {\r\n    'use strict';\r\n    /**\r\n     * File class for the InMemory and XHR file systems.\r\n     * Doesn't sync to anything, so it works nicely for memory-only files.\r\n     */\r\n    class NoSyncFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        /**\r\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous sync. Doesn't do anything.\r\n         */\r\n        syncSync() {\r\n            // NOP.\r\n        }\r\n        /**\r\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous close. Doesn't do anything.\r\n         */\r\n        closeSync() {\r\n            // NOP.\r\n        }\r\n    }\r\n\r\n    return files.NoSyncFile = NoSyncFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/registry',[\r\n\t\"../files\"\r\n],function(files){\r\n\r\n\tvar cache = {}\r\n\r\n\tfunction get(name) {\r\n\t\treturn cache[name];\r\n\t}\r\n\r\n\tfunction add(name,provider) {\r\n\t\tcache[name] = provider;\r\n\t}\r\n\t\r\n\r\n\treturn files.providers.registry = {\r\n\t\tget,\r\n\t\tadd\r\n\t};\r\n});\ndefine('skylark-data-files/configure',[\r\n    \"./files\",\r\n    './file-system',\r\n    \"./error-codes\",\r\n    \"./file-error\",\r\n    './providers/registry',\r\n], function(files, FileSystem, ErrorCodes,FileError,registry) {\r\n    'use strict';\r\n\r\n    var fs = files.fs = new FileSystem();\r\n\r\n    /**\r\n     * Initializes BrowserFS with the given root file system.\r\n     */\r\n    function initialize(rootfs) {\r\n        return fs.initialize(rootfs);\r\n    }\r\n    /**\r\n     * Creates a file system with the given configuration, and initializes BrowserFS with it.\r\n     * See the FileSystemConfiguration type for more info on the configuration object.\r\n     */\r\n    function configure(config, cb) {\r\n        getFileSystem(config, (e, fs) => {\r\n            if (fs) {\r\n                initialize(fs);\r\n                cb(fs);\r\n            }\r\n            else {\r\n                cb(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Retrieve a file system with the given configuration.\r\n     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\r\n     * @param cb Called when the file system is constructed, or when an error occurs.\r\n     */\r\n    function getFileSystem(config, cb) {\r\n        const fsName = config['fs'];\r\n        if (!fsName) {\r\n            return cb(new FileError(ErrorCodes.EPERM, 'Missing \"fs\" property on configuration object.'));\r\n        }\r\n        const options = config['options'];\r\n        let waitCount = 0;\r\n        let called = false;\r\n        function finish() {\r\n            if (!called) {\r\n                called = true;\r\n                const fsc = registry.get(fsName);\r\n                if (!fsc) {\r\n                    cb(new FileError(ErrorCodes.EPERM, `File system ${fsName} is not available in BrowserFS.`));\r\n                }\r\n                else {\r\n                    fsc.Create(options, cb);\r\n                }\r\n            }\r\n        }\r\n        if (options !== null && typeof (options) === \"object\") {\r\n            let finishedIterating = false;\r\n            const props = Object.keys(options).filter((k) => k !== 'fs');\r\n            // Check recursively if other fields have 'fs' properties.\r\n            props.forEach((p) => {\r\n                const d = options[p];\r\n                if (d !== null && typeof (d) === \"object\" && d['fs']) {\r\n                    waitCount++;\r\n                    getFileSystem(d, function (e, fs) {\r\n                        waitCount--;\r\n                        if (e) {\r\n                            if (called) {\r\n                                return;\r\n                            }\r\n                            called = true;\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            options[p] = fs;\r\n                            if (waitCount === 0 && finishedIterating) {\r\n                                finish();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            finishedIterating = true;\r\n        }\r\n        if (waitCount === 0) {\r\n            finish();\r\n        }\r\n    }\r\n\r\n    return files.configure = configure;\r\n});\ndefine('skylark-data-files/providers/base-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils'\r\n], function (Bufer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Basic filesystem class. Most filesystems should extend this class, as it\r\n     * provides default implementations for a handful of methods.\r\n     */\r\n    class BaseProvider {\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        diskSpace(p, cb) {\r\n            cb(0, 0);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         */\r\n        openFile(p, flag, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFile(p, flag, mode, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            const mustBeFile = (e, stats) => {\r\n                if (e) {\r\n                    // File does not exist.\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            // Ensure parent exists.\r\n                            return this.stat(paths.dirname(p), false, (e, parentStats) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (parentStats && !parentStats.isDirectory()) {\r\n                                    cb(FileError.ENOTDIR(paths.dirname(p)));\r\n                                }\r\n                                else {\r\n                                    this.createFile(p, flag, mode, cb);\r\n                                }\r\n                            });\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.ENOENT(p));\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n                else {\r\n                    // File exists.\r\n                    if (stats && stats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(p));\r\n                    }\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.EEXIST(p));\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            // NOTE: In a previous implementation, we deleted the file and\r\n                            // re-created it. However, this created a race condition if another\r\n                            // asynchronous request was trying to read the file, as the file\r\n                            // would not exist for a small period of time.\r\n                            return this.openFile(p, flag, (e, fd) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (fd) {\r\n                                    fd.truncate(0, () => {\r\n                                        fd.sync(() => {\r\n                                            cb(null, fd);\r\n                                        });\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    fail();\r\n                                }\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this.openFile(p, flag, cb);\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n            };\r\n            this.stat(p, false, mustBeFile);\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        statSync(p, isLstat) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         * @return A File object corresponding to the opened file.\r\n         */\r\n        openFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        openSync(p, flag, mode) {\r\n            // Check if the path exists, and is a file.\r\n            let stats;\r\n            try {\r\n                stats = this.statSync(p, false);\r\n            }\r\n            catch (e) {\r\n                // File does not exist.\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        // Ensure parent exists.\r\n                        const parentStats = this.statSync(paths.dirname(p), false);\r\n                        if (!parentStats.isDirectory()) {\r\n                            throw FileError.ENOTDIR(paths.dirname(p));\r\n                        }\r\n                        return this.createFileSync(p, flag, mode);\r\n                    case ActionType.THROW_EXCEPTION:\r\n                        throw FileError.ENOENT(p);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n                }\r\n            }\r\n            // File exists.\r\n            if (stats.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            switch (flag.pathExistsAction()) {\r\n                case ActionType.THROW_EXCEPTION:\r\n                    throw FileError.EEXIST(p);\r\n                case ActionType.TRUNCATE_FILE:\r\n                    // Delete file.\r\n                    this.unlinkSync(p);\r\n                    // Create file. Use the same mode as the old file.\r\n                    // Node itself modifies the ctime when this occurs, so this action\r\n                    // will preserve that behavior if the underlying file system\r\n                    // supports those properties.\r\n                    return this.createFileSync(p, flag, stats.mode);\r\n                case ActionType.NOP:\r\n                    return this.openFileSync(p, flag, mode);\r\n                default:\r\n                    throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        unlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        rmdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        rmdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        mkdirSync(p, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        exists(p, cb) {\r\n            this.stat(p, null, function (err) {\r\n                cb(!err);\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            try {\r\n                this.statSync(p, true);\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(null, addPaths);\r\n                }\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                this.exists(p, function (doesExist) {\r\n                    if (doesExist) {\r\n                        cb(null, p);\r\n                    }\r\n                    else {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(path, addPaths);\r\n                }\r\n                return splitPath.join(paths.sep);\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                if (this.existsSync(p)) {\r\n                    return p;\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        truncate(p, len, cb) {\r\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\r\n                if (er) {\r\n                    return cb(er);\r\n                }\r\n                fd.truncate(len, (function (er) {\r\n                    fd.close((function (er2) {\r\n                        cb(er || er2);\r\n                    }));\r\n                }));\r\n            }));\r\n        }\r\n        truncateSync(p, len) {\r\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\r\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\r\n            try {\r\n                fd.truncateSync(len);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, (err, fd) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                fd.stat((err, stat) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    // Allocate buffer.\r\n                    const buf = Buffer.alloc(stat.size);\r\n                    fd.read(buf, 0, stat.size, 0, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        else if (encoding === null) {\r\n                            return cb(err, buf);\r\n                        }\r\n                        try {\r\n                            cb(null, buf.toString(encoding));\r\n                        }\r\n                        catch (e) {\r\n                            cb(e);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const stat = fd.statSync();\r\n                // Allocate buffer.\r\n                const buf = Buffer.alloc(stat.size);\r\n                fd.readSync(buf, 0, stat.size, 0);\r\n                fd.closeSync();\r\n                if (encoding === null) {\r\n                    return buf;\r\n                }\r\n                return buf.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                try {\r\n                    if (typeof data === 'string') {\r\n                        data = Buffer.from(data, encoding);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return cb(e);\r\n                }\r\n                // Write into file.\r\n                fd.write(data, 0, data.length, 0, cb);\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                // Write into file.\r\n                fd.writeSync(data, 0, data.length, 0);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            this.open(fname, flag, mode, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.write(data, 0, data.length, null, cb);\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.writeSync(data, 0, data.length, null);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.BaseProvider = BaseProvider;\r\n});\ndefine('skylark-data-files/providers/dropbox/dropbox-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n    'use strict';\r\n\r\n    class DropboxFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n    return  DropboxFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/dropbox/dropbox-provider',[\n    \"skylark-langx-funcs/defer\",\n    \"skylark-langx-binary/buffer\",\n    \"skylark-langx-paths\",\n    \"../registry\",\n    \"../base-provider\",\n    '../../stats',\n    '../../file-type',\n    '../../file-error',\n    '../../error-codes',\n    '../../utils',\n    './dropbox-file'\n], function (setImmediate,Buffer,paths, registry,BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\n    'use strict';\n\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  paths;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'not_found':\n                return FileError.ENOENT(p);\n            case 'not_file':\n                return FileError.EISDIR(p);\n            case 'not_folder':\n                return FileError.ENOTDIR(p);\n            case 'restricted_content':\n                return FileError.EPERM(p);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return FileError.EPERM(p);\n            case 'insufficient_space':\n                return new FileError(ErrorCodes.ENOSPC, msg);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxProvider extends BaseProvider {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxProvider instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxProvider(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxProvider.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(FileError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(FileError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(FileError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(FileError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(FileError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(FileError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxProvider.Name = \"DropboxV2\";\n    DropboxProvider.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxProvider.DropboxFile = DropboxFile;\n\n    return  DropboxProvider;\n    \n});\ndefine('skylark-langx-funcs/debounce',[\r\n\t\"./funcs\",\r\n    \"./defer\"\r\n],function(funcs,defer){\r\n   \r\n    function debounce(fn, wait,useAnimationFrame) {\r\n        var timeout,\r\n            defered,\r\n            debounced = function () {\r\n                var context = this, args = arguments;\r\n                var later = function () {\r\n                    timeout = null;\r\n                    if (useAnimationFrame) {\r\n                        defered = defer(fn,args,context);\r\n                    } else {\r\n                        fn.apply(context, args);\r\n                    }\r\n                };\r\n\r\n                cancel();\r\n                timeout = setTimeout(later, wait);\r\n\r\n                return {\r\n                    cancel \r\n                };\r\n            },\r\n            cancel = debounced.cancel = function () {\r\n                if (timeout) {\r\n                    clearTimeout(timeout);\r\n                }\r\n                if (defered) {\r\n                    defered.cancel();\r\n                }\r\n                timeout = void 0;\r\n                defered = void 0;\r\n            };\r\n\r\n        return debounced;\r\n    }\r\n\r\n    return funcs.debounce = debounce;\r\n\r\n});\ndefine('skylark-langx-funcs/delegate',[\r\n  \"skylark-langx-objects\",\r\n  \"./funcs\"\r\n],function(objects,funcs){\r\n\tvar mixin = objects.mixin;\r\n\r\n    var delegate = (function() {\r\n        // boodman/crockford delegation w/ cornford optimization\r\n        function TMP() {}\r\n        return function(obj, props) {\r\n            TMP.prototype = obj;\r\n            var tmp = new TMP();\r\n            TMP.prototype = null;\r\n            if (props) {\r\n                mixin(tmp, props);\r\n            }\r\n            return tmp; // Object\r\n        };\r\n    })();\r\n\r\n    return funcs.delegate = delegate;\r\n\r\n});\ndefine('skylark-langx-funcs/loop',[\r\n\t\"./funcs\"\r\n],function(funcs){\r\n\r\n\t/**\r\n\t * Animation timer is a special type of timer that uses the requestAnimationFrame method.\r\n\t *\r\n\t * This timer calls the method with the same rate as the screen refesh rate.\r\n\t * \r\n\t * Loop time can be changed dinamically.\r\n\t *\r\n\t * @class AnimationTimer\r\n\t * @param {Function} callback Timer callback function.\r\n\t */\r\n\tfunction AnimationTimer(callback)\r\n\t{\r\n\t\tthis.callback = callback;\r\n\r\n\t\tthis.running = false;\r\n\t\tthis.id = -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Start timer, is the timer is already running dosen't do anything.\r\n\t * \r\n\t * @method start\r\n\t */\r\n\tAnimationTimer.prototype.start = function()\r\n\t{\r\n\t\tif(this.running)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis.running = true;\r\n\r\n\t\tvar self = this;\r\n\t\tfunction run()\r\n\t\t{\r\n\t\t\tself.callback();\r\n\r\n\t\t\tif(self.running)\r\n\t\t\t{\r\n\t\t\t\tself.id = requestAnimationFrame(run);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trun();\r\n\t};\r\n\r\n\t/**\r\n\t * Stop animation timer.\r\n\t * \r\n\t * @method stop\r\n\t */\r\n\tAnimationTimer.prototype.stop = function()\r\n\t{\r\n\t\tthis.running = false;\r\n\t\tcancelAnimationFrame(this.id);\r\n\t};\r\n\r\n\tfunction loop(fn) {\r\n\t\treturn new AnimationTimer(fn);\r\n    }\r\n\r\n    return funcs.loop = loop;\r\n});\ndefine('skylark-langx-funcs/negate',[\r\n\t\"./funcs\"\r\n],function(funcs){\r\n   \r\n    /**\r\n     * Creates a function that negates the result of the predicate `func`. The\r\n     * `func` predicate is invoked with the `this` binding and arguments of the\r\n     * created function.\r\n     * @category Function\r\n     * @param {Function} predicate The predicate to negate.\r\n     * @returns {Function} Returns the new negated function.\r\n     * @example\r\n     *\r\n     * function isEven(n) {\r\n     *   return n % 2 == 0\r\n     * }\r\n     *\r\n     * filter([1, 2, 3, 4, 5, 6], negate(isEven))\r\n     * // => [1, 3, 5]\r\n     */\r\n    function negate(predicate) {\r\n      if (typeof predicate !== 'function') {\r\n        throw new TypeError('Expected a function')\r\n      }\r\n      return function(...args) {\r\n        return !predicate.apply(this, args)\r\n      }\r\n    }\r\n\r\n\r\n    return funcs.negate = negate;\r\n\r\n});\ndefine('skylark-langx-funcs/proxy',[\r\n  \"skylark-langx-types\",\r\n\t\"./funcs\"\r\n],function(types,funcs){\r\n    var slice = Array.prototype.slice,\r\n        isFunction = types.isFunction,\r\n        isString = types.isString;\r\n\r\n    function proxy(fn, context) {\r\n        var args = (2 in arguments) && slice.call(arguments, 2)\r\n        if (isFunction(fn)) {\r\n            var proxyFn = function() {\r\n                return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);\r\n            }\r\n            return proxyFn;\r\n        } else if (isString(context)) {\r\n            if (args) {\r\n                args.unshift(fn[context], fn)\r\n                return proxy.apply(null, args)\r\n            } else {\r\n                return proxy(fn[context], fn);\r\n            }\r\n        } else {\r\n            throw new TypeError(\"expected function\");\r\n        }\r\n    }\r\n\r\n    return funcs.bind = funcs.proxy = proxy;\r\n\r\n});\ndefine('skylark-langx-funcs/template',[\r\n  \"skylark-langx-objects\",\r\n  \"./funcs\",\r\n  \"./proxy\"\r\n],function(objects,funcs,proxy){\r\n    //ref : underscore\r\n    var slice = Array.prototype.slice;\r\n   \r\n    // By default, Underscore uses ERB-style template delimiters, change the\r\n    // following template settings to use alternative delimiters.\r\n    var templateSettings = {\r\n        evaluate: /<%([\\s\\S]+?)%>/g,\r\n        interpolate: /<%=([\\s\\S]+?)%>/g,\r\n        escape: /<%-([\\s\\S]+?)%>/g\r\n    };\r\n\r\n    // When customizing `templateSettings`, if you don't want to define an\r\n    // interpolation, evaluation or escaping regex, we need one that is\r\n    // guaranteed not to match.\r\n    var noMatch = /(.)^/;\r\n\r\n\r\n    // Certain characters need to be escaped so that they can be put into a\r\n    // string literal.\r\n    var escapes = {\r\n      \"'\":      \"'\",\r\n      '\\\\':     '\\\\',\r\n      '\\r':     'r',\r\n      '\\n':     'n',\r\n      '\\t':     't',\r\n      '\\u2028': 'u2028',\r\n      '\\u2029': 'u2029'\r\n    };\r\n\r\n    var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\r\n\r\n\r\n    function template(text, data, settings) {\r\n        var render;\r\n        settings = objects.defaults({}, settings,templateSettings);\r\n\r\n        // Combine delimiters into one regular expression via alternation.\r\n        var matcher = RegExp([\r\n          (settings.escape || noMatch).source,\r\n          (settings.interpolate || noMatch).source,\r\n          (settings.evaluate || noMatch).source\r\n        ].join('|') + '|$', 'g');\r\n\r\n        // Compile the template source, escaping string literals appropriately.\r\n        var index = 0;\r\n        var source = \"__p+='\";\r\n        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\r\n          source += text.slice(index, offset)\r\n              .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\r\n\r\n          if (escape) {\r\n            source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\r\n          }\r\n          if (interpolate) {\r\n            source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\r\n          }\r\n          if (evaluate) {\r\n            source += \"';\\n\" + evaluate + \"\\n__p+='\";\r\n          }\r\n          index = offset + match.length;\r\n          return match;\r\n        });\r\n        source += \"';\\n\";\r\n\r\n        // If a variable is not specified, place data values in local scope.\r\n        if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\r\n\r\n        source = \"var __t,__p='',__j=Array.prototype.join,\" +\r\n          \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n          source + 'return __p;\\n';\r\n\r\n        try {\r\n          render = new Function(settings.variable || 'obj', '_', source);\r\n        } catch (e) {\r\n          e.source = source;\r\n          throw e;\r\n        }\r\n\r\n        if (data) {\r\n          return render(data,this)\r\n        }\r\n        var template = proxy(function(data) {\r\n          return render.call(this, data,this);\r\n        },this);\r\n\r\n        // Provide the compiled source as a convenience for precompilation.\r\n        var argument = settings.variable || 'obj';\r\n        template.source = 'function(' + argument + '){\\n' + source + '}';\r\n\r\n        return template;\r\n    }\r\n\r\n    template.templateSettings = funcs.templateSettings = templateSettings;\r\n\r\n    return funcs.template = template;\r\n\r\n});\ndefine('skylark-langx-funcs/throttle',[\r\n  \"./funcs\"\r\n],function(funcs){\r\n\r\n    const throttle = function (fn, wait) {\r\n        let last = window.performance.now();\r\n        const throttled = function (...args) {\r\n            const now = window.performance.now();\r\n            if (now - last >= wait) {\r\n                fn(...args);\r\n                last = now;\r\n            }\r\n        };\r\n        return throttled;\r\n    };\r\n\r\n    /*\r\n    function throttle(func, delay) {\r\n        var timer = null;\r\n\r\n        return function() {\r\n            var context = this,\r\n                args = arguments;\r\n\r\n            if ( timer === null ) {\r\n                timer = setTimeout(function() {\r\n                    func.apply(context, args);\r\n                    timer = null;\r\n                }, delay);\r\n            }\r\n        };\r\n    }\r\n    */\r\n\r\n\r\n    return funcs.throttle = throttle;\r\n});\ndefine('skylark-langx-funcs/main',[\r\n\t\"./funcs\",\r\n\t\"./debounce\",\r\n\t\"./defer\",\r\n\t\"./delegate\",\r\n\t\"./loop\",\r\n\t\"./negate\",\r\n\t\"./proxy\",\r\n\t\"./template\",\r\n\t\"./throttle\"\r\n],function(funcs){\r\n\treturn funcs;\r\n});\ndefine('skylark-langx-funcs', ['skylark-langx-funcs/main'], function (main) { return main; });\n\ndefine('skylark-langx-async/deferred',[\r\n    \"skylark-langx-arrays\",\r\n\t\"skylark-langx-funcs\",\r\n    \"skylark-langx-objects\"\r\n],function(arrays,funcs,objects){\r\n    \"use strict\";\r\n\r\n    var slice = Array.prototype.slice,\r\n        proxy = funcs.proxy,\r\n        makeArray = arrays.makeArray,\r\n        result = objects.result,\r\n        mixin = objects.mixin;\r\n\r\n    mixin(Promise.prototype,{\r\n        always: function(handler) {\r\n            //this.done(handler);\r\n            //this.fail(handler);\r\n            this.then(handler,handler);\r\n            return this;\r\n        },\r\n        done : function() {\r\n            for (var i = 0;i<arguments.length;i++) {\r\n                this.then(arguments[i]);\r\n            }\r\n            return this;\r\n        },\r\n        fail : function(handler) { \r\n            //return mixin(Promise.prototype.catch.call(this,handler),added);\r\n            //return this.then(null,handler);\r\n            this.catch(handler);\r\n            return this;\r\n         }\r\n    });\r\n\r\n\r\n    var Deferred = function() {\r\n        var self = this,\r\n            p = this.promise = makePromise2(new Promise(function(resolve, reject) {\r\n                self._resolve = resolve;\r\n                self._reject = reject;\r\n            }));\r\n\r\n        //wrapPromise(p,self);\r\n\r\n        //this[PGLISTENERS] = [];\r\n        //this[PGNOTIFIES] = [];\r\n\r\n        //this.resolve = Deferred.prototype.resolve.bind(this);\r\n        //this.reject = Deferred.prototype.reject.bind(this);\r\n        //this.progress = Deferred.prototype.progress.bind(this);\r\n\r\n    };\r\n\r\n   \r\n    function makePromise2(promise) {\r\n        // Don't modify any promise that has been already modified.\r\n        if (promise.isResolved) return promise;\r\n\r\n        // Set initial state\r\n        var isPending = true;\r\n        var isRejected = false;\r\n        var isResolved = false;\r\n\r\n        // Observe the promise, saving the fulfillment in a closure scope.\r\n        var result = promise.then(\r\n            function(v) {\r\n                isResolved = true;\r\n                isPending = false;\r\n                return v; \r\n            }, \r\n            function(e) {\r\n                isRejected = true;\r\n                isPending = false;\r\n                throw e; \r\n            }\r\n        );\r\n\r\n        result.isResolved = function() { return isResolved; };\r\n        result.isPending = function() { return isPending; };\r\n        result.isRejected = function() { return isRejected; };\r\n\r\n        result.state = function() {\r\n            if (isResolved) {\r\n                return 'resolved';\r\n            }\r\n            if (isRejected) {\r\n                return 'rejected';\r\n            }\r\n            return 'pending';\r\n        };\r\n\r\n        var notified = [],\r\n            listeners = [];\r\n\r\n          \r\n        result.then = function(onResolved,onRejected,onProgress) {\r\n            if (onProgress) {\r\n                this.progress(onProgress);\r\n            }\r\n            return makePromise2(Promise.prototype.then.call(this,\r\n                onResolved && function(args) {\r\n                    if (args && args.__ctx__ !== undefined) {\r\n                        return onResolved.apply(args.__ctx__,args);\r\n                    } else {\r\n                        return onResolved(args);\r\n                    }\r\n                },\r\n                onRejected && function(args){\r\n                    if (args && args.__ctx__ !== undefined) {\r\n                        return onRejected.apply(args.__ctx__,args);\r\n                    } else {\r\n                        return onRejected(args);\r\n                    }\r\n                }\r\n            ));\r\n        };\r\n\r\n        result.progress = function(handler) {\r\n            notified.forEach(function (value) {\r\n                handler(value);\r\n            });\r\n            listeners.push(handler);\r\n            return this;\r\n        };\r\n\r\n        result.pipe = result.then;\r\n\r\n        result.notify = function(value) {\r\n            try {\r\n                notified.push(value);\r\n\r\n                return listeners.forEach(function (listener) {\r\n                    return listener(value);\r\n                });\r\n            } catch (error) {\r\n            this.reject(error);\r\n            }\r\n            return this;\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n \r\n    Deferred.prototype.resolve = function(value) {\r\n        var args = slice.call(arguments);\r\n        return this.resolveWith(null,args);\r\n    };\r\n\r\n    Deferred.prototype.resolveWith = function(context,args) {\r\n        args = args ? makeArray(args) : []; \r\n        args.__ctx__ = context;\r\n        this._resolve(args);\r\n        this._resolved = true;\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.notify = function(value) {\r\n        var p = result(this,\"promise\");\r\n        p.notify(value);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.reject = function(reason) {\r\n        var args = slice.call(arguments);\r\n        return this.rejectWith(null,args);\r\n    };\r\n\r\n    Deferred.prototype.rejectWith = function(context,args) {\r\n        args = args ? makeArray(args) : []; \r\n        args.__ctx__ = context;\r\n        this._reject(args);\r\n        this._rejected = true;\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.isResolved = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.isResolved();\r\n    };\r\n\r\n    Deferred.prototype.isRejected = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.isRejected();\r\n    };\r\n\r\n    Deferred.prototype.state = function() {\r\n        var p = result(this,\"promise\");\r\n        return p.state();\r\n    };\r\n\r\n    Deferred.prototype.then = function(callback, errback, progback) {\r\n        var p = result(this,\"promise\");\r\n        return p.then(callback, errback, progback);\r\n    };\r\n\r\n    Deferred.prototype.progress = function(progback){\r\n        var p = result(this,\"promise\");\r\n        return p.progress(progback);\r\n    };\r\n   \r\n    Deferred.prototype.catch = function(errback) {\r\n        var p = result(this,\"promise\");\r\n        return p.catch(errback);\r\n    };\r\n\r\n\r\n    Deferred.prototype.always  = function() {\r\n        var p = result(this,\"promise\");\r\n        p.always.apply(p,arguments);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.done  = function() {\r\n        var p = result(this,\"promise\");\r\n        p.done.apply(p,arguments);\r\n        return this;\r\n    };\r\n\r\n    Deferred.prototype.fail = function(errback) {\r\n        var p = result(this,\"promise\");\r\n        p.fail(errback);\r\n        return this;\r\n    };\r\n\r\n\r\n    Deferred.all = function(array) {\r\n        //return wrapPromise(Promise.all(array));\r\n        var d = new Deferred();\r\n        Promise.all(array).then(d.resolve.bind(d),d.reject.bind(d));\r\n        return result(d,\"promise\");\r\n    };\r\n\r\n    Deferred.first = function(array) {\r\n        return makePromise2(Promise.race(array));\r\n    };\r\n\r\n\r\n    Deferred.when = function(valueOrPromise, callback, errback, progback) {\r\n        var receivedPromise = valueOrPromise && typeof valueOrPromise.then === \"function\";\r\n        var nativePromise = receivedPromise && valueOrPromise instanceof Promise;\r\n\r\n        if (!receivedPromise) {\r\n            if (arguments.length > 1) {\r\n                return callback ? callback(valueOrPromise) : valueOrPromise;\r\n            } else {\r\n                return new Deferred().resolve(valueOrPromise);\r\n            }\r\n        } else if (!nativePromise) {\r\n            var deferred = new Deferred(valueOrPromise.cancel);\r\n            valueOrPromise.then(proxy(deferred.resolve,deferred), proxy(deferred.reject,deferred), deferred.notify);\r\n            valueOrPromise = deferred.promise;\r\n        }\r\n\r\n        if (callback || errback || progback) {\r\n            return valueOrPromise.then(callback, errback, progback);\r\n        }\r\n        return valueOrPromise;\r\n    };\r\n\r\n    Deferred.reject = function(err) {\r\n        var d = new Deferred();\r\n        d.reject(err);\r\n        return d.promise;\r\n    };\r\n\r\n    Deferred.resolve = function(data) {\r\n        var d = new Deferred();\r\n        d.resolve.apply(d,arguments);\r\n        return d.promise;\r\n    };\r\n\r\n    Deferred.immediate = Deferred.resolve;\r\n\r\n\r\n    Deferred.promise = function(callback) {\r\n        var d = new Deferred();\r\n\r\n        callback(d.resolve.bind(d),d.reject.bind(d),d.progress.bind(d));\r\n\r\n        return d.promise;\r\n    };\r\n\r\n    return Deferred;\r\n});\ndefine('skylark-langx-async/async',[\r\n    \"skylark-langx-ns\",\r\n    \"skylark-langx-objects\",\r\n    \"./deferred\"\r\n],function(skylark,objects,Deferred){\r\n    var each = objects.each;\r\n    \r\n    var async = {\r\n        Deferred : Deferred,\r\n\r\n        parallel : function(arr,args,ctx) {\r\n            var rets = [];\r\n            ctx = ctx || null;\r\n            args = args || [];\r\n\r\n            each(arr,function(i,func){\r\n                rets.push(func.apply(ctx,args));\r\n            });\r\n\r\n            return Deferred.all(rets);\r\n        },\r\n\r\n        series : function(arr,args,ctx) {\r\n            var rets = [],\r\n                d = new Deferred(),\r\n                p = d.promise;\r\n\r\n            ctx = ctx || null;\r\n            args = args || [];\r\n\r\n            d.resolve();\r\n            each(arr,function(i,func){\r\n                p = p.then(function(){\r\n                    return func.apply(ctx,args);\r\n                });\r\n                rets.push(p);\r\n            });\r\n\r\n            return Deferred.all(rets);\r\n        },\r\n\r\n        waterful : function(arr,args,ctx) {\r\n            var d = new Deferred(),\r\n                p = d.promise;\r\n\r\n            ctx = ctx || null;\r\n            args = args || [];\r\n\r\n            d.resolveWith(ctx,args);\r\n\r\n            each(arr,function(i,func){\r\n                p = p.then(func);\r\n            });\r\n            return p;\r\n        }\r\n    };\r\n\r\n\treturn skylark.attach(\"langx.async\",async);\t\r\n});\ndefine('skylark-langx-async/main',[\r\n\t\"./async\"\r\n],function(async){\r\n\treturn async;\r\n});\ndefine('skylark-langx-async', ['skylark-langx-async/main'], function (main) { return main; });\n\ndefine('skylark-data-files/providers/html5/html5-lfs-file',[\r\n    \"../../utils\",\r\n    '../../preload-file'\r\n], function (utils,PreloadFile) {\r\n    'use strict';\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\r\n\r\n    // A note about getFile and getDirectory options:\r\n    // These methods are called at numerous places in this file, and are passed\r\n    // some combination of these two options:\r\n    //   - create: If true, the entry will be created if it doesn't exist.\r\n    //             If false, an error will be thrown if it doesn't exist.\r\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\r\n    //                and throw an error if it does.\r\n    class Html5LfsFile extends PreloadFile {\r\n        constructor(fs, entry, path, flag, stat, contents) {\r\n            super(fs, path, flag, stat, contents);\r\n            this._entry = entry;\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                return cb();\r\n            }\r\n            this._entry.createWriter((writer) => {\r\n                const buffer = this.getBuffer();\r\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\r\n                const length = blob.size;\r\n                writer.onwriteend = (err) => {\r\n                    writer.onwriteend = null;\r\n                    writer.onerror = null;\r\n                    writer.truncate(length);\r\n                    this.resetDirty();\r\n                    cb();\r\n                };\r\n                writer.onerror = (err) => {\r\n                    cb(convertError(err, this.getPath(), false));\r\n                };\r\n                writer.write(blob);\r\n            });\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n    return Html5LfsFile;\r\n});\ndefine('skylark-data-files/providers/html5/html5-lfs-provider',[\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    '../../preload-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    \"./html5-lfs-file\"\n], function (async,paths,PreloadFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType, utils,Html5LfsFile) {\n    'use strict';\n\n    const asyncEach = async.each;\n\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\n\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n\n    /**\n     * @hidden\n     */\n    const _getFS = window.webkitRequestProvider || window.requestProvider || null;\n\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for Provider.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case window.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case window.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            window.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate FileError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return FileError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return FileError.FileError(ErrorCodes.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return FileError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return FileError.FileError(ErrorCodes.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return FileError.FileError(ErrorCodes.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return FileError.FileError(expectedDir ? ErrorCodes.ENOTDIR : ErrorCodes.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return FileError.FileError(ErrorCodes.EINVAL, p);\n        }\n    }\n\n    /**\n     * A read-write filesystem backed by the HTML5 Provider API.\n     *\n     * As the HTML5 Provider is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class Html5LfsProvider extends BaseProvider {\n\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = window.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n\n        /**\n         * Creates an Html5LfsProvider instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new Html5LfsProvider(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n\n        static isAvailable() {\n            return !!_getFS;\n        }\n\n        getName() {\n            return Html5LfsProvider.Name;\n        }\n\n        isReadOnly() {\n            return false;\n        }\n\n        supportsSymlinks() {\n            return false;\n        }\n\n        supportsProps() {\n            return false;\n        }\n\n        supportsSynch() {\n            return false;\n        }\n\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new FileError(ErrorCodes.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = paths.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = paths.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(FileError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(FileError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new Html5LfsFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        \n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === window.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    Html5LfsProvider.Name = \"Html5LfsProvider\";\n    Html5LfsProvider.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    Html5LfsProvider.Html5LfsFile = Html5LfsFile;\n\n    return Html5LfsProvider;\n});\ndefine('skylark-data-files/providers/http/xhr',[\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error',\n    \"../../utils\"\n], function (Buffer,ErrorCodes,FileError,utils) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = utils;\n\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new FileError(ErrorCodes.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});\ndefine('skylark-data-files/providers/http/fetch',[\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error'\n], function (Buffer,ErrorCodes,FileError) {\n    'use strict';\n\n\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\n\n    function fetchFileAsync(p, type, cb) {\n        let request;\n        try {\n            request = fetch(p);\n        }\n        catch (e) {\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\n            return cb(new FileError(ErrorCodes.EINVAL, e.message));\n        }\n        request\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch error: response returned code ${res.status}`));\n            }\n            else {\n                switch (type) {\n                    case 'buffer':\n                        res.arrayBuffer()\n                            .then((buf) => cb(null, Buffer.from(buf)))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    case 'json':\n                        res.json()\n                            .then((json) => cb(null, json))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n                }\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n\n    function fetchFileSizeAsync(p, cb) {\n        fetch(p, { method: 'HEAD' })\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch HEAD error: response returned code ${res.status}`));\n            }\n            else {\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    return {\n        fetchIsAvailable: fetchIsAvailable,\n        fetchFileAsync: fetchFileAsync,\n        fetchFileSizeAsync: fetchFileSizeAsync\n    };\n});\ndefine('skylark-data-files/inodes/dir-inode',[\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a directory. Currently only contains the directory listing.\r\n     */\r\n    class DirInode {\r\n        /**\r\n         * Constructs an inode for a directory.\r\n         */\r\n        constructor(data = null) {\r\n            this.data = data;\r\n            this._ls = {};\r\n        }\r\n        isFile() {\r\n            return false;\r\n        }\r\n        isDir() {\r\n            return true;\r\n        }\r\n        getData() { return this.data; }\r\n        /**\r\n         * Return a Stats object for this inode.\r\n         * @todo Should probably remove this at some point. This isn't the\r\n         *       responsibility of the FileIndex.\r\n         */\r\n        getStats() {\r\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\r\n        }\r\n        /**\r\n         * Returns the directory listing for this directory. Paths in the directory are\r\n         * relative to the directory's path.\r\n         * @return The directory listing for this directory.\r\n         */\r\n        getListing() {\r\n            return Object.keys(this._ls);\r\n        }\r\n        /**\r\n         * Returns the inode for the indicated item, or null if it does not exist.\r\n         * @param p Name of item in this directory.\r\n         */\r\n        getItem(p) {\r\n            const item = this._ls[p];\r\n            return item ? item : null;\r\n        }\r\n        /**\r\n         * Add the given item to the directory listing. Note that the given inode is\r\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\r\n         * @param p Item name to add to the directory listing.\r\n         * @param inode The inode for the\r\n         *   item to add to the directory inode.\r\n         * @return True if it was added, false if it already existed.\r\n         */\r\n        addItem(p, inode) {\r\n            if (p in this._ls) {\r\n                return false;\r\n            }\r\n            this._ls[p] = inode;\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given item from the directory listing.\r\n         * @param p Name of item to remove from the directory listing.\r\n         * @return Returns the item\r\n         *   removed, or null if the item did not exist.\r\n         */\r\n        remItem(p) {\r\n            const item = this._ls[p];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            delete this._ls[p];\r\n            return item;\r\n        }\r\n    }\r\n\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    DirInode.isDirInode =  function isDirInode(inode) {\r\n        return !!inode && inode.isDir();\r\n    }\r\n\r\n\r\n    return DirInode;\r\n});\ndefine('skylark-data-files/inodes/file-inode',[\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\r\n     */\r\n    class FileInode {\r\n        constructor(data) {\r\n            this.data = data;\r\n        }\r\n        isFile() { return true; }\r\n        isDir() { return false; }\r\n        getData() { return this.data; }\r\n        setData(data) { this.data = data; }\r\n    }\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    FileInode.isFileInode = function isFileInode(inode) {\r\n        return !!inode && inode.isFile();\r\n    };\r\n\r\n\r\n    return FileInode;\r\n\r\n});\ndefine('skylark-data-files/inodes/file-index',[\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type',\r\n    \"./dir-inode\",\r\n    \"./file-inode\"\r\n], function (paths, Stats,FileType,DirInode,FileINode) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple class for storing a filesystem index. Assumes that all paths passed\r\n     * to it are *absolute* paths.\r\n     *\r\n     * Can be used as a partial or a full index, although care must be taken if used\r\n     * for the former purpose, especially when directories are concerned.\r\n     */\r\n    class FileIndex {\r\n        /**\r\n         * Constructs a new FileIndex.\r\n         */\r\n        constructor() {\r\n            // _index is a single-level key,value store that maps *directory* paths to\r\n            // DirInodes. File information is only contained in DirInodes themselves.\r\n            this._index = {};\r\n            // Create the root directory.\r\n            this.addPath('/', new DirInode());\r\n        }\r\n        /**\r\n         * Static method for constructing indices from a JSON listing.\r\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\r\n         * @return A new FileIndex object.\r\n         */\r\n        static fromListing(listing) {\r\n            const idx = new FileIndex();\r\n            // Add a root DirNode.\r\n            const rootInode = new DirInode();\r\n            idx._index['/'] = rootInode;\r\n            const queue = [['', listing, rootInode]];\r\n            while (queue.length > 0) {\r\n                let inode;\r\n                const next = queue.pop();\r\n                const pwd = next[0];\r\n                const tree = next[1];\r\n                const parent = next[2];\r\n                for (const node in tree) {\r\n                    if (tree.hasOwnProperty(node)) {\r\n                        const children = tree[node];\r\n                        const name = `${pwd}/${node}`;\r\n                        if (children) {\r\n                            idx._index[name] = inode = new DirInode();\r\n                            queue.push([name, children, inode]);\r\n                        }\r\n                        else {\r\n                            // This inode doesn't have correct size information, noted with -1.\r\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\r\n                        }\r\n                        if (parent) {\r\n                            parent._ls[node] = inode;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return idx;\r\n        }\r\n        /**\r\n         * Runs the given function over all files in the index.\r\n         */\r\n        fileIterator(cb) {\r\n            for (const path in this._index) {\r\n                if (this._index.hasOwnProperty(path)) {\r\n                    const dir = this._index[path];\r\n                    const files = dir.getListing();\r\n                    for (const file of files) {\r\n                        const item = dir.getItem(file);\r\n                        if (isFileInode(item)) {\r\n                            cb(item.getData());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPath(path, inode) {\r\n            if (!inode) {\r\n                throw new Error('Inode must be specified');\r\n            }\r\n            if (path[0] !== '/') {\r\n                throw new Error('Path must be absolute, got: ' + path);\r\n            }\r\n            // Check if it already exists.\r\n            if (this._index.hasOwnProperty(path)) {\r\n                return this._index[path] === inode;\r\n            }\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[dirpath];\r\n            if (parent === undefined && path !== '/') {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                if (!this.addPath(dirpath, parent)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Add myself to my parent.\r\n            if (path !== '/') {\r\n                if (!parent.addItem(itemname, inode)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // If I'm a directory, add myself to the index.\r\n            if (isDirInode(inode)) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * The path is added without special treatment (no joining of adjacent separators, etc).\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPathFast(path, inode) {\r\n            const itemNameMark = path.lastIndexOf('/');\r\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\r\n            const itemName = path.substring(itemNameMark + 1);\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[parentPath];\r\n            if (parent === undefined) {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                this.addPathFast(parentPath, parent);\r\n            }\r\n            if (!parent.addItem(itemName, inode)) {\r\n                return false;\r\n            }\r\n            // If adding a directory, add to the index as well.\r\n            if (inode.isDir()) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given path. Can be a file or a directory.\r\n         * @return The removed item,\r\n         *   or null if it did not exist.\r\n         */\r\n        removePath(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to remove it from its parent directory first.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Remove myself from my parent.\r\n            const inode = parent.remItem(itemname);\r\n            if (inode === null) {\r\n                return null;\r\n            }\r\n            // If I'm a directory, remove myself from the index, and remove my children.\r\n            if (isDirInode(inode)) {\r\n                const children = inode.getListing();\r\n                for (const child of children) {\r\n                    this.removePath(path + '/' + child);\r\n                }\r\n                // Remove the directory from the index, unless it's the root.\r\n                if (path !== '/') {\r\n                    delete this._index[path];\r\n                }\r\n            }\r\n            return inode;\r\n        }\r\n        /**\r\n         * Retrieves the directory listing of the given path.\r\n         * @return An array of files in the given path, or 'null' if it does not exist.\r\n         */\r\n        ls(path) {\r\n            const item = this._index[path];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            return item.getListing();\r\n        }\r\n        /**\r\n         * Returns the inode of the given item.\r\n         * @return Returns null if the item does not exist.\r\n         */\r\n        getInode(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Retrieve from its parent directory.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Root case\r\n            if (dirpath === path) {\r\n                return parent;\r\n            }\r\n            return parent.getItem(itemname);\r\n        }\r\n        /**\r\n         * Split into a (directory path, item name) pair\r\n         */\r\n        _split_path(p) {\r\n            const dirpath = paths.dirname(p);\r\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\r\n            return [dirpath, itemname];\r\n        }\r\n    }\r\n    \r\n\r\n    return FileIndex;\r\n});\ndefine('skylark-data-files/providers/http/http-provider',[\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    '../../no-sync-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    './xhr',\n    './fetch',\n    '../../inodes/dir-inode',\n    '../../inodes/file-index',\n    '../../inodes/file-inode',\n\n], function (async,paths,NoSyncFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType,  utils,xhr, fetch, DirInode,FileIndex,FileInode) {\n\n\n    'use strict';\n\n    const { copyingSlice }  = utils;\n\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n\n    const isFileInode = FileInode.isFileInode,\n          isDirInode = DirInode.isDirInode;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new FileError(ErrorCodes.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HttpProvider extends BaseProvider {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HttpProvider file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HttpProvider(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HttpProvider(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HttpProvider.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw FileError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(FileError.FileError(ErrorCodes.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw FileError.FileError(ErrorCodes.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new FileError(ErrorCodes.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(FileError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(FileError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new FileError(ErrorCodes.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw FileError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw FileError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HttpProvider.Name = \"http\";\n    HttpProvider.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    return HttpProvider;\n});\ndefine('skylark-langx-strings/strings',[\r\n    \"skylark-langx-ns\"\r\n],function(skylark){\r\n    return skylark.attach(\"langx.strings\");\r\n});\ndefine('skylark-langx-strings/generate-uuid',[\r\n\t\"./strings\"\r\n],function(strings){\r\n    function generateUUID() {\r\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n            var r = Math.random() * 16 | 0;\r\n            var v = c === 'x' ? r : ((r & 0x3) | 0x8);\r\n            return v.toString(16);\r\n        });\r\n    }\r\n\r\n\treturn strings.generateUUID = generateUUID;\r\n});\ndefine('skylark-data-collections/collections',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"data.collections\",{});\r\n});\ndefine('skylark-data-collections/lru-node',[\r\n    \"./collections\"\r\n], function(collections, List) {\r\n\r\n    class LruNode {\r\n        constructor(key, value) {\r\n            this.key = key;\r\n            this.value = value;\r\n            this.prev = null;\r\n            this.next = null;\r\n        }\r\n    }\r\n\r\n    return collections.LruNode = LruNode;\r\n});\ndefine('skylark-data-collections/lru-cache',[\r\n    \"./collections\",\r\n    \"./lru-node\"\r\n], function(collections,LruNode) {\r\n   // Adapted from https://chrisrng.svbtle.com/lru-cache-in-javascript\r\n    class LruCache {\r\n        constructor(limit) {\r\n            this.limit = limit;\r\n            this.size = 0;\r\n            this.map = {};\r\n            this.head = null;\r\n            this.tail = null;\r\n        }\r\n        /**\r\n         * Change or add a new value in the cache\r\n         * We overwrite the entry if it already exists\r\n         */\r\n        set(key, value) {\r\n            const node = new LruNode(key, value);\r\n            if (this.map[key]) {\r\n                this.map[key].value = node.value;\r\n                this.remove(node.key);\r\n            }\r\n            else {\r\n                if (this.size >= this.limit) {\r\n                    delete this.map[this.tail.key];\r\n                    this.size--;\r\n                    this.tail = this.tail.prev;\r\n                    this.tail.next = null;\r\n                }\r\n            }\r\n            this.setHead(node);\r\n        }\r\n        /* Retrieve a single entry from the cache */\r\n        get(key) {\r\n            if (this.map[key]) {\r\n                const value = this.map[key].value;\r\n                const node = new LruNode(key, value);\r\n                this.remove(key);\r\n                this.setHead(node);\r\n                return value;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        /* Remove a single entry from the cache */\r\n        remove(key) {\r\n            const node = this.map[key];\r\n            if (!node) {\r\n                return;\r\n            }\r\n            if (node.prev !== null) {\r\n                node.prev.next = node.next;\r\n            }\r\n            else {\r\n                this.head = node.next;\r\n            }\r\n            if (node.next !== null) {\r\n                node.next.prev = node.prev;\r\n            }\r\n            else {\r\n                this.tail = node.prev;\r\n            }\r\n            delete this.map[key];\r\n            this.size--;\r\n        }\r\n        /* Resets the entire cache - Argument limit is optional to be reset */\r\n        removeAll() {\r\n            this.size = 0;\r\n            this.map = {};\r\n            this.head = null;\r\n            this.tail = null;\r\n        }\r\n        setHead(node) {\r\n            node.next = this.head;\r\n            node.prev = null;\r\n            if (this.head !== null) {\r\n                this.head.prev = node;\r\n            }\r\n            this.head = node;\r\n            if (this.tail === null) {\r\n                this.tail = node;\r\n            }\r\n            this.size++;\r\n            this.map[node.key] = node;\r\n        }\r\n    }\r\n\r\n    return collections.LruCache = LruCache;\r\n});\ndefine('skylark-data-files/inodes/inode',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../stats',\r\n    '../file-type'\r\n], function (Buffer,Stats,FileType) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Generic inode definition that can easily be serialized.\r\n     */\r\n    class Inode {\r\n        constructor(id, size, mode, atime, mtime, ctime) {\r\n            this.id = id;\r\n            this.size = size;\r\n            this.mode = mode;\r\n            this.atime = atime;\r\n            this.mtime = mtime;\r\n            this.ctime = ctime;\r\n        }\r\n\r\n        /**\r\n         * Converts the buffer into an Inode.\r\n         */\r\n        static fromBuffer(buffer) {\r\n            if (buffer === undefined) {\r\n                throw new Error(\"NO\");\r\n            }\r\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\r\n        }\r\n\r\n        /**\r\n         * Handy function that converts the Inode to a Node Stats object.\r\n         */\r\n        toStats() {\r\n            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\r\n        }\r\n\r\n        /**\r\n         * Get the size of this Inode, in bytes.\r\n         */\r\n        getSize() {\r\n            // ASSUMPTION: ID is ASCII (1 byte per char).\r\n            return 30 + this.id.length;\r\n        }\r\n\r\n        /**\r\n         * Writes the inode into the start of the buffer.\r\n         */\r\n        toBuffer(buff = Buffer.alloc(this.getSize())) {\r\n            buff.writeUInt32LE(this.size, 0);\r\n            buff.writeUInt16LE(this.mode, 4);\r\n            buff.writeDoubleLE(this.atime, 6);\r\n            buff.writeDoubleLE(this.mtime, 14);\r\n            buff.writeDoubleLE(this.ctime, 22);\r\n            buff.write(this.id, 30, this.id.length, 'ascii');\r\n            return buff;\r\n        }\r\n        \r\n        /**\r\n         * Updates the Inode using information from the stats object. Used by file\r\n         * systems at sync time, e.g.:\r\n         * - Program opens file and gets a File object.\r\n         * - Program mutates file. File object is responsible for maintaining\r\n         *   metadata changes locally -- typically in a Stats object.\r\n         * - Program closes file. File object's metadata changes are synced with the\r\n         *   file system.\r\n         * @return True if any changes have occurred.\r\n         */\r\n        update(stats) {\r\n            let hasChanged = false;\r\n            if (this.size !== stats.size) {\r\n                this.size = stats.size;\r\n                hasChanged = true;\r\n            }\r\n            if (this.mode !== stats.mode) {\r\n                this.mode = stats.mode;\r\n                hasChanged = true;\r\n            }\r\n            const atimeMs = stats.atime.getTime();\r\n            if (this.atime !== atimeMs) {\r\n                this.atime = atimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const mtimeMs = stats.mtime.getTime();\r\n            if (this.mtime !== mtimeMs) {\r\n                this.mtime = mtimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const ctimeMs = stats.ctime.getTime();\r\n            if (this.ctime !== ctimeMs) {\r\n                this.ctime = ctimeMs;\r\n                hasChanged = true;\r\n            }\r\n            return hasChanged;\r\n        }\r\n        // XXX: Copied from Stats. Should reconcile these two into something more\r\n        //      compact.\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n    }\r\n\r\n\r\n    return Inode;\r\n});\ndefine('skylark-data-files/providers/async-key-value-file',[\r\n    \"../files\",\r\n    '../preload-file'\r\n], function (files, PreloadFile) {\r\n    'use strict';\r\n\r\n    class AsyncKeyValueFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            if (this.isDirty()) {\r\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\r\n                    if (!e) {\r\n                        this.resetDirty();\r\n                    }\r\n                    cb(e);\r\n                });\r\n            }\r\n            else {\r\n                cb();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return files.providers.AsyncKeyValueFile = AsyncKeyValueFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/async-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-collections/lru-cache\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"../file-type\",\r\n    '../utils',\r\n    \"../inodes/inode\",\r\n    \"./base-provider\",\r\n    \"./async-key-value-file\"\r\n ], function (GenerateRandomID,Buffer,paths,LRUCache, files, ErrorCodes, FileError, FileType, utils, Inode,BaseProvider,AsyncKeyValueFile) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const ROOT_NODE_ID = \"/\";\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyDirNode = null;\r\n\r\n    /**\r\n     * Returns an empty directory node.\r\n     * @hidden\r\n     */\r\n    function getEmptyDirNode() {\r\n        if (emptyDirNode) {\r\n            return emptyDirNode;\r\n        }\r\n        return emptyDirNode = Buffer.from(\"{}\");\r\n    }\r\n\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\r\n     * with 'e' and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noError(e, cb) {\r\n        if (e) {\r\n            cb(e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\r\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noErrorTx(e, tx, cb) {\r\n        if (e) {\r\n            tx.abort(() => {\r\n                cb(e);\r\n            });\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\r\n     * an underlying asynchronous key-value store.\r\n     */\r\n    class AsyncKeyValueProvider extends BaseProvider {\r\n        constructor(cacheSize) {\r\n            super();\r\n            this._cache = null;\r\n            if (cacheSize > 0) {\r\n                this._cache = new LRUCache(cacheSize);\r\n            }\r\n        }\r\n\r\n        static isAvailable() { return true; }\r\n        /**\r\n         * Initializes the file system. Typically called by subclasses' async\r\n         * constructors.\r\n         */\r\n        init(store, cb) {\r\n            this.store = store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory(cb);\r\n        }\r\n\r\n        getName() { return this.store.name(); }\r\n        \r\n        isReadOnly() { return false; }\r\n        \r\n        supportsSymlinks() { return false; }\r\n        \r\n        supportsProps() { return false; }\r\n        \r\n        supportsSynch() { return false; }\r\n        \r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty(cb) {\r\n            if (this._cache) {\r\n                this._cache.removeAll();\r\n            }\r\n            this.store.clear((e) => {\r\n                if (noError(e, cb)) {\r\n                    // INVARIANT: Root always exists.\r\n                    this.makeRootDirectory(cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        rename(oldPath, newPath, cb) {\r\n            // TODO: Make rename compatible with the cache.\r\n            if (this._cache) {\r\n                // Clear and disable cache during renaming process.\r\n                const c = this._cache;\r\n                this._cache = null;\r\n                c.removeAll();\r\n                const oldCb = cb;\r\n                cb = (e) => {\r\n                    // Restore empty cache.\r\n                    this._cache = c;\r\n                    oldCb(e);\r\n                };\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            const oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath);\r\n            const newParent = paths.dirname(newPath), newName = paths.basename(newPath);\r\n            const inodes = {};\r\n            const lists = {};\r\n            let errorOccurred = false;\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                return cb(new FileError(ErrorCodes.EBUSY, oldParent));\r\n            }\r\n            /**\r\n             * Responsible for Phase 2 of the rename operation: Modifying and\r\n             * committing the directory listings. Called once we have successfully\r\n             * retrieved both the old and new parent's inodes and listings.\r\n             */\r\n            const theOleSwitcharoo = () => {\r\n                // Sanity check: Ensure both paths are present, and no error has occurred.\r\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\r\n                    return;\r\n                }\r\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\r\n                // Delete file from old parent.\r\n                if (!oldParentList[oldName]) {\r\n                    cb(FileError.ENOENT(oldPath));\r\n                }\r\n                else {\r\n                    const fileId = oldParentList[oldName];\r\n                    delete oldParentList[oldName];\r\n                    // Finishes off the renaming process by adding the file to the new\r\n                    // parent.\r\n                    const completeRename = () => {\r\n                        newParentList[newName] = fileId;\r\n                        // Commit old parent's list.\r\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (oldParent === newParent) {\r\n                                    // DONE!\r\n                                    tx.commit(cb);\r\n                                }\r\n                                else {\r\n                                    // Commit new parent's list.\r\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.commit(cb);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    };\r\n                    if (newParentList[newName]) {\r\n                        // 'newPath' already exists. Check if it's a file or a directory, and\r\n                        // act accordingly.\r\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (inode.isFile()) {\r\n                                    // Delete the file and continue.\r\n                                    tx.del(inode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.del(newParentList[newName], (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    completeRename();\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Can't overwrite a directory using rename.\r\n                                    tx.abort((e) => {\r\n                                        cb(FileError.EPERM(newPath));\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeRename();\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Grabs a path's inode and directory listing, and shoves it into the\r\n             * inodes and lists hashes.\r\n             */\r\n            const processInodeAndListings = (p) => {\r\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\r\n                    if (e) {\r\n                        if (!errorOccurred) {\r\n                            errorOccurred = true;\r\n                            tx.abort(() => {\r\n                                cb(e);\r\n                            });\r\n                        }\r\n                        // If error has occurred already, just stop here.\r\n                    }\r\n                    else {\r\n                        inodes[p] = node;\r\n                        lists[p] = dirList;\r\n                        theOleSwitcharoo();\r\n                    }\r\n                });\r\n            };\r\n            processInodeAndListings(oldParent);\r\n            if (oldParent !== newParent) {\r\n                processInodeAndListings(newParent);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, inode.toStats());\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flag, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\r\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\r\n                }\r\n            });\r\n        }\r\n\r\n        openFile(p, flag, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            // Step 1: Grab the file's inode.\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    // Step 2: Grab the file's data.\r\n                    tx.get(inode.id, (e, data) => {\r\n                        if (noError(e, cb)) {\r\n                            if (data === undefined) {\r\n                                cb(FileError.ENOENT(p));\r\n                            }\r\n                            else {\r\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        unlink(p, cb) {\r\n            this.removeEntry(p, false, cb);\r\n        }\r\n        \r\n        rmdir(p, cb) {\r\n            // Check first if directory is empty.\r\n            this.readdir(p, (err, files) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(p));\r\n                }\r\n                else {\r\n                    this.removeEntry(p, true, cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        mkdir(p, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\r\n        }\r\n        \r\n        readdir(p, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, Object.keys(dirListing));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        \r\n        _sync(p, data, stats, cb) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            // Step 1: Get the file node's ID.\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, fileInodeId) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    // Step 2: Get the file inode.\r\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            const inodeChanged = fileInode.update(stats);\r\n                            // Step 3: Sync the data.\r\n                            tx.put(fileInode.id, data, true, (e) => {\r\n                                if (noErrorTx(e, tx, cb)) {\r\n                                    // Step 4: Sync the metadata (if it changed)!\r\n                                    if (inodeChanged) {\r\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                tx.commit(cb);\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        // No need to sync metadata; return.\r\n                                        tx.commit(cb);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory(cb) {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            tx.get(ROOT_NODE_ID, (e, data) => {\r\n                if (e || data === undefined) {\r\n                    // Create new inode.\r\n                    const currTime = (new Date()).getTime(), \r\n                    // Mode 0666\r\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                    // If the root doesn't exist, the first random ID shouldn't exist,\r\n                    // either.\r\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\r\n                                if (e) {\r\n                                    tx.abort(() => { cb(e); });\r\n                                }\r\n                                else {\r\n                                    tx.commit(cb);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // We're good.\r\n                    tx.commit(cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @param cb Passed an error or the ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename, cb) {\r\n            if (this._cache) {\r\n                const id = this._cache.get(paths.join(parent, filename));\r\n                if (id) {\r\n                    return cb(null, id);\r\n                }\r\n            }\r\n            const handleDirectoryListings = (e, inode, dirList) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (dirList[filename]) {\r\n                    const id = dirList[filename];\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), id);\r\n                    }\r\n                    cb(null, id);\r\n                }\r\n                else {\r\n                    cb(FileError.ENOENT(paths.resolve(parent, filename)));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), ROOT_NODE_ID);\r\n                    }\r\n                    cb(null, ROOT_NODE_ID);\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root node.\r\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\r\n                        if (noError(e, cb)) {\r\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\r\n                                // handle_directory_listings will handle e for us.\r\n                                handleDirectoryListings(e, inode, dirList);\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // Get the parent directory's INode, and find the file in its directory\r\n                // listing.\r\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @param cb Passed an error or the Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p, cb) {\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, id) => {\r\n                if (noError(e, cb)) {\r\n                    this.getINode(tx, p, id, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         * @param cb Passed an error or the inode under the given id.\r\n         */\r\n        getINode(tx, p, id, cb) {\r\n            tx.get(id, (e, data) => {\r\n                if (noError(e, cb)) {\r\n                    if (data === undefined) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    else {\r\n                        cb(null, Inode.fromBuffer(data));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode, cb) {\r\n            if (!inode.isDirectory()) {\r\n                cb(FileError.ENOTDIR(p));\r\n            }\r\n            else {\r\n                tx.get(inode.id, (e, data) => {\r\n                    if (noError(e, cb)) {\r\n                        try {\r\n                            cb(null, JSON.parse(data.toString()));\r\n                        }\r\n                        catch (e) {\r\n                            // Occurs when data is undefined, or corresponds to something other\r\n                            // than a directory listing. The latter should never occur unless\r\n                            // the file system is corrupted.\r\n                            cb(FileError.ENOENT(p));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Given a path to a directory, retrieves the corresponding INode and\r\n         * directory listing.\r\n         */\r\n        findINodeAndDirListing(tx, p, cb) {\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, listing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, inode, listing);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Adds a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @param cb Passed an error or the GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data, cb) {\r\n            let retries = 0, currId;\r\n            const reroll = () => {\r\n                if (++retries === 5) {\r\n                    // Max retries hit. Return with an error.\r\n                    cb(new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.'));\r\n                }\r\n                else {\r\n                    // Try again.\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false, (e, committed) => {\r\n                        if (e || !committed) {\r\n                            reroll();\r\n                        }\r\n                        else {\r\n                            // Successfully stored under 'currId'.\r\n                            cb(null, currId);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            reroll();\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @param cb Passed an error or the Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data, cb) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                return cb(FileError.EEXIST(p));\r\n            }\r\n            // Let's build a pyramid of code!\r\n            // Step 1: Get the parent directory's inode and directory listing\r\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (dirListing[fname]) {\r\n                        // File already exists.\r\n                        tx.abort(() => {\r\n                            cb(FileError.EEXIST(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Step 2: Commit data to store.\r\n                        this.addNewNode(tx, data, (e, dataId) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                // Step 3: Commit the file's inode to the store.\r\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\r\n                                    if (noErrorTx(e, tx, cb)) {\r\n                                        // Step 4: Update parent directory's listing.\r\n                                        dirListing[fname] = fileInodeId;\r\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                // Step 5: Commit and return the new inode.\r\n                                                tx.commit((e) => {\r\n                                                    if (noErrorTx(e, tx, cb)) {\r\n                                                        cb(null, fileInode);\r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir, cb) {\r\n            // Eagerly delete from cache (harmless even if removal fails)\r\n            if (this._cache) {\r\n                this._cache.remove(p);\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), fileName = paths.basename(p);\r\n            // Step 1: Get parent directory's node and directory listing.\r\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (!parentListing[fileName]) {\r\n                        tx.abort(() => {\r\n                            cb(FileError.ENOENT(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Remove from directory listing of parent.\r\n                        const fileNodeId = parentListing[fileName];\r\n                        delete parentListing[fileName];\r\n                        // Step 2: Get file inode.\r\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (!isDir && fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.EISDIR(p));\r\n                                    });\r\n                                }\r\n                                else if (isDir && !fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.ENOTDIR(p));\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Step 3: Delete data.\r\n                                    tx.del(fileNode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            // Step 4: Delete node.\r\n                                            tx.del(fileNodeId, (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    // Step 5: Update directory listing.\r\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\r\n                                                        if (noErrorTx(e, tx, cb)) {\r\n                                                            tx.commit(cb);\r\n                                                        }\r\n                                                    });\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    return  files.providers.AsyncKeyValueProvider = AsyncKeyValueProvider;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-ro-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils'\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            this.tx = tx;\r\n            this.store = store;\r\n        }\r\n        get(key, cb) {\r\n            try {\r\n                const r = this.store.get(key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    // IDB returns the value 'undefined' when you try to get keys that\r\n                    // don't exist. The caller expects this behavior.\r\n                    const result = event.target.result;\r\n                    if (result === undefined) {\r\n                        cb(null, result);\r\n                    }\r\n                    else {\r\n                        // IDB data is stored as an ArrayBuffer\r\n                        cb(null, arrayBuffer2Buffer(result));\r\n                    }\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return IndexedDBROTransaction;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-rw-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils',\r\n    \"./indexed-db-ro-transaction\"\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils,IndexedDBROTransaction) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            super(tx, store);\r\n        }\r\n        put(key, data, overwrite, cb) {\r\n            try {\r\n                const arraybuffer = buffer2ArrayBuffer(data);\r\n                let r;\r\n                // Note: 'add' will never overwrite an existing key.\r\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\r\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb(null, true);\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        del(key, cb) {\r\n            try {\r\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\r\n                // like this.\r\n                // http://stackoverflow.com/a/26479152\r\n                const r = this.store['delete'](key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb();\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        commit(cb) {\r\n            // Return to the event loop to commit the transaction.\r\n            setTimeout(cb, 0);\r\n        }\r\n        abort(cb) {\r\n            let _e = null;\r\n            try {\r\n                this.tx.abort();\r\n            }\r\n            catch (e) {\r\n                _e = convertError(e);\r\n            }\r\n            finally {\r\n                cb(_e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBRWTransaction;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-store',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    class IndexedDBStore {\r\n        constructor(db, storeName) {\r\n            this.db = db;\r\n            this.storeName = storeName;\r\n        }\r\n        static Create(storeName, cb) {\r\n            const openReq = indexedDB.open(storeName, 1);\r\n            openReq.onupgradeneeded = (event) => {\r\n                const db = event.target.result;\r\n                // Huh. This should never happen; we're at version 1. Why does another\r\n                // database exist?\r\n                if (db.objectStoreNames.contains(storeName)) {\r\n                    db.deleteObjectStore(storeName);\r\n                }\r\n                db.createObjectStore(storeName);\r\n            };\r\n            openReq.onsuccess = (event) => {\r\n                cb(null, new IndexedDBStore(event.target.result, storeName));\r\n            };\r\n            openReq.onerror = onErrorHandler(cb, ErrorCodes.EACCES);\r\n        }\r\n        name() {\r\n            return IndexedDBProvider.Name + \" - \" + this.storeName;\r\n        }\r\n        clear(cb) {\r\n            try {\r\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\r\n                r.onsuccess = (event) => {\r\n                    // Use setTimeout to commit transaction.\r\n                    setTimeout(cb, 0);\r\n                };\r\n                r.onerror = onErrorHandler(cb);\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        beginTransaction(type = 'readonly') {\r\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\r\n            if (type === 'readwrite') {\r\n                return new IndexedDBRWTransaction(tx, objectStore);\r\n            }\r\n            else if (type === 'readonly') {\r\n                return new IndexedDBROTransaction(tx, objectStore);\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Invalid transaction type.');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBStore;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-provider',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    \"../registry\",\r\n    '../../utils',\r\n    \"./indexed-db-store\",\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  registry,utils,IndexedDBStore,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * A file system that uses the IndexedDB key value file system.\r\n     */\r\n    class IndexedDBProvider extends AsyncKeyValueProvider {\r\n        constructor(cacheSize) {\r\n            super(cacheSize);\r\n        }\r\n        /**\r\n         * Constructs an IndexedDB file system with the given options.\r\n         */\r\n        static Create(opts = {}, cb) {\r\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\r\n                if (store) {\r\n                    const idbfs = new IndexedDBProvider(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\r\n                    idbfs.init(store, (e) => {\r\n                        if (e) {\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            cb(null, idbfs);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        static isAvailable() {\r\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\r\n            // In Firefox, it throws an exception.\r\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\r\n            // Untested: Opera, IE.\r\n            try {\r\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    IndexedDBProvider.Name = \"IndexedDB\";\r\n    IndexedDBProvider.Options = {\r\n        storeName: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\r\n        },\r\n        cacheSize: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\r\n        }\r\n    };\r\n\r\n\r\n    IndexedDBProvider.IndexedDBROTransaction = IndexedDBROTransaction;\r\n    IndexedDBProvider.IndexedDBRWTransaction = IndexedDBRWTransaction;\r\n    IndexedDBProvider.IndexedDBStore = IndexedDBStore;\r\n\r\n    registry.add(\"indexedDB\",IndexedDBProvider);\r\n\r\n    return IndexedDBProvider;\r\n});\ndefine('skylark-data-files/providers/synchronous-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils',\r\n    \"./base-provider\"\r\n], function (Buffer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils,BaseProvider) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Implements the asynchronous API in terms of the synchronous API.\r\n     * @class SynchronousProvider\r\n     */\r\n    class SynchronousProvider extends BaseProvider {\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            try {\r\n                this.renameSync(oldPath, newPath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            try {\r\n                cb(null, this.statSync(p, isLstat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        open(p, flags, mode, cb) {\r\n            try {\r\n                cb(null, this.openSync(p, flags, mode));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            try {\r\n                this.unlinkSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            try {\r\n                this.rmdirSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            try {\r\n                this.mkdirSync(p, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            try {\r\n                cb(null, this.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            try {\r\n                this.chmodSync(p, isLchmod, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            try {\r\n                this.chownSync(p, isLchown, uid, gid);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            try {\r\n                this.utimesSync(p, atime, mtime);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            try {\r\n                this.linkSync(srcpath, dstpath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            try {\r\n                this.symlinkSync(srcpath, dstpath, type);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readlink(p, cb) {\r\n            try {\r\n                cb(null, this.readlinkSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SynchronousProvider =  SynchronousProvider;\r\n});\ndefine('skylark-data-files/providers/sync-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"./base-provider\",\r\n    \"./synchronous-provider\",\r\n    '../utils'\r\n], function (GenerateRandomID, Buffer,paths,files,ErrorCodes, FileError,BaseProvider, SynchronousProvider,  utils) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n\r\n    /**\r\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\r\n     * underlying key-value store.\r\n     *\r\n     * We use a unique ID for each node in the file system. The root node has a\r\n     * fixed ID.\r\n     * @todo Introduce Node ID caching.\r\n     * @todo Check modes.\r\n     */\r\n    class SyncKeyValueProvider extends SynchronousProvider {\r\n        static isAvailable() { return true; }\r\n        constructor(options) {\r\n            super();\r\n            this.store = options.store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        getName() { return this.store.name(); }\r\n        isReadOnly() { return false; }\r\n        supportsSymlinks() { return false; }\r\n        supportsProps() { return false; }\r\n        supportsSynch() { return true; }\r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty() {\r\n            this.store.clear();\r\n            // INVARIANT: Root always exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            const tx = this.store.beginTransaction('readwrite'), oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath), newParent = paths.dirname(newPath), newName = paths.basename(newPath), \r\n            // Remove oldPath from parent's directory listing.\r\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\r\n            if (!oldDirList[oldName]) {\r\n                throw FileError.ENOENT(oldPath);\r\n            }\r\n            const nodeId = oldDirList[oldName];\r\n            delete oldDirList[oldName];\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                throw new FileError(ErrorCodes.EBUSY, oldParent);\r\n            }\r\n            // Add newPath to parent's directory listing.\r\n            let newDirNode, newDirList;\r\n            if (newParent === oldParent) {\r\n                // Prevent us from re-grabbing the same directory listing, which still\r\n                // contains oldName.\r\n                newDirNode = oldDirNode;\r\n                newDirList = oldDirList;\r\n            }\r\n            else {\r\n                newDirNode = this.findINode(tx, newParent);\r\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\r\n            }\r\n            if (newDirList[newName]) {\r\n                // If it's a file, delete it.\r\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\r\n                if (newNameNode.isFile()) {\r\n                    try {\r\n                        tx.del(newNameNode.id);\r\n                        tx.del(newDirList[newName]);\r\n                    }\r\n                    catch (e) {\r\n                        tx.abort();\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    // If it's a directory, throw a permissions error.\r\n                    throw FileError.EPERM(newPath);\r\n                }\r\n            }\r\n            newDirList[newName] = nodeId;\r\n            // Commit the two changed directory listings.\r\n            try {\r\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\r\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        statSync(p, isLstat) {\r\n            // Get the inode to the item, convert it into a Stats object.\r\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\r\n        }\r\n        createFileSync(p, flag, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\r\n            // Open the file.\r\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\r\n        }\r\n        openFileSync(p, flag) {\r\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\r\n        }\r\n        unlinkSync(p) {\r\n            this.removeEntry(p, false);\r\n        }\r\n        rmdirSync(p) {\r\n            // Check first if directory is empty.\r\n            if (this.readdirSync(p).length > 0) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                this.removeEntry(p, true);\r\n            }\r\n        }\r\n        mkdirSync(p, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\r\n        }\r\n        readdirSync(p) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\r\n        }\r\n        _syncSync(p, data, stats) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite'), \r\n            // We use the _findInode helper because we actually need the INode id.\r\n            fileInodeId = this._findINode(tx, paths.dirname(p), paths.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\r\n            try {\r\n                // Sync data.\r\n                tx.put(fileInode.id, data, true);\r\n                // Sync metadata.\r\n                if (inodeChanged) {\r\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\r\n                }\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory() {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            if (tx.get(ROOT_NODE_ID) === undefined) {\r\n                // Create new inode.\r\n                const currTime = (new Date()).getTime(), \r\n                // Mode 0666\r\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                // If the root doesn't exist, the first random ID shouldn't exist,\r\n                // either.\r\n                tx.put(dirInode.id, getEmptyDirNode(), false);\r\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\r\n                tx.commit();\r\n            }\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @return string The ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename) {\r\n            const readDirectory = (inode) => {\r\n                // Get the root's directory listing.\r\n                const dirList = this.getDirListing(tx, parent, inode);\r\n                // Get the file's ID.\r\n                if (dirList[filename]) {\r\n                    return dirList[filename];\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(paths.resolve(parent, filename));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    return ROOT_NODE_ID;\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root ndoe.\r\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\r\n                }\r\n            }\r\n            else {\r\n                return readDirectory(this.getINode(tx, parent + paths.sep + filename, this._findINode(tx, paths.dirname(parent), paths.basename(parent))));\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @return The Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p) {\r\n            return this.getINode(tx, p, this._findINode(tx, paths.dirname(p), paths.basename(p)));\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         */\r\n        getINode(tx, p, id) {\r\n            const inode = tx.get(id);\r\n            if (inode === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return Inode.fromBuffer(inode);\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode) {\r\n            if (!inode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            const data = tx.get(inode.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return JSON.parse(data.toString());\r\n        }\r\n        /**\r\n         * Creates a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @return The GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data) {\r\n            const retries = 0;\r\n            let currId;\r\n            while (retries < 5) {\r\n                try {\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false);\r\n                    return currId;\r\n                }\r\n                catch (e) {\r\n                    // Ignore and reroll.\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.');\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @return The Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            // Check if file already exists.\r\n            if (dirListing[fname]) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            let fileNode;\r\n            try {\r\n                // Commit data.\r\n                const dataId = this.addNewNode(tx, data);\r\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                // Commit file node.\r\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\r\n                // Update and commit parent directory listing.\r\n                dirListing[fname] = fileNodeId;\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n            return fileNode;\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir) {\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = paths.basename(p);\r\n            if (!parentListing[fileName]) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            // Remove from directory listing of parent.\r\n            const fileNodeId = parentListing[fileName];\r\n            delete parentListing[fileName];\r\n            // Get file inode.\r\n            const fileNode = this.getINode(tx, p, fileNodeId);\r\n            if (!isDir && fileNode.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            else if (isDir && !fileNode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            try {\r\n                // Delete data.\r\n                tx.del(fileNode.id);\r\n                // Delete node.\r\n                tx.del(fileNodeId);\r\n                // Update directory listing.\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            // Success.\r\n            tx.commit();\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SyncKeyValueProvider = SyncKeyValueProvider;\r\n});\ndefine('skylark-data-files/providers/simple-sync-rw-transaction',[\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error'\r\n], function (files, ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A simple RW transaction for simple synchronous key-value stores.\r\n     */\r\n    class SimpleSyncRWTransaction {\r\n        constructor(store) {\r\n            this.store = store;\r\n            /**\r\n             * Stores data in the keys we modify prior to modifying them.\r\n             * Allows us to roll back commits.\r\n             */\r\n            this.originalData = {};\r\n            /**\r\n             * List of keys modified in this transaction, if any.\r\n             */\r\n            this.modifiedKeys = [];\r\n        }\r\n        get(key) {\r\n            const val = this.store.get(key);\r\n            this.stashOldValue(key, val);\r\n            return val;\r\n        }\r\n        put(key, data, overwrite) {\r\n            this.markModified(key);\r\n            return this.store.put(key, data, overwrite);\r\n        }\r\n        del(key) {\r\n            this.markModified(key);\r\n            this.store.del(key);\r\n        }\r\n        commit() { }\r\n        abort() {\r\n            // Rollback old values.\r\n            for (const key of this.modifiedKeys) {\r\n                const value = this.originalData[key];\r\n                if (!value) {\r\n                    // Key didn't exist.\r\n                    this.store.del(key);\r\n                }\r\n                else {\r\n                    // Key existed. Store old value.\r\n                    this.store.put(key, value, true);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Stashes given key value pair into `originalData` if it doesn't already\r\n         * exist. Allows us to stash values the program is requesting anyway to\r\n         * prevent needless `get` requests if the program modifies the data later\r\n         * on during the transaction.\r\n         */\r\n        stashOldValue(key, value) {\r\n            // Keep only the earliest value in the transaction.\r\n            if (!this.originalData.hasOwnProperty(key)) {\r\n                this.originalData[key] = value;\r\n            }\r\n        }\r\n        /**\r\n         * Marks the given key as modified, and stashes its value if it has not been\r\n         * stashed already.\r\n         */\r\n        markModified(key) {\r\n            if (this.modifiedKeys.indexOf(key) === -1) {\r\n                this.modifiedKeys.push(key);\r\n                if (!this.originalData.hasOwnProperty(key)) {\r\n                    this.originalData[key] = this.store.get(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return files.providers.SimpleSyncRWTransaction = SimpleSyncRWTransaction;\r\n});\ndefine('skylark-data-files/providers/inmemory/in-memory-store',[\r\n    '../simple-sync-rw-transaction'\r\n], function (SimpleSyncRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple in-memory key-value store backed by a JavaScript object.\r\n     */\r\n    class InMemoryStore {\r\n        constructor() {\r\n            this.store = {};\r\n        }\r\n        clear() { this.store = {}; }\r\n        beginTransaction(type) {\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            return this.store[key];\r\n        }\r\n        put(key, data, overwrite) {\r\n            if (!overwrite && this.store.hasOwnProperty(key)) {\r\n                return false;\r\n            }\r\n            this.store[key] = data;\r\n            return true;\r\n        }\r\n        del(key) {\r\n            delete this.store[key];\r\n        }\r\n    }\r\n\r\n\r\n    return InMemoryStore;\r\n});\ndefine('skylark-data-files/providers/inmemory/in-memory-provider',[\n    '../sync-key-value-provider',\n    \"./in-memory-store\"\n], function (SyncKeyValueProvider,InMemoryStore) {\n    'use strict';\n\n    /**\n     * A simple in-memory file system backed by an InMemoryStore.\n     * Files are not persisted across page loads.\n     */\n    class InMemoryProvider extends SyncKeyValueProvider {\n        name() { return InMemoryProvider.Name; }\n        constructor() {\n            super({ store: new InMemoryStore() });\n        }\n        /**\n         * Creates an InMemoryProvider instance.\n         */\n        static Create(options, cb) {\n            cb(null, new InMemoryProvider());\n        }\n    }\n    InMemoryProvider.Name = \"InMemory\";\n    InMemoryProvider.Options = {};\n\n    InMemoryProvider.InMemoryStore = InMemoryStore;\n\n    return InMemoryProvider;\n});\ndefine('skylark-data-files/providers/localstorage/local-storage-store',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../simple-sync-rw-transaction',\r\n    '../../error-codes',\r\n    '../../file-error',\r\n], function (Buffer,SimpleSyncRWTransaction, ErrorCodes,FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A synchronous key-value store backed by localStorage.\r\n     */\r\n    class LocalStorageStore {\r\n        name() {\r\n            return LocalStorageProvider.Name;\r\n        }\r\n        clear() {\r\n            window.localStorage.clear();\r\n        }\r\n        beginTransaction(type) {\r\n            // No need to differentiate.\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            try {\r\n                const data = window.localStorage.getItem(key);\r\n                if (data !== null) {\r\n                    return Buffer.from(data, binaryEncoding);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Do nothing.\r\n            }\r\n            // Key doesn't exist, or a failure occurred.\r\n            return undefined;\r\n        }\r\n        put(key, data, overwrite) {\r\n            try {\r\n                if (!overwrite && window.localStorage.getItem(key) !== null) {\r\n                    // Don't want to overwrite the key!\r\n                    return false;\r\n                }\r\n                window.localStorage.setItem(key, data.toString(binaryEncoding));\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.ENOSPC, \"LocalStorage is full.\");\r\n            }\r\n        }\r\n        del(key) {\r\n            try {\r\n                window.localStorage.removeItem(key);\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.EIO, \"Unable to delete key \" + key + \": \" + e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return LocalStorageStore;\r\n});\ndefine('skylark-data-files/providers/localstorage/local-storage-provider',[\n    \"skylark-langx-binary/buffer\",\n    '../sync-key-value-provider',\n    '../../error-codes',\n    '../../file-error',\n    \"./local-storage-store\"\n], function (Buffer,SyncKeyValueProvider, ErrorCodes,FileError,LocalStorageStore) {\n    'use strict';\n\n\n    /**\n     * Some versions of FF and all versions of IE do not support the full range of\n     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\n     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\n     * @hidden\n     */\n    let supportsBinaryString = false, binaryEncoding;\n    try {\n        window.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\n        supportsBinaryString = window.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\n    }\n    catch (e) {\n        // IE throws an exception.\n        supportsBinaryString = false;\n    }\n    \n    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';\n    if (!Buffer.isEncoding(binaryEncoding)) {\n        // Fallback for non BrowserFS implementations of buffer that lack a\n        // binary_string format.\n        binaryEncoding = \"base64\";\n    }\n\n    /**\n     * A synchronous file system backed by localStorage. Connects our\n     * LocalStorageStore to our SyncKeyValueProvider.\n     */\n    class LocalStorageProvider extends SyncKeyValueProvider {\n        /**\n         * Creates a new LocalStorage file system using the contents of `localStorage`.\n         */\n        constructor() { super({ store: new LocalStorageStore() }); }\n        /**\n         * Creates a LocalStorageProvider instance.\n         */\n        static Create(options, cb) {\n            cb(null, new LocalStorageProvider());\n        }\n        static isAvailable() {\n            return typeof window.localStorage !== 'undefined';\n        }\n    }\n\n    LocalStorageProvider.Name = \"LocalStorage\";\n    LocalStorageProvider.Options = {};\n    \n    LocalStorageProvider.LocalStorageStore = LocalStorageStore;\n\n    return LocalStorageProvider;\n});\ndefine('skylark-data-files/providers/mutex',[\r\n    \"skylark-langx-funcs/defer\"\r\n], function (defer) {\r\n    'use strict';\r\n    /**\r\n     * Non-recursive mutex\r\n     * @hidden\r\n     */\r\n    class Mutex {\r\n        constructor() {\r\n            this._locked = false;\r\n            this._waiters = [];\r\n        }\r\n        lock(cb) {\r\n            if (this._locked) {\r\n                this._waiters.push(cb);\r\n                return;\r\n            }\r\n            this._locked = true;\r\n            cb();\r\n        }\r\n        unlock() {\r\n            if (!this._locked) {\r\n                throw new Error('unlock of a non-locked mutex');\r\n            }\r\n            const next = this._waiters.shift();\r\n            // don't unlock - we want to queue up next for the\r\n            // _end_ of the current task execution, but we don't\r\n            // want it to be called inline with whatever the\r\n            // current stack is.  This way we still get the nice\r\n            // behavior that an unlock immediately followed by a\r\n            // lock won't cause starvation.\r\n            if (next) {\r\n                defer(next);\r\n                return;\r\n            }\r\n            this._locked = false;\r\n        }\r\n        tryLock() {\r\n            if (this._locked) {\r\n                return false;\r\n            }\r\n            this._locked = true;\r\n            return true;\r\n        }\r\n        isLocked() {\r\n            return this._locked;\r\n        }\r\n    }\r\n\r\n    return Mutex;\r\n});\ndefine('skylark-data-files/providers/locked-provider',[\r\n    \"../files\",\r\n    './mutex'\r\n], function (files,Mutex) {\r\n    'use strict';\r\n    /**\r\n     * This class serializes access to an underlying async filesystem.\r\n     * For example, on an OverlayFS instance with an async lower\r\n     * directory operations like rename and rmdir may involve multiple\r\n     * requests involving both the upper and lower filesystems -- they\r\n     * are not executed in a single atomic step.  OverlayFS uses this\r\n     * LockedProvider to avoid having to reason about the correctness of\r\n     * multiple requests interleaving.\r\n     */\r\n    class LockedProvider {\r\n        constructor(fs) {\r\n            this._fs = fs;\r\n            this._mu = new Mutex();\r\n        }\r\n        getName() {\r\n            return 'LockedProvider<' + this._fs.getName() + '>';\r\n        }\r\n        getFSUnlocked() {\r\n            return this._fs;\r\n        }\r\n        diskSpace(p, cb) {\r\n            // FIXME: should this lock?\r\n            this._fs.diskSpace(p, cb);\r\n        }\r\n        isReadOnly() {\r\n            return this._fs.isReadOnly();\r\n        }\r\n        supportsLinks() {\r\n            return this._fs.supportsLinks();\r\n        }\r\n        supportsProps() {\r\n            return this._fs.supportsProps();\r\n        }\r\n        supportsSynch() {\r\n            return this._fs.supportsSynch();\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rename(oldPath, newPath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.renameSync(oldPath, newPath);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.stat(p, isLstat, (err, stat) => {\r\n                    this._mu.unlock();\r\n                    cb(err, stat);\r\n                });\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.statSync(p, isLstat);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.open(p, flag, mode, (err, fd) => {\r\n                    this._mu.unlock();\r\n                    cb(err, fd);\r\n                });\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.openSync(p, flag, mode);\r\n        }\r\n        unlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.unlink(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.unlinkSync(p);\r\n        }\r\n        rmdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rmdir(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.rmdirSync(p);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.mkdir(p, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.mkdirSync(p, mode);\r\n        }\r\n        readdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readdir(p, (err, files) => {\r\n                    this._mu.unlock();\r\n                    cb(err, files);\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readdirSync(p);\r\n        }\r\n        exists(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.exists(p, (exists) => {\r\n                    this._mu.unlock();\r\n                    cb(exists);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.existsSync(p);\r\n        }\r\n        realpath(p, cache, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\r\n                    this._mu.unlock();\r\n                    cb(err, resolvedPath);\r\n                });\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.realpathSync(p, cache);\r\n        }\r\n        truncate(p, len, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.truncate(p, len, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        truncateSync(p, len) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.truncateSync(p, len);\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\r\n                    this._mu.unlock();\r\n                    cb(err, data);\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readFileSync(fname, encoding, flag);\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chmod(p, isLchmod, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chmodSync(p, isLchmod, mode);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chownSync(p, isLchown, uid, gid);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.utimes(p, atime, mtime, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.utimesSync(p, atime, mtime);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.link(srcpath, dstpath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        readlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readlink(p, (err, linkString) => {\r\n                    this._mu.unlock();\r\n                    cb(err, linkString);\r\n                });\r\n            });\r\n        }\r\n        readlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readlinkSync(p);\r\n        }\r\n    }\r\n\r\n    return files.providers.LockedProvider = LockedProvider;\r\n});\ndefine('skylark-data-files/providers/overlay/overlay-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n\r\n    /**\r\n     * Overlays a RO file to make it writable.\r\n     */\r\n    class OverlayFile extends PreloadFile {\r\n        constructor(fs, path, flag, stats, data) {\r\n            super(fs, path, flag, stats, data);\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                cb(null);\r\n                return;\r\n            }\r\n            this._fs._syncAsync(this, (err) => {\r\n                this.resetDirty();\r\n                cb(err);\r\n            });\r\n        }\r\n        syncSync() {\r\n            if (this.isDirty()) {\r\n                this._fs._syncSync(this);\r\n                this.resetDirty();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n        closeSync() {\r\n            this.syncSync();\r\n        }\r\n    }\r\n\r\n\r\n    return OverlayFile;\r\n});\ndefine('skylark-data-files/providers/overlay/unlocked-overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"./overlay-file\"\r\n], function (paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,OverlayFile) {\r\n    /**\r\n     * @hidden\r\n     */\r\n    const deletionLogPath = '/.deletedFiles.log';\r\n\r\n    /**\r\n     * Given a read-only mode, makes it writable.\r\n     * @hidden\r\n     */\r\n    function makeModeWritable(mode) {\r\n        return 0o222 | mode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFlag(f) {\r\n        return FileFlag.getFileFlag(f);\r\n    }    \r\n     /**\r\n     * *INTERNAL, DO NOT USE DIRECTLY!*\r\n     *\r\n     * Core OverlayProviderclass that contains no locking whatsoever. We wrap these objects\r\n     * in a LockedFS to prevent races.\r\n     */\r\n    class UnlockedOverlayProvider extends BaseProvider {\r\n        constructor(writable, readable) {\r\n            super();\r\n            this._isInitialized = false;\r\n            this._initializeCallbacks = [];\r\n            this._deletedFiles = {};\r\n            this._deleteLog = '';\r\n            // If 'true', we have scheduled a delete log update.\r\n            this._deleteLogUpdatePending = false;\r\n            // If 'true', a delete log update is needed after the scheduled delete log\r\n            // update finishes.\r\n            this._deleteLogUpdateNeeded = false;\r\n            // If there was an error updating the delete log...\r\n            this._deleteLogError = null;\r\n            this._writable = writable;\r\n            this._readable = readable;\r\n            if (this._writable.isReadOnly()) {\r\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getOverlayedProviders() {\r\n            return {\r\n                readable: this._readable,\r\n                writable: this._writable\r\n            };\r\n        }\r\n        _syncAsync(file, cb) {\r\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\r\n            });\r\n        }\r\n        _syncSync(file) {\r\n            this.createParentDirectories(file.getPath());\r\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\r\n        }\r\n        getName() {\r\n            return OverlayFS.Name;\r\n        }\r\n        /**\r\n         * **INTERNAL METHOD**\r\n         *\r\n         * Called once to load up metadata stored on the writable file system.\r\n         */\r\n        _initialize(cb) {\r\n            const callbackArray = this._initializeCallbacks;\r\n            const end = (e) => {\r\n                this._isInitialized = !e;\r\n                this._initializeCallbacks = [];\r\n                callbackArray.forEach(((cb) => cb(e)));\r\n            };\r\n            // if we're already initialized, immediately invoke the callback\r\n            if (this._isInitialized) {\r\n                return cb();\r\n            }\r\n            callbackArray.push(cb);\r\n            // The first call to initialize initializes, the rest wait for it to complete.\r\n            if (callbackArray.length !== 1) {\r\n                return;\r\n            }\r\n            // Read deletion log, process into metadata.\r\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\r\n                if (err) {\r\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\r\n                    if (err.errno !== ErrorCode.ENOENT) {\r\n                        return end(err);\r\n                    }\r\n                }\r\n                else {\r\n                    this._deleteLog = data;\r\n                }\r\n                this._reparseDeletionLog();\r\n                end();\r\n            });\r\n        }\r\n        isReadOnly() { return false; }\r\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\r\n        supportsLinks() { return false; }\r\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\r\n        getDeletionLog() {\r\n            return this._deleteLog;\r\n        }\r\n        restoreDeletionLog(log) {\r\n            this._deleteLog = log;\r\n            this._reparseDeletionLog();\r\n            this.updateLog('');\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\r\n                return;\r\n            }\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\r\n            }\r\n            // nothing to do if paths match\r\n            if (oldPath === newPath) {\r\n                return cb();\r\n            }\r\n            this.stat(oldPath, false, (oldErr, oldStats) => {\r\n                if (oldErr) {\r\n                    return cb(oldErr);\r\n                }\r\n                return this.stat(newPath, false, (newErr, newStats) => {\r\n                    const self = this;\r\n                    // precondition: both oldPath and newPath exist and are dirs.\r\n                    // decreases: |files|\r\n                    // Need to move *every file/folder* currently stored on\r\n                    // readable to its new location on writable.\r\n                    function copyDirContents(files) {\r\n                        const file = files.shift();\r\n                        if (!file) {\r\n                            return cb();\r\n                        }\r\n                        const oldFile = paths.resolve(oldPath, file);\r\n                        const newFile = paths.resolve(newPath, file);\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        self.rename(oldFile, newFile, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            copyDirContents(files);\r\n                        });\r\n                    }\r\n                    let mode = 0o777;\r\n                    // from linux's rename(2) manpage: oldpath can specify a\r\n                    // directory.  In this case, newpath must either not exist, or\r\n                    // it must specify an empty directory.\r\n                    if (oldStats.isDirectory()) {\r\n                        if (newErr) {\r\n                            if (newErr.errno !== ErrorCode.ENOENT) {\r\n                                return cb(newErr);\r\n                            }\r\n                            return this._writable.exists(oldPath, (exists) => {\r\n                                // simple case - both old and new are on the writable layer\r\n                                if (exists) {\r\n                                    return this._writable.rename(oldPath, newPath, cb);\r\n                                }\r\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\r\n                                    if (mkdirErr) {\r\n                                        return cb(mkdirErr);\r\n                                    }\r\n                                    this._readable.readdir(oldPath, (err, files) => {\r\n                                        if (err) {\r\n                                            return cb();\r\n                                        }\r\n                                        copyDirContents(files);\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                        mode = newStats.mode;\r\n                        if (!newStats.isDirectory()) {\r\n                            return cb(ApiError.ENOTDIR(newPath));\r\n                        }\r\n                        this.readdir(newPath, (readdirErr, files) => {\r\n                            if (files && files.length) {\r\n                                return cb(ApiError.ENOTEMPTY(newPath));\r\n                            }\r\n                            this._readable.readdir(oldPath, (err, files) => {\r\n                                if (err) {\r\n                                    return cb();\r\n                                }\r\n                                copyDirContents(files);\r\n                            });\r\n                        });\r\n                    }\r\n                    if (newStats && newStats.isDirectory()) {\r\n                        return cb(ApiError.EISDIR(newPath));\r\n                    }\r\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            return this.unlink(oldPath, cb);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            this.checkInitialized();\r\n            this.checkPath(oldPath);\r\n            this.checkPath(newPath);\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot rename deletion log.');\r\n            }\r\n            // Write newPath using oldPath's contents, delete oldPath.\r\n            const oldStats = this.statSync(oldPath, false);\r\n            if (oldStats.isDirectory()) {\r\n                // Optimization: Don't bother moving if old === new.\r\n                if (oldPath === newPath) {\r\n                    return;\r\n                }\r\n                let mode = 0o777;\r\n                if (this.existsSync(newPath)) {\r\n                    const stats = this.statSync(newPath, false);\r\n                    mode = stats.mode;\r\n                    if (stats.isDirectory()) {\r\n                        if (this.readdirSync(newPath).length > 0) {\r\n                            throw ApiError.ENOTEMPTY(newPath);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw ApiError.ENOTDIR(newPath);\r\n                    }\r\n                }\r\n                // Take care of writable first. Move any files there, or create an empty directory\r\n                // if it doesn't exist.\r\n                if (this._writable.existsSync(oldPath)) {\r\n                    this._writable.renameSync(oldPath, newPath);\r\n                }\r\n                else if (!this._writable.existsSync(newPath)) {\r\n                    this._writable.mkdirSync(newPath, mode);\r\n                }\r\n                // Need to move *every file/folder* currently stored on readable to its new location\r\n                // on writable.\r\n                if (this._readable.existsSync(oldPath)) {\r\n                    this._readable.readdirSync(oldPath).forEach((name) => {\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        this.renameSync(paths.resolve(oldPath, name), paths.resolve(newPath, name));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\r\n                    throw ApiError.EISDIR(newPath);\r\n                }\r\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\r\n            }\r\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\r\n                this.unlinkSync(oldPath);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this._writable.stat(p, isLstat, (err, stat) => {\r\n                if (err && err.errno === ErrorCode.ENOENT) {\r\n                    if (this._deletedFiles[p]) {\r\n                        cb(ApiError.ENOENT(p));\r\n                    }\r\n                    this._readable.stat(p, isLstat, (err, stat) => {\r\n                        if (stat) {\r\n                            // Make the oldStat's mode writable. Preserve the topmost\r\n                            // part of the mode, which specifies if it is a file or a\r\n                            // directory.\r\n                            stat = Stats.clone(stat);\r\n                            stat.mode = makeModeWritable(stat.mode);\r\n                        }\r\n                        cb(err, stat);\r\n                    });\r\n                }\r\n                else {\r\n                    cb(err, stat);\r\n                }\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            this.checkInitialized();\r\n            try {\r\n                return this._writable.statSync(p, isLstat);\r\n            }\r\n            catch (e) {\r\n                if (this._deletedFiles[p]) {\r\n                    throw ApiError.ENOENT(p);\r\n                }\r\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\r\n                // Make the oldStat's mode writable. Preserve the topmost part of the\r\n                // mode, which specifies if it is a file or a directory.\r\n                oldStat.mode = makeModeWritable(oldStat.mode);\r\n                return oldStat;\r\n            }\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, stats) => {\r\n                if (stats) {\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this._writable.exists(p, (exists) => {\r\n                                if (exists) {\r\n                                    this._writable.open(p, flag, mode, cb);\r\n                                }\r\n                                else {\r\n                                    // at this point we know the stats object we got is from\r\n                                    // the readable FS.\r\n                                    stats = Stats.clone(stats);\r\n                                    stats.mode = mode;\r\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\r\n                                        if (readFileErr) {\r\n                                            return cb(readFileErr);\r\n                                        }\r\n                                        if (stats.size === -1) {\r\n                                            stats.size = data.length;\r\n                                        }\r\n                                        const f = new OverlayFile(this, p, flag, stats, data);\r\n                                        cb(null, f);\r\n                                    });\r\n                                }\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.EEXIST(p));\r\n                    }\r\n                }\r\n                else {\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                return this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.ENOENT(p));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot open deletion log.');\r\n            }\r\n            if (this.existsSync(p)) {\r\n                switch (flag.pathExistsAction()) {\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    case ActionType.NOP:\r\n                        if (this._writable.existsSync(p)) {\r\n                            return this._writable.openSync(p, flag, mode);\r\n                        }\r\n                        else {\r\n                            // Create an OverlayFile.\r\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\r\n                            const stats = Stats.clone(this._readable.statSync(p, false));\r\n                            stats.mode = mode;\r\n                            return new OverlayFile(this, p, flag, stats, buf);\r\n                        }\r\n                    default:\r\n                        throw ApiError.EEXIST(p);\r\n                }\r\n            }\r\n            else {\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    default:\r\n                        throw ApiError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        return this._writable.unlink(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    this.deletePath(p);\r\n                                }\r\n                                cb(null);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        // if this only exists on the readable FS, add it to the\r\n                        // delete map.\r\n                        this.deletePath(p);\r\n                        cb(null);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.unlinkSync(p);\r\n                }\r\n                // if it still exists add to the delete log\r\n                if (this.existsSync(p)) {\r\n                    this.deletePath(p);\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            const rmdirLower = () => {\r\n                this.readdir(p, (err, files) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    if (files.length) {\r\n                        return cb(ApiError.ENOTEMPTY(p));\r\n                    }\r\n                    this.deletePath(p);\r\n                    cb(null);\r\n                });\r\n            };\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        this._writable.rmdir(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this._readable.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    rmdirLower();\r\n                                }\r\n                                else {\r\n                                    cb();\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        rmdirLower();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.rmdirSync(p);\r\n                }\r\n                if (this.existsSync(p)) {\r\n                    // Check if directory is empty.\r\n                    if (this.readdirSync(p).length > 0) {\r\n                        throw ApiError.ENOTEMPTY(p);\r\n                    }\r\n                    else {\r\n                        this.deletePath(p);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (exists) {\r\n                    return cb(ApiError.EEXIST(p));\r\n                }\r\n                // The below will throw should any of the parent directories\r\n                // fail to exist on _writable.\r\n                this.createParentDirectoriesAsync(p, (err) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this._writable.mkdir(p, mode, cb);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                throw ApiError.EEXIST(p);\r\n            }\r\n            else {\r\n                // The below will throw should any of the parent directories fail to exist\r\n                // on _writable.\r\n                this.createParentDirectories(p);\r\n                this._writable.mkdirSync(p, mode);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, dirStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (!dirStats.isDirectory()) {\r\n                    return cb(ApiError.ENOTDIR(p));\r\n                }\r\n                this._writable.readdir(p, (err, wFiles) => {\r\n                    if (err && err.code !== 'ENOENT') {\r\n                        return cb(err);\r\n                    }\r\n                    else if (err || !wFiles) {\r\n                        wFiles = [];\r\n                    }\r\n                    this._readable.readdir(p, (err, rFiles) => {\r\n                        // if the directory doesn't exist on the lower FS set rFiles\r\n                        // here to simplify the following code.\r\n                        if (err || !rFiles) {\r\n                            rFiles = [];\r\n                        }\r\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\r\n                        const seenMap = {};\r\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\r\n                            // Remove duplicates.\r\n                            const result = !seenMap[fPath];\r\n                            seenMap[fPath] = true;\r\n                            return result;\r\n                        });\r\n                        cb(null, filtered);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            this.checkInitialized();\r\n            const dirStats = this.statSync(p, false);\r\n            if (!dirStats.isDirectory()) {\r\n                throw ApiError.ENOTDIR(p);\r\n            }\r\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\r\n            let contents = [];\r\n            try {\r\n                contents = contents.concat(this._writable.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            try {\r\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            const seenMap = {};\r\n            return contents.filter((fileP) => {\r\n                const result = !seenMap[fileP];\r\n                seenMap[fileP] = true;\r\n                return result;\r\n            });\r\n        }\r\n        exists(p, cb) {\r\n            // Cannot pass an error back to callback, so throw an exception instead\r\n            // if not initialized.\r\n            this.checkInitialized();\r\n            this._writable.exists(p, (existsWritable) => {\r\n                if (existsWritable) {\r\n                    return cb(true);\r\n                }\r\n                this._readable.exists(p, (existsReadable) => {\r\n                    cb(existsReadable && this._deletedFiles[p] !== true);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            this.checkInitialized();\r\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chmod(p, isLchmod, mode, cb);\r\n                }\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chmodSync(p, isLchmod, mode);\r\n            });\r\n        }\r\n        chown(p, isLchmod, uid, gid, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\r\n                }\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chownSync(p, isLchown, uid, gid);\r\n            });\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.utimes(p, atime, mtime, cb);\r\n                }\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.utimesSync(p, atime, mtime);\r\n            });\r\n        }\r\n        deletePath(p) {\r\n            this._deletedFiles[p] = true;\r\n            this.updateLog(`d${p}\\n`);\r\n        }\r\n        updateLog(addition) {\r\n            this._deleteLog += addition;\r\n            if (this._deleteLogUpdatePending) {\r\n                this._deleteLogUpdateNeeded = true;\r\n            }\r\n            else {\r\n                this._deleteLogUpdatePending = true;\r\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\r\n                    this._deleteLogUpdatePending = false;\r\n                    if (e) {\r\n                        this._deleteLogError = e;\r\n                    }\r\n                    else if (this._deleteLogUpdateNeeded) {\r\n                        this._deleteLogUpdateNeeded = false;\r\n                        this.updateLog('');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        _reparseDeletionLog() {\r\n            this._deletedFiles = {};\r\n            this._deleteLog.split('\\n').forEach((path) => {\r\n                // If the log entry begins w/ 'd', it's a deletion.\r\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\r\n            });\r\n        }\r\n        checkInitialized() {\r\n            if (!this._isInitialized) {\r\n                throw new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\");\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                throw e;\r\n            }\r\n        }\r\n        checkInitAsync(cb) {\r\n            if (!this._isInitialized) {\r\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\"));\r\n                return false;\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                cb(e);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        checkPath(p) {\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM(p);\r\n            }\r\n        }\r\n        checkPathAsync(p, cb) {\r\n            if (p === deletionLogPath) {\r\n                cb(ApiError.EPERM(p));\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createParentDirectoriesAsync(p, cb) {\r\n            let parent = paths.dirname(p);\r\n            const toCreate = [];\r\n            const self = this;\r\n            this._writable.stat(parent, false, statDone);\r\n            function statDone(err, stat) {\r\n                if (err) {\r\n                    if (parent === \"/\") {\r\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\r\n                    }\r\n                    else {\r\n                        toCreate.push(parent);\r\n                        parent = paths.dirname(parent);\r\n                        self._writable.stat(parent, false, statDone);\r\n                    }\r\n                }\r\n                else {\r\n                    createParents();\r\n                }\r\n            }\r\n            function createParents() {\r\n                if (!toCreate.length) {\r\n                    return cb();\r\n                }\r\n                const dir = toCreate.pop();\r\n                self._readable.stat(dir, false, (err, stats) => {\r\n                    // stop if we couldn't read the dir\r\n                    if (!stats) {\r\n                        return cb();\r\n                    }\r\n                    self._writable.mkdir(dir, stats.mode, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        createParents();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * With the given path, create the needed parent directories on the writable storage\r\n         * should they not exist. Use modes from the read-only storage.\r\n         */\r\n        createParentDirectories(p) {\r\n            let parent = paths.dirname(p), toCreate = [];\r\n            while (!this._writable.existsSync(parent)) {\r\n                toCreate.push(parent);\r\n                parent = paths.dirname(parent);\r\n            }\r\n            toCreate = toCreate.reverse();\r\n            toCreate.forEach((p) => {\r\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\r\n            });\r\n        }\r\n        /**\r\n         * Helper function:\r\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\r\n         * - Calls f to perform operation on writable.\r\n         */\r\n        operateOnWritable(p, f) {\r\n            if (this.existsSync(p)) {\r\n                if (!this._writable.existsSync(p)) {\r\n                    // File is on readable storage. Copy to writable storage before\r\n                    // changing its mode.\r\n                    this.copyToWritable(p);\r\n                }\r\n                f();\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        operateOnWritableAsync(p, cb) {\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (existsWritable) => {\r\n                    if (existsWritable) {\r\n                        cb();\r\n                    }\r\n                    else {\r\n                        return this.copyToWritableAsync(p, cb);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Copy from readable to writable storage.\r\n         * PRECONDITION: File does not exist on writable storage.\r\n         */\r\n        copyToWritable(p) {\r\n            const pStats = this.statSync(p, false);\r\n            if (pStats.isDirectory()) {\r\n                this._writable.mkdirSync(p, pStats.mode);\r\n            }\r\n            else {\r\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\r\n            }\r\n        }\r\n        copyToWritableAsync(p, cb) {\r\n            this.stat(p, false, (err, pStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (pStats.isDirectory()) {\r\n                    return this._writable.mkdir(p, pStats.mode, cb);\r\n                }\r\n                // need to copy file.\r\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\r\n                });\r\n            });\r\n        }\r\n    }\r\n \r\n\r\n    return UnlockedOverlayProvider;\r\n});\ndefine('skylark-data-files/providers/overlay/overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"../locked-provider\",\r\n    \"./unlocked-overlay-provider\"\r\n], function (paths, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,LockedProvider,UnlockedOverlayProvider) {\r\n\r\n\r\n    /**\r\n     * OverlayProvidermakes a read-only filesystem writable by storing writes on a second,\r\n     * writable file system. Deletes are persisted via metadata stored on the writable\r\n     * file system.\r\n     */\r\n    class OverlayProvider extends LockedProvider {\r\n        /**\r\n         * @param writable The file system to write modified files to.\r\n         * @param readable The file system that initially populates this file system.\r\n         */\r\n        constructor(writable, readable) {\r\n            super(new UnlockedOverlayProvider(writable, readable));\r\n        }\r\n        /**\r\n         * Constructs and initializes an OverlayProviderinstance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                const fs = new OverlayProvider(opts.writable, opts.readable);\r\n                fs._initialize((e) => {\r\n                    cb(e, fs);\r\n                });\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return UnlockedOverlayProvider.isAvailable();\r\n        }\r\n        getOverlayedProviders() {\r\n            return super.getFSUnlocked().getOverlayedProviders();\r\n        }\r\n        unwrap() {\r\n            return super.getFSUnlocked();\r\n        }\r\n        _initialize(cb) {\r\n            super.getFSUnlocked()._initialize(cb);\r\n        }\r\n    }\r\n    OverlayProvider.Name = \"OverlayProvider\";\r\n    OverlayProvider.Options = {\r\n        writable: {\r\n            type: \"object\",\r\n            description: \"The file system to write modified files to.\"\r\n        },\r\n        readable: {\r\n            type: \"object\",\r\n            description: \"The file system that initially populates this file system.\"\r\n        }\r\n    };\r\n\r\n    return OverlayProvider;\r\n});\ndefine('skylark-data-files/main',[\r\n\t\"./files\",\r\n\t\"./action-type\",\r\n\t\"./base-file\",\r\n\t\"./error-codes\",\r\n\t\"./error-strings\",\r\n\t\"./file-error\",\r\n\t\"./file-flag\",\r\n\t\"./file-system\",\r\n\t\"./no-sync-file\",\r\n\t\"./preload-file\",\r\n\t\"./stats\",\r\n\t\"./configure\",\r\n\t\"./providers/dropbox/dropbox-provider\",\r\n\t\"./providers/html5/html5-lfs-provider\",\r\n\t\"./providers/http/http-provider\",\r\n\t\"./providers/indexeddb/indexed-db-provider\",\r\n\t\"./providers/inmemory/in-memory-provider\",\r\n\t\"./providers/localstorage/local-storage-provider\",\r\n\t\"./providers/overlay/overlay-provider\"\r\n\r\n],function(files){\r\n\treturn files;\r\n});\ndefine('skylark-data-files', ['skylark-data-files/main'], function (main) { return main; });\n\n"]}