{"version":3,"sources":["skylark-data-files.js"],"names":["define","files","ActionType","ErrorCodes","ErrorStrings","EPERM","ENOENT","EIO","EBADF","EACCES","EBUSY","EEXIST","ENOTDIR","EISDIR","EINVAL","EFBIG","ENOSPC","EROFS","ENOTEMPTY","ENOTSUP","Buffer","FileError","Error","[object Object]","type","message","path","super","this","syscall","errno","code","stack","json","err","buffer","i","fromJSON","JSON","parse","toString","readUInt32LE","p","create","alloc","bufferSize","bytesWritten","write","stringify","toJSON","writeUInt32LE","byteLength","BaseFile","cb","sync","syncSync","uid","gid","mode","atime","mtime","FileFlag","flagStr","validFlagStrs","indexOf","flagCache","hasOwnProperty","isExclusive","THROW_EXCEPTION","isTruncating","TRUNCATE_FILE","NOP","isWriteable","isAppendable","CREATE_FILE","FileType","Stats","itemType","size","atimeMs","mtimeMs","ctimeMs","birthtimeMs","dev","ino","rdev","nlink","blksize","fileData","currentTime","Date","now","FILE","DIRECTORY","blocks","Math","ceil","readDoubleLE","ctime","s","birthtime","writeDoubleLE","getTime","SYMLINK","setImmediate","wrapCbHook","numArgs","wrapCb","hookedCb","arg1","arg2","arg3","assertRoot","fs","normalizeMode","def","trueMode","parseInt","isNaN","normalizeTime","time","normalizePath","resolve","normalizeOptions","options","defEnc","defFlag","defMode","encoding","flag","TypeError","nopCb","FileSystem","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","rootFS","constructor","isAvailable","oldPath","newPath","newCb","rename","e","renameSync","exists","existsSync","stat","statSync","len","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","data","writeFile","writeFileSync","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","length","datasync","datasyncSync","arg4","arg5","offset","position","from","undefined","getPos","writeSync","bytesRead","buf","read","shenanigans","rv","readSync","callback","chown","chownSync","numMode","chmod","chmodSync","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","cbWrapper","paths","isIE","navigator","exec","userAgent","toLowerCase","isWebWorker","window","buffer2Uint8array","buff","Uint8Array","uint8Array2Buffer","u8","byteOffset","arrayBuffer2Buffer","ab","emptyBuff","emptyBuffer","deprecationMessage","print","fsName","opts","console","warn","fail","mkdirpSync","dirname","buffer2ArrayBuffer","u8offset","u8Len","slice","arrayish2Buffer","arr","copyingSlice","start","end","s0","newS0","subarray","bufferValidator","v","isBuffer","checkOptions","fsType","optsInfo","Options","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","optName","opt","providedValue","optional","incorrectOptions","Object","keys","filter","o","map","a","str","distance","levenshtein","sort","b","description","typeMatches","Array","isArray","join","validator","utils","PreloadFile","_fs","_path","_flag","_stat","contents","_pos","_dirty","_buffer","delta","newPos","clone","isSynchronous","getRootFS","supportsSynch","newBuff","copy","endFp","setPos","endRead","supportsProps","NoSyncFile","main"],"mappings":"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","file":"../skylark-data-files.js","sourcesContent":["define('skylark-data-files/files',[],function(){\r\n\t\r\n});\ndefine('skylark-data-files/action-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  var ActionType;\r\n  (function (ActionType) {\r\n      // Indicates that the code should not do anything.\r\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\r\n      // Indicates that the code should throw an exception.\r\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\r\n      // Indicates that the code should truncate the file, but only if it is a file.\r\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\r\n      // Indicates that the code should create the file.\r\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\r\n  })(ActionType || (ActionType = {}));\r\n\r\n  return files.ActionType = ActionType;\r\n});\r\n  \ndefine('skylark-data-files/error-codes',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Standard libc error codes. Add more to this enum and ErrorStrings as they are\r\n   * needed.\r\n   * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\r\n   */\r\n  var ErrorCodes;\r\n  (function (ErrorCodes) {\r\n      ErrorCodes[ErrorCodes[\"EPERM\"] = 1] = \"EPERM\";\r\n      ErrorCodes[ErrorCodes[\"ENOENT\"] = 2] = \"ENOENT\";\r\n      ErrorCodes[ErrorCodes[\"EIO\"] = 5] = \"EIO\";\r\n      ErrorCodes[ErrorCodes[\"EBADF\"] = 9] = \"EBADF\";\r\n      ErrorCodes[ErrorCodes[\"EACCES\"] = 13] = \"EACCES\";\r\n      ErrorCodes[ErrorCodes[\"EBUSY\"] = 16] = \"EBUSY\";\r\n      ErrorCodes[ErrorCodes[\"EEXIST\"] = 17] = \"EEXIST\";\r\n      ErrorCodes[ErrorCodes[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\r\n      ErrorCodes[ErrorCodes[\"EISDIR\"] = 21] = \"EISDIR\";\r\n      ErrorCodes[ErrorCodes[\"EINVAL\"] = 22] = \"EINVAL\";\r\n      ErrorCodes[ErrorCodes[\"EFBIG\"] = 27] = \"EFBIG\";\r\n      ErrorCodes[ErrorCodes[\"ENOSPC\"] = 28] = \"ENOSPC\";\r\n      ErrorCodes[ErrorCodes[\"EROFS\"] = 30] = \"EROFS\";\r\n      ErrorCodes[ErrorCodes[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\r\n      ErrorCodes[ErrorCodes[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\r\n  })(ErrorCodes || (ErrorCodes = {}));\r\n\r\n  return files.ErrorCodes = ErrorCodes;\r\n});\r\n  \ndefine('skylark-data-files/error-strings',[\r\n  \"./files\",\r\n  \"./error-codes\"\r\n],function (files,ErrorCodes) {\r\n  'use strict';\r\n\r\n  /* tslint:disable:variable-name */\r\n  /**\r\n   * Strings associated with each error code.\r\n   * @hidden\r\n   */\r\n  const ErrorStrings = {};\r\n  ErrorStrings[ErrorCodes.EPERM] = 'Operation not permitted.';\r\n  ErrorStrings[ErrorCodes.ENOENT] = 'No such file or directory.';\r\n  ErrorStrings[ErrorCodes.EIO] = 'Input/output error.';\r\n  ErrorStrings[ErrorCodes.EBADF] = 'Bad file descriptor.';\r\n  ErrorStrings[ErrorCodes.EACCES] = 'Permission denied.';\r\n  ErrorStrings[ErrorCodes.EBUSY] = 'Resource busy or locked.';\r\n  ErrorStrings[ErrorCodes.EEXIST] = 'File exists.';\r\n  ErrorStrings[ErrorCodes.ENOTDIR] = 'File is not a directory.';\r\n  ErrorStrings[ErrorCodes.EISDIR] = 'File is a directory.';\r\n  ErrorStrings[ErrorCodes.EINVAL] = 'Invalid argument.';\r\n  ErrorStrings[ErrorCodes.EFBIG] = 'File is too big.';\r\n  ErrorStrings[ErrorCodes.ENOSPC] = 'No space left on disk.';\r\n  ErrorStrings[ErrorCodes.EROFS] = 'Cannot modify a read-only file system.';\r\n  ErrorStrings[ErrorCodes.ENOTEMPTY] = 'Directory is not empty.';\r\n  ErrorStrings[ErrorCodes.ENOTSUP] = 'Operation is not supported.';\r\n\r\n  return files.ErrorStrings = ErrorStrings;\r\n});\r\n  \ndefine('skylark-data-files/file-error',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    \"./error-strings\"\r\n],function (Buffer,files,ErrorCodes,ErrorStrings) {\r\n   'use strict';\r\n   \r\n\r\n    /* tslint:enable:variable-name */\r\n    /**\r\n     * Represents a BrowserFS error. Passed back to applications after a failed\r\n     * call to the BrowserFS API.\r\n     */\r\n    class FileError extends Error {\r\n        /**\r\n         * Represents a BrowserFS error. Passed back to applications after a failed\r\n         * call to the BrowserFS API.\r\n         *\r\n         * Error codes mirror those returned by regular Unix file operations, which is\r\n         * what Node returns.\r\n         * @constructor FileError\r\n         * @param type The type of the error.\r\n         * @param [message] A descriptive error message.\r\n         */\r\n        constructor(type, message = ErrorStrings[type], path) {\r\n            super(message);\r\n            // Unsupported.\r\n            this.syscall = \"\";\r\n            this.errno = type;\r\n            this.code = ErrorCodes[type];\r\n            this.path = path;\r\n            this.stack = new Error().stack;\r\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\r\n        }\r\n        static fromJSON(json) {\r\n            const err = new FileError(0);\r\n            err.errno = json.errno;\r\n            err.code = json.code;\r\n            err.path = json.path;\r\n            err.stack = json.stack;\r\n            err.message = json.message;\r\n            return err;\r\n        }\r\n        /**\r\n         * Creates an FileError object from a buffer.\r\n         */\r\n        static fromBuffer(buffer, i = 0) {\r\n            return FileError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\r\n        }\r\n        static create(code, p) {\r\n            return new FileError(code, ErrorStrings[code], p);\r\n        }\r\n        static ENOENT(path) {\r\n            return this.create(ErrorCodes.ENOENT, path);\r\n        }\r\n        static EEXIST(path) {\r\n            return this.create(ErrorCodes.EEXIST, path);\r\n        }\r\n        static EISDIR(path) {\r\n            return this.create(ErrorCodes.EISDIR, path);\r\n        }\r\n        static ENOTDIR(path) {\r\n            return this.create(ErrorCodes.ENOTDIR, path);\r\n        }\r\n        static EPERM(path) {\r\n            return this.create(ErrorCodes.EPERM, path);\r\n        }\r\n        static ENOTEMPTY(path) {\r\n            return this.create(ErrorCodes.ENOTEMPTY, path);\r\n        }\r\n        /**\r\n         * @return A friendly error message.\r\n         */\r\n        toString() {\r\n            return this.message;\r\n        }\r\n        toJSON() {\r\n            return {\r\n                errno: this.errno,\r\n                code: this.code,\r\n                path: this.path,\r\n                stack: this.stack,\r\n                message: this.message\r\n            };\r\n        }\r\n        /**\r\n         * Writes the API error into a buffer.\r\n         */\r\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\r\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\r\n            buffer.writeUInt32LE(bytesWritten, i);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * The size of the API error in buffer-form in bytes.\r\n         */\r\n        bufferSize() {\r\n            // 4 bytes for string length.\r\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\r\n        }\r\n    }\r\n\r\n    return files.FileError = FileError;\r\n\r\n});\ndefine('skylark-data-files/base-file',[\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\"\r\n], function (files,ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Base class that contains shared implementations of functions for the file\r\n     * object.\r\n     */\r\n    class BaseFile {\r\n        sync(cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        datasync(cb) {\r\n            this.sync(cb);\r\n        }\r\n        datasyncSync() {\r\n            return this.syncSync();\r\n        }\r\n        chown(uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chmod(mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n    return files.BaseFile = BaseFile;\r\n});\ndefine('skylark-data-files/file-flag',[\r\n  \"./files\",\r\n  './error-codes',\r\n  \"./file-error\",\r\n  \"./action-type\"\r\n], function (files,ErrorCodes,FileError,ActionType) {\r\n    'use strict';\r\n\r\n\r\n\r\n  /**\r\n   * Represents one of the following file flags. A convenience object.\r\n   *\r\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\r\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\r\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\r\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\r\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\r\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\r\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\r\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\r\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\r\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\r\n   *\r\n   * Exclusive mode ensures that the file path is newly created.\r\n   */\r\n  class FileFlag {\r\n      /**\r\n       * This should never be called directly.\r\n       * @param modeStr The string representing the mode\r\n       * @throw when the mode string is invalid\r\n       */\r\n      constructor(flagStr) {\r\n          this.flagStr = flagStr;\r\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\r\n              throw new FileError(ErrorCodes.EINVAL, \"Invalid flag: \" + flagStr);\r\n          }\r\n      }\r\n      /**\r\n       * Get an object representing the given file flag.\r\n       * @param modeStr The string representing the flag\r\n       * @return The FileFlag object representing the flag\r\n       * @throw when the flag string is invalid\r\n       */\r\n      static getFileFlag(flagStr) {\r\n          // Check cache first.\r\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\r\n              return FileFlag.flagCache[flagStr];\r\n          }\r\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\r\n      }\r\n      /**\r\n       * Get the underlying flag string for this flag.\r\n       */\r\n      getFlagString() {\r\n          return this.flagStr;\r\n      }\r\n      /**\r\n       * Returns true if the file is readable.\r\n       */\r\n      isReadable() {\r\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is writeable.\r\n       */\r\n      isWriteable() {\r\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file mode should truncate.\r\n       */\r\n      isTruncating() {\r\n          return this.flagStr.indexOf('w') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is appendable.\r\n       */\r\n      isAppendable() {\r\n          return this.flagStr.indexOf('a') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in synchronous mode.\r\n       */\r\n      isSynchronous() {\r\n          return this.flagStr.indexOf('s') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in exclusive mode.\r\n       */\r\n      isExclusive() {\r\n          return this.flagStr.indexOf('x') !== -1;\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path existing.\r\n       */\r\n      pathExistsAction() {\r\n          if (this.isExclusive()) {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n          else if (this.isTruncating()) {\r\n              return ActionType.TRUNCATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.NOP;\r\n          }\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path not existing.\r\n       */\r\n      pathNotExistsAction() {\r\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\r\n              return ActionType.CREATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n      }\r\n  }\r\n  // Contains cached FileMode instances.\r\n  FileFlag.flagCache = {};\r\n  // Array of valid mode strings.\r\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\r\n\r\n\r\n\r\n  return files.FileFlag = FileFlag;\r\n});\ndefine('skylark-data-files/file-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n    * Indicates the type of the given file. Applied to 'mode'.\r\n    */\r\n  var FileType;\r\n  (function (FileType) {\r\n      FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\r\n      FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\r\n      FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\r\n  })(FileType || (FileType = {}));\r\n\r\n  return files.FileType = FileType;\r\n});\r\n  \ndefine('skylark-data-files/stats',[\r\n    'skylark-langx-binary/buffer',\r\n    \"./file-type\"\r\n],function (Buffer,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Emulation of Node's `fs.Stats` object.\r\n     *\r\n     * Attribute descriptions are from `man 2 stat'\r\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\r\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\r\n     */\r\n    class Stats {\r\n        /**\r\n         * Provides information about a particular entry in the file system.\r\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\r\n         * @param size Size of the item in bytes. For directories/symlinks,\r\n         *   this is normally the size of the struct that represents the item.\r\n         * @param mode Unix-style file mode (e.g. 0o644)\r\n         * @param atimeMs time of last access, in milliseconds since epoch\r\n         * @param mtimeMs time of last modification, in milliseconds since epoch\r\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\r\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\r\n         */\r\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\r\n            /**\r\n             * UNSUPPORTED ATTRIBUTES\r\n             * I assume no one is going to need these details, although we could fake\r\n             * appropriate values if need be.\r\n             */\r\n            // ID of device containing file\r\n            this.dev = 0;\r\n            // inode number\r\n            this.ino = 0;\r\n            // device ID (if special file)\r\n            this.rdev = 0;\r\n            // number of hard links\r\n            this.nlink = 1;\r\n            // blocksize for file system I/O\r\n            this.blksize = 4096;\r\n            // @todo Maybe support these? atm, it's a one-user filesystem.\r\n            // user ID of owner\r\n            this.uid = 0;\r\n            // group ID of owner\r\n            this.gid = 0;\r\n            // XXX: Some file systems stash data on stats objects.\r\n            this.fileData = null;\r\n            this.size = size;\r\n            let currentTime = 0;\r\n            if (typeof (atimeMs) !== 'number') {\r\n                currentTime = Date.now();\r\n                atimeMs = currentTime;\r\n            }\r\n            if (typeof (mtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                mtimeMs = currentTime;\r\n            }\r\n            if (typeof (ctimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                ctimeMs = currentTime;\r\n            }\r\n            if (typeof (birthtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                birthtimeMs = currentTime;\r\n            }\r\n            this.atimeMs = atimeMs;\r\n            this.ctimeMs = ctimeMs;\r\n            this.mtimeMs = mtimeMs;\r\n            this.birthtimeMs = birthtimeMs;\r\n            if (!mode) {\r\n                switch (itemType) {\r\n                    case FileType.FILE:\r\n                        this.mode = 0x1a4;\r\n                        break;\r\n                    case FileType.DIRECTORY:\r\n                    default:\r\n                        this.mode = 0x1ff;\r\n                }\r\n            }\r\n            else {\r\n                this.mode = mode;\r\n            }\r\n            // number of 512B blocks allocated\r\n            this.blocks = Math.ceil(size / 512);\r\n            // Check if mode also includes top-most bits, which indicate the file's\r\n            // type.\r\n            if (this.mode < 0x1000) {\r\n                this.mode |= itemType;\r\n            }\r\n        }\r\n        static fromBuffer(buffer) {\r\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\r\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\r\n        }\r\n        /**\r\n         * Clones the stats object.\r\n         */\r\n        static clone(s) {\r\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\r\n        }\r\n        get atime() {\r\n            return new Date(this.atimeMs);\r\n        }\r\n        get mtime() {\r\n            return new Date(this.mtimeMs);\r\n        }\r\n        get ctime() {\r\n            return new Date(this.ctimeMs);\r\n        }\r\n        get birthtime() {\r\n            return new Date(this.birthtimeMs);\r\n        }\r\n        toBuffer() {\r\n            const buffer = Buffer.alloc(32);\r\n            buffer.writeUInt32LE(this.size, 0);\r\n            buffer.writeUInt32LE(this.mode, 4);\r\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\r\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\r\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\r\n         */\r\n        isSymbolicLink() {\r\n            return (this.mode & 0xF000) === FileType.SYMLINK;\r\n        }\r\n        /**\r\n         * Change the mode of the file. We use this helper function to prevent messing\r\n         * up the type of the file, which is encoded in mode.\r\n         */\r\n        chmod(mode) {\r\n            this.mode = (this.mode & 0xF000) | mode;\r\n        }\r\n        // We don't support the following types of files.\r\n        isSocket() {\r\n            return false;\r\n        }\r\n        isBlockDevice() {\r\n            return false;\r\n        }\r\n        isCharacterDevice() {\r\n            return false;\r\n        }\r\n        isFIFO() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return files.Stats = Stats;\r\n});\ndefine('skylark-data-files/file-system',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths/path\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, path, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return path.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});\ndefine('skylark-data-files/utils',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(path.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});\ndefine('skylark-data-files/preload-file',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,file,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});\ndefine('skylark-data-files/no-sync-file',[\r\n     \"./preload-file\"\r\n], function (PreloadFile) {\r\n    'use strict';\r\n    /**\r\n     * File class for the InMemory and XHR file systems.\r\n     * Doesn't sync to anything, so it works nicely for memory-only files.\r\n     */\r\n    class NoSyncFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        /**\r\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous sync. Doesn't do anything.\r\n         */\r\n        syncSync() {\r\n            // NOP.\r\n        }\r\n        /**\r\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous close. Doesn't do anything.\r\n         */\r\n        closeSync() {\r\n            // NOP.\r\n        }\r\n    }\r\n\r\n    return files.NoSyncFile = NoSyncFile;\r\n    \r\n});\ndefine('skylark-data-files/main',[\r\n\t\"./files\",\r\n\t\"./action-type\",\r\n\t\"./base-file\",\r\n\t\"./error-codes\",\r\n\t\"./error-strings\",\r\n\t\"./file-error\",\r\n\t\"./file-flag\",\r\n\t\"./file-system\",\r\n\t\"./no-sync-file\",\r\n\t\"./preload-file\",\r\n\t\"./stats\"\r\n],function(files){\r\n\treturn files;\r\n});\ndefine('skylark-data-files', ['skylark-data-files/main'], function (main) { return main; });\n\n"]}