{"version":3,"sources":["skylark-data-files.js"],"names":["define","skylark","attach","providers","files","ActionType","ErrorCodes","exports","byteLength","b64","lens","getLens","validLen","placeHoldersLen","toByteArray","tmp","i","arr","Arr","_byteLength","curByte","len","revLookup","charCodeAt","fromByteArray","uint8","length","extraBytes","parts","len2","push","encodeChunk","lookup","join","Uint8Array","Array","code","Error","indexOf","start","end","num","output","read","buffer","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","value","c","rt","abs","isNaN","floor","log","LN2","binary","base64","ieee754","Buffer","INSPECT_MAX_BYTES","K_MAX_LENGTH","createBuffer","RangeError","buf","__proto__","prototype","arg","encodingOrOffset","allocUnsafe","from","TypeError","isArrayBuffer","array","byteOffset","undefined","fromArrayBuffer","string","encoding","isEncoding","actual","slice","fromString","obj","isBuffer","checked","copy","ArrayBuffer","isView","numberIsNaN","fromArrayLike","type","isArray","data","fromObject","assertSize","size","toString","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","swap","b","n","bidirectionalIndexOf","val","dir","arrayIndexOf","call","lastIndexOf","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","found","j","hexWrite","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","utf8Slice","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","kMaxLength","TYPED_ARRAY_SUPPORT","foo","typedArraySupport","console","error","Object","defineProperty","get","this","Symbol","species","configurable","enumerable","writable","poolSize","alloc","fill","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","list","pos","swap16","swap32","swap64","arguments","hexSlice","asciiSlice","latin1Slice","utf16leSlice","toLocaleString","equals","inspect","max","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","ret","out","toHex","bytes","checkOffset","ext","checkInt","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","set","INVALID_BASE64_RE","leadSurrogate","split","trim","replace","base64clean","src","dst","constructor","name","ErrorStrings","EPERM","ENOENT","EIO","EBADF","EACCES","EBUSY","EEXIST","ENOTDIR","EISDIR","EINVAL","EFBIG","ENOSPC","EROFS","ENOTEMPTY","ENOTSUP","FileError","[object Object]","message","path","super","syscall","errno","stack","json","err","fromJSON","JSON","parse","p","create","bufferSize","bytesWritten","stringify","BaseFile","cb","sync","syncSync","uid","gid","mode","atime","mtime","FileFlag","flagStr","validFlagStrs","flagCache","hasOwnProperty","isExclusive","THROW_EXCEPTION","isTruncating","TRUNCATE_FILE","NOP","isWriteable","isAppendable","CREATE_FILE","FileType","Stats","itemType","atimeMs","mtimeMs","ctimeMs","birthtimeMs","dev","ino","rdev","nlink","blksize","fileData","currentTime","Date","now","FILE","DIRECTORY","blocks","ceil","ctime","birthtime","getTime","SYMLINK","setImmediate","paths","wrapCbHook","numArgs","wrapCb","hookedCb","arg1","arg2","arg3","assertRoot","fs","normalizeMode","def","trueMode","normalizeTime","time","normalizePath","resolve","normalizeOptions","options","defEnc","defFlag","defMode","flag","nopCb","FileSystem","F_OK","R_OK","W_OK","X_OK","root","fdMap","nextFd","rootFS","isAvailable","oldPath","newPath","newCb","rename","renameSync","exists","existsSync","stat","statSync","truncate","truncateSync","unlink","unlinkSync","open","getFileFlag","file","getFdForFile","openSync","filename","isReadable","readFile","readFileSync","writeFile","writeFileSync","appendFile","appendFileSync","fd","fd2file","close","closeFd","closeSync","datasync","datasyncSync","arg4","arg5","position","getPos","writeSync","bytesRead","shenanigans","rv","readSync","callback","chown","chownSync","numMode","chmod","chmodSync","utimes","utimesSync","rmdir","rmdirSync","mkdir","mkdirSync","readdir","readdirSync","srcpath","dstpath","link","linkSync","symlink","symlinkSync","readlink","readlinkSync","cache","realpath","realpathSync","listener","cbWrapper","isIE","navigator","exec","userAgent","isWebWorker","window","buffer2Uint8array","buff","uint8Array2Buffer","u8","arrayBuffer2Buffer","ab","emptyBuff","emptyBuffer","deprecationMessage","print","fsName","opts","warn","fail","mkdirpSync","dirname","buffer2ArrayBuffer","u8offset","u8Len","arrayish2Buffer","copyingSlice","s0","newS0","bufferValidator","v","checkOptions","fsType","optsInfo","Options","Name","pendingValidators","callbackCalled","loopEnded","validatorCallback","optName","opt","providedValue","optional","incorrectOptions","keys","filter","o","map","distance","levenshtein","sort","description","typeMatches","validator","utils","PreloadFile","_fs","_path","_flag","_stat","contents","_pos","_dirty","_buffer","delta","newPos","clone","isSynchronous","getRootFS","supportsSynch","newBuff","endFp","setPos","endRead","supportsProps","NoSyncFile","registry","add","provider","initialize","rootfs","configure","config","getFileSystem","waitCount","called","finish","fsc","Create","finishedIterating","props","k","forEach","Bufer","BaseProvider","stats","pathNotExistsAction","parentStats","isDirectory","createFile","pathExistsAction","openFile","isLstat","createFileSync","openFileSync","supportsLinks","splitPath","sep","addPaths","doesExist","er","er2","fname","oldCb","err2","isLchmod","isLchown","_syncFile","getPath","getBuffer","DropboxFile","FixPath","ExtractTheFuckingError","obj2","reason","GetErrorMessage","user_message","text","error_summary","LookupErrorToError","msg","WriteErrorToError","FilesDeleteWrapped","client","filesDeleteV2","then","catch","path_lookup","path_write","setTimeout","random","DropboxProvider","_client","Dropbox","mainCb","next","shift","relocationArg","from_path","to_path","filesMoveV2","from_lookup","from_write","to","filesGetMetadata","ref","fileMetadata","flags","downloadArg","filesDownload","fileBlob","fr","FileReader","onload","result","readAsArrayBuffer","dpError","blob","Blob","commitInfo","filesUpload","metadata","upError","parent","filesCreateFolderV2","filesListFolder","ContinueReadingDir","previousEntries","newEntries","entries","path_display","has_more","cursor","filesListFolderContinue","ProcessListFolderError",".tag","pathError","entry","_entry","isDirty","createWriter","writer","onwriteend","onerror","resetDirty","convertError","async","Html5LfsFile","asyncEach","each","_getFS","webkitRequestProvider","requestProvider","expectedDir","Html5LfsProvider","PERSISTENT","_allocate","_readdir","finished","deleteEntry","succ","fullPath","removeRecursively","remove","semaphore","successCount","currentPath","success","getDirectory","parentDir","basename","moveTo","getFile","loadAsDir","failedToLoad","exclusive","reader","onloadend","event","bfsFile","_makeFile","ev","_remove","dirEntry","createReader","readEntries","results","errorCallback","webkitPersistentStorage","requestQuota","TEMPORARY","webkitTemporaryStorage","webkitStorageInfo","_requestQuota","granted","isFile","xhrIsAvailable","XMLHttpRequest","getFileSize","req","onreadystatechange","readyState","status","getResponseHeader","send","asyncDownloadFile","jsonSupported","responseType","response","responseText","syncDownloadFile","overrideMimeType","getFileSizeSync","getFileSizeAsync","fetchIsAvailable","fetch","fetchFileAsync","request","ok","arrayBuffer","fetchFileSizeAsync","method","headers","DirInode","_ls","item","inode","isDirInode","isDir","FileInode","isFileInode","FileINode","FileIndex","_index","addPath","listing","idx","rootInode","queue","pop","pwd","tree","node","children","getListing","getItem","getData","_split_path","dirpath","itemname","addItem","itemNameMark","parentPath","substring","itemName","addPathFast","remItem","child","removePath","xhr","syncNotAvailableError","HttpProvider","index","prefixUrl","preferXHR","charAt","fromListing","_requestFileAsyncInternal","_requestFileSizeAsyncInternal","_requestFileSyncInternal","_requestFileSizeSyncInternal","baseUrl","fileIterator","getInode","_requestFileSizeAsync","getStats","_requestFileSizeSync","self","_requestFileAsync","_requestFileSync","fdCast","fdBuff","tryToString","filePath","_getHTTPPath","Inode","id","getSize","hasChanged","AsyncKeyValueFile","_sync","GenerateRandomID","LRUCache","ROOT_NODE_ID","emptyDirNode","noError","noErrorTx","tx","abort","AsyncKeyValueProvider","cacheSize","_cache","store","makeRootDirectory","removeAll","clear","beginTransaction","oldParent","oldName","newParent","newName","inodes","lists","errorOccurred","theOleSwitcharoo","oldParentList","oldParentINode","newParentList","newParentINode","fileId","completeRename","put","commit","getINode","del","processInodeAndListings","findINodeAndDirListing","dirList","findINode","toStats","commitNewFile","newFile","removeEntry","getDirListing","dirListing","_findINode","fileInodeId","fileInode","inodeChanged","update","toBuffer","currTime","dirInode","getEmptyDirNode","handleDirectoryListings","fromBuffer","currId","retries","reroll","committed","parentNode","addNewNode","dataId","fileName","parentListing","fileNodeId","fileNode","key","r","preventDefault","onErrorHandler","onsuccess","IndexedDBROTransaction","indexedDB","mozIndexedDB","webkitIndexedDB","msIndexedDB","overwrite","arraybuffer","_e","IndexedDBRWTransaction","IndexedDBStore","db","storeName","openReq","onupgradeneeded","objectStoreNames","contains","deleteObjectStore","createObjectStore","IndexedDBProvider","transaction","objectStore","idbfs","init","SynchronousProvider","SyncKeyValueProvider","oldDirNode","oldDirList","nodeId","newDirNode","newDirList","newNameNode","SyncKeyValueFile","readDirectory","SimpleSyncRWTransaction","originalData","modifiedKeys","stashOldValue","markModified","InMemoryStore","InMemoryProvider","LocalStorageProvider","localStorage","binaryEncoding","setItem","removeItem","LocalStorageStore","supportsBinaryString","defer","_locked","_waiters","Mutex","LockedProvider","_mu","getName","diskSpace","isReadOnly","lock","unlock","isLocked","resolvedPath","linkString","_syncAsync","_syncSync","OverlayFile","deletionLogPath","makeModeWritable","getFlag","f","readable","_isInitialized","_initializeCallbacks","_deletedFiles","_deleteLog","_deleteLogUpdatePending","_deleteLogUpdateNeeded","_deleteLogError","_writable","_readable","ApiError","ErrorCode","createParentDirectoriesAsync","createParentDirectories","OverlayFS","callbackArray","_reparseDeletionLog","updateLog","checkInitAsync","checkPathAsync","oldErr","oldStats","newErr","newStats","copyDirContents","oldFile","mkdirErr","readdirErr","checkInitialized","checkPath","oldStat","readFileErr","writableExists","readableExists","deletePath","rmdirLower","dirStats","wFiles","rFiles","seenMap","filtered","fPath","fileP","existsWritable","existsReadable","operateOnWritableAsync","operateOnWritable","addition","toCreate","statDone","createParents","reverse","copyToWritable","copyToWritableAsync","pStats","UnlockedOverlayProvider","OverlayProvider","_initialize","getFSUnlocked","getOverlayedProviders","main"],"mappings":"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","file":"../skylark-data-files.js","sourcesContent":["define('skylark-data-files/files',[\r\n\t\"skylark-langx-ns\"\r\n],function(skylark){\r\n\treturn skylark.attach(\"data.files\",{\r\n\t\tproviders : {\r\n\t\t\t\r\n\t\t}\r\n\t});\r\n});\ndefine('skylark-data-files/action-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  var ActionType;\r\n  (function (ActionType) {\r\n      // Indicates that the code should not do anything.\r\n      ActionType[ActionType[\"NOP\"] = 0] = \"NOP\";\r\n      // Indicates that the code should throw an exception.\r\n      ActionType[ActionType[\"THROW_EXCEPTION\"] = 1] = \"THROW_EXCEPTION\";\r\n      // Indicates that the code should truncate the file, but only if it is a file.\r\n      ActionType[ActionType[\"TRUNCATE_FILE\"] = 2] = \"TRUNCATE_FILE\";\r\n      // Indicates that the code should create the file.\r\n      ActionType[ActionType[\"CREATE_FILE\"] = 3] = \"CREATE_FILE\";\r\n  })(ActionType || (ActionType = {}));\r\n\r\n  return files.ActionType = ActionType;\r\n});\r\n  \ndefine('skylark-data-files/error-codes',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n   * Standard libc error codes. Add more to this enum and ErrorStrings as they are\r\n   * needed.\r\n   * @url http://www.gnu.org/software/libc/manual/html_node/Error-Codes.html\r\n   */\r\n  var ErrorCodes;\r\n  (function (ErrorCodes) {\r\n      ErrorCodes[ErrorCodes[\"EPERM\"] = 1] = \"EPERM\";\r\n      ErrorCodes[ErrorCodes[\"ENOENT\"] = 2] = \"ENOENT\";\r\n      ErrorCodes[ErrorCodes[\"EIO\"] = 5] = \"EIO\";\r\n      ErrorCodes[ErrorCodes[\"EBADF\"] = 9] = \"EBADF\";\r\n      ErrorCodes[ErrorCodes[\"EACCES\"] = 13] = \"EACCES\";\r\n      ErrorCodes[ErrorCodes[\"EBUSY\"] = 16] = \"EBUSY\";\r\n      ErrorCodes[ErrorCodes[\"EEXIST\"] = 17] = \"EEXIST\";\r\n      ErrorCodes[ErrorCodes[\"ENOTDIR\"] = 20] = \"ENOTDIR\";\r\n      ErrorCodes[ErrorCodes[\"EISDIR\"] = 21] = \"EISDIR\";\r\n      ErrorCodes[ErrorCodes[\"EINVAL\"] = 22] = \"EINVAL\";\r\n      ErrorCodes[ErrorCodes[\"EFBIG\"] = 27] = \"EFBIG\";\r\n      ErrorCodes[ErrorCodes[\"ENOSPC\"] = 28] = \"ENOSPC\";\r\n      ErrorCodes[ErrorCodes[\"EROFS\"] = 30] = \"EROFS\";\r\n      ErrorCodes[ErrorCodes[\"ENOTEMPTY\"] = 39] = \"ENOTEMPTY\";\r\n      ErrorCodes[ErrorCodes[\"ENOTSUP\"] = 95] = \"ENOTSUP\";\r\n  })(ErrorCodes || (ErrorCodes = {}));\r\n\r\n  return files.ErrorCodes = ErrorCodes;\r\n});\r\n  \ndefine('skylark-langx-binary/base64',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.byteLength = byteLength\r\n  exports.toByteArray = toByteArray\r\n  exports.fromByteArray = fromByteArray\r\n\r\n  var lookup = []\r\n  var revLookup = []\r\n  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\r\n\r\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\r\n  for (var i = 0, len = code.length; i < len; ++i) {\r\n    lookup[i] = code[i]\r\n    revLookup[code.charCodeAt(i)] = i\r\n  }\r\n\r\n  // Support decoding URL-safe base64 strings, as Node.js does.\r\n  // See: https://en.wikipedia.org/wiki/Base64#URL_applications\r\n  revLookup['-'.charCodeAt(0)] = 62\r\n  revLookup['_'.charCodeAt(0)] = 63\r\n\r\n  function getLens (b64) {\r\n    var len = b64.length\r\n\r\n    if (len % 4 > 0) {\r\n      throw new Error('Invalid string. Length must be a multiple of 4')\r\n    }\r\n\r\n    // Trim off extra bytes after placeholder bytes are found\r\n    // See: https://github.com/beatgammit/base64-js/issues/42\r\n    var validLen = b64.indexOf('=')\r\n    if (validLen === -1) validLen = len\r\n\r\n    var placeHoldersLen = validLen === len\r\n      ? 0\r\n      : 4 - (validLen % 4)\r\n\r\n    return [validLen, placeHoldersLen]\r\n  }\r\n\r\n  // base64 is 4/3 + up to two characters of the original data\r\n  function byteLength (b64) {\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function _byteLength (b64, validLen, placeHoldersLen) {\r\n    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\r\n  }\r\n\r\n  function toByteArray (b64) {\r\n    var tmp\r\n    var lens = getLens(b64)\r\n    var validLen = lens[0]\r\n    var placeHoldersLen = lens[1]\r\n\r\n    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\r\n\r\n    var curByte = 0\r\n\r\n    // if there are placeholders, only get up to the last complete 4 chars\r\n    var len = placeHoldersLen > 0\r\n      ? validLen - 4\r\n      : validLen\r\n\r\n    var i\r\n    for (i = 0; i < len; i += 4) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 18) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 12) |\r\n        (revLookup[b64.charCodeAt(i + 2)] << 6) |\r\n        revLookup[b64.charCodeAt(i + 3)]\r\n      arr[curByte++] = (tmp >> 16) & 0xFF\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 2) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 2) |\r\n        (revLookup[b64.charCodeAt(i + 1)] >> 4)\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    if (placeHoldersLen === 1) {\r\n      tmp =\r\n        (revLookup[b64.charCodeAt(i)] << 10) |\r\n        (revLookup[b64.charCodeAt(i + 1)] << 4) |\r\n        (revLookup[b64.charCodeAt(i + 2)] >> 2)\r\n      arr[curByte++] = (tmp >> 8) & 0xFF\r\n      arr[curByte++] = tmp & 0xFF\r\n    }\r\n\r\n    return arr\r\n  }\r\n\r\n  function tripletToBase64 (num) {\r\n    return lookup[num >> 18 & 0x3F] +\r\n      lookup[num >> 12 & 0x3F] +\r\n      lookup[num >> 6 & 0x3F] +\r\n      lookup[num & 0x3F]\r\n  }\r\n\r\n  function encodeChunk (uint8, start, end) {\r\n    var tmp\r\n    var output = []\r\n    for (var i = start; i < end; i += 3) {\r\n      tmp =\r\n        ((uint8[i] << 16) & 0xFF0000) +\r\n        ((uint8[i + 1] << 8) & 0xFF00) +\r\n        (uint8[i + 2] & 0xFF)\r\n      output.push(tripletToBase64(tmp))\r\n    }\r\n    return output.join('')\r\n  }\r\n\r\n  function fromByteArray (uint8) {\r\n    var tmp\r\n    var len = uint8.length\r\n    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\r\n    var parts = []\r\n    var maxChunkLength = 16383 // must be multiple of 3\r\n\r\n    // go through the array every three bytes, we'll deal with trailing stuff later\r\n    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\r\n      parts.push(encodeChunk(\r\n        uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\r\n      ))\r\n    }\r\n\r\n    // pad the end with zeros, but make sure to not forget the extra bytes\r\n    if (extraBytes === 1) {\r\n      tmp = uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 2] +\r\n        lookup[(tmp << 4) & 0x3F] +\r\n        '=='\r\n      )\r\n    } else if (extraBytes === 2) {\r\n      tmp = (uint8[len - 2] << 8) + uint8[len - 1]\r\n      parts.push(\r\n        lookup[tmp >> 10] +\r\n        lookup[(tmp >> 4) & 0x3F] +\r\n        lookup[(tmp << 2) & 0x3F] +\r\n        '='\r\n      )\r\n    }\r\n\r\n    return parts.join('')\r\n  }\r\n\r\n  return exports;\r\n});\ndefine('skylark-langx-binary/ieee754',[],function(){\r\n  'use strict'\r\n  var exports = {};\r\n\r\n  exports.read = function (buffer, offset, isLE, mLen, nBytes) {\r\n    var e, m\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var nBits = -7\r\n    var i = isLE ? (nBytes - 1) : 0\r\n    var d = isLE ? -1 : 1\r\n    var s = buffer[offset + i]\r\n\r\n    i += d\r\n\r\n    e = s & ((1 << (-nBits)) - 1)\r\n    s >>= (-nBits)\r\n    nBits += eLen\r\n    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    m = e & ((1 << (-nBits)) - 1)\r\n    e >>= (-nBits)\r\n    nBits += mLen\r\n    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\r\n\r\n    if (e === 0) {\r\n      e = 1 - eBias\r\n    } else if (e === eMax) {\r\n      return m ? NaN : ((s ? -1 : 1) * Infinity)\r\n    } else {\r\n      m = m + Math.pow(2, mLen)\r\n      e = e - eBias\r\n    }\r\n    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\r\n  }\r\n\r\n  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\r\n    var e, m, c\r\n    var eLen = (nBytes * 8) - mLen - 1\r\n    var eMax = (1 << eLen) - 1\r\n    var eBias = eMax >> 1\r\n    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\r\n    var i = isLE ? 0 : (nBytes - 1)\r\n    var d = isLE ? 1 : -1\r\n    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\r\n\r\n    value = Math.abs(value)\r\n\r\n    if (isNaN(value) || value === Infinity) {\r\n      m = isNaN(value) ? 1 : 0\r\n      e = eMax\r\n    } else {\r\n      e = Math.floor(Math.log(value) / Math.LN2)\r\n      if (value * (c = Math.pow(2, -e)) < 1) {\r\n        e--\r\n        c *= 2\r\n      }\r\n      if (e + eBias >= 1) {\r\n        value += rt / c\r\n      } else {\r\n        value += rt * Math.pow(2, 1 - eBias)\r\n      }\r\n      if (value * c >= 2) {\r\n        e++\r\n        c /= 2\r\n      }\r\n\r\n      if (e + eBias >= eMax) {\r\n        m = 0\r\n        e = eMax\r\n      } else if (e + eBias >= 1) {\r\n        m = ((value * c) - 1) * Math.pow(2, mLen)\r\n        e = e + eBias\r\n      } else {\r\n        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\r\n        e = 0\r\n      }\r\n    }\r\n\r\n    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\r\n\r\n    e = (e << mLen) | m\r\n    eLen += mLen\r\n    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\r\n\r\n    buffer[offset + i - d] |= s * 128\r\n  }\r\n\r\n  return exports;\r\n});\r\n\ndefine('skylark-langx-binary/buffer',[\r\n  \"./binary\",\r\n  \"./base64\",\r\n  \"./ieee754\"\r\n],function(binary,base64,ieee754){\r\n  /*!\r\n   * The buffer module from node.js, for the browser.\r\n   *\r\n   * @author   Feross Aboukhadijeh <https://feross.org>\r\n   * @license  MIT\r\n   */\r\n  /* eslint-disable no-proto */\r\n\r\n  'use strict'\r\n\r\n\r\n  Buffer.INSPECT_MAX_BYTES = 50\r\n\r\n  var K_MAX_LENGTH = 0x7fffffff\r\n  Buffer.kMaxLength = K_MAX_LENGTH\r\n\r\n  /**\r\n   * If `Buffer.TYPED_ARRAY_SUPPORT`:\r\n   *   === true    Use Uint8Array implementation (fastest)\r\n   *   === false   Print warning and recommend using `buffer` v4.x which has an Object\r\n   *               implementation (most compatible, even IE6)\r\n   *\r\n   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\r\n   * Opera 11.6+, iOS 4.2+.\r\n   *\r\n   * We report that the browser does not support typed arrays if the are not subclassable\r\n   * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\r\n   * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\r\n   * for __proto__ and has a buggy typed array implementation.\r\n   */\r\n  Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\r\n\r\n  if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\r\n      typeof console.error === 'function') {\r\n    console.error(\r\n      'This browser lacks typed array (Uint8Array) support which is required by ' +\r\n      '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\r\n    )\r\n  }\r\n\r\n  function typedArraySupport () {\r\n    // Can typed array instances can be augmented?\r\n    try {\r\n      var arr = new Uint8Array(1)\r\n      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\r\n      return arr.foo() === 42\r\n    } catch (e) {\r\n      return false\r\n    }\r\n  }\r\n\r\n  Object.defineProperty(Buffer.prototype, 'parent', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.buffer\r\n    }\r\n  })\r\n\r\n  Object.defineProperty(Buffer.prototype, 'offset', {\r\n    get: function () {\r\n      if (!(this instanceof Buffer)) {\r\n        return undefined\r\n      }\r\n      return this.byteOffset\r\n    }\r\n  })\r\n\r\n  function createBuffer (length) {\r\n    if (length > K_MAX_LENGTH) {\r\n      throw new RangeError('Invalid typed array length')\r\n    }\r\n    // Return an augmented `Uint8Array` instance\r\n    var buf = new Uint8Array(length)\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  /**\r\n   * The Buffer constructor returns instances of `Uint8Array` that have their\r\n   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\r\n   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\r\n   * and the `Uint8Array` methods. Square bracket notation works as expected -- it\r\n   * returns a single octet.\r\n   *\r\n   * The `Uint8Array` prototype remains unmodified.\r\n   */\r\n\r\n  function Buffer (arg, encodingOrOffset, length) {\r\n    // Common case.\r\n    if (typeof arg === 'number') {\r\n      if (typeof encodingOrOffset === 'string') {\r\n        throw new Error(\r\n          'If encoding is specified then the first argument must be a string'\r\n        )\r\n      }\r\n      return allocUnsafe(arg)\r\n    }\r\n    return from(arg, encodingOrOffset, length)\r\n  }\r\n\r\n  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\r\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\r\n      Buffer[Symbol.species] === Buffer) {\r\n    Object.defineProperty(Buffer, Symbol.species, {\r\n      value: null,\r\n      configurable: true,\r\n      enumerable: false,\r\n      writable: false\r\n    })\r\n  }\r\n\r\n  Buffer.poolSize = 8192 // not used by this implementation\r\n\r\n  function from (value, encodingOrOffset, length) {\r\n    if (typeof value === 'number') {\r\n      throw new TypeError('\"value\" argument must not be a number')\r\n    }\r\n\r\n    if (isArrayBuffer(value) || (value && isArrayBuffer(value.buffer))) {\r\n      return fromArrayBuffer(value, encodingOrOffset, length)\r\n    }\r\n\r\n    if (typeof value === 'string') {\r\n      return fromString(value, encodingOrOffset)\r\n    }\r\n\r\n    return fromObject(value)\r\n  }\r\n\r\n  /**\r\n   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\r\n   * if value is a number.\r\n   * Buffer.from(str[, encoding])\r\n   * Buffer.from(array)\r\n   * Buffer.from(buffer)\r\n   * Buffer.from(arrayBuffer[, byteOffset[, length]])\r\n   **/\r\n  Buffer.from = function (value, encodingOrOffset, length) {\r\n    return from(value, encodingOrOffset, length)\r\n  }\r\n\r\n  // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\r\n  // https://github.com/feross/buffer/pull/148\r\n  Buffer.prototype.__proto__ = Uint8Array.prototype\r\n  Buffer.__proto__ = Uint8Array\r\n\r\n  function assertSize (size) {\r\n    if (typeof size !== 'number') {\r\n      throw new TypeError('\"size\" argument must be of type number')\r\n    } else if (size < 0) {\r\n      throw new RangeError('\"size\" argument must not be negative')\r\n    }\r\n  }\r\n\r\n  function alloc (size, fill, encoding) {\r\n    assertSize(size)\r\n    if (size <= 0) {\r\n      return createBuffer(size)\r\n    }\r\n    if (fill !== undefined) {\r\n      // Only pay attention to encoding if it's a string. This\r\n      // prevents accidentally sending in a number that would\r\n      // be interpretted as a start offset.\r\n      return typeof encoding === 'string'\r\n        ? createBuffer(size).fill(fill, encoding)\r\n        : createBuffer(size).fill(fill)\r\n    }\r\n    return createBuffer(size)\r\n  }\r\n\r\n  /**\r\n   * Creates a new filled Buffer instance.\r\n   * alloc(size[, fill[, encoding]])\r\n   **/\r\n  Buffer.alloc = function (size, fill, encoding) {\r\n    return alloc(size, fill, encoding)\r\n  }\r\n\r\n  function allocUnsafe (size) {\r\n    assertSize(size)\r\n    return createBuffer(size < 0 ? 0 : checked(size) | 0)\r\n  }\r\n\r\n  /**\r\n   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\r\n   * */\r\n  Buffer.allocUnsafe = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n  /**\r\n   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\r\n   */\r\n  Buffer.allocUnsafeSlow = function (size) {\r\n    return allocUnsafe(size)\r\n  }\r\n\r\n  function fromString (string, encoding) {\r\n    if (typeof encoding !== 'string' || encoding === '') {\r\n      encoding = 'utf8'\r\n    }\r\n\r\n    if (!Buffer.isEncoding(encoding)) {\r\n      throw new TypeError('Unknown encoding: ' + encoding)\r\n    }\r\n\r\n    var length = byteLength(string, encoding) | 0\r\n    var buf = createBuffer(length)\r\n\r\n    var actual = buf.write(string, encoding)\r\n\r\n    if (actual !== length) {\r\n      // Writing a hex string, for example, that contains invalid characters will\r\n      // cause everything after the first invalid character to be ignored. (e.g.\r\n      // 'abxxcd' will be treated as 'ab')\r\n      buf = buf.slice(0, actual)\r\n    }\r\n\r\n    return buf\r\n  }\r\n\r\n  function fromArrayLike (array) {\r\n    var length = array.length < 0 ? 0 : checked(array.length) | 0\r\n    var buf = createBuffer(length)\r\n    for (var i = 0; i < length; i += 1) {\r\n      buf[i] = array[i] & 255\r\n    }\r\n    return buf\r\n  }\r\n\r\n  function fromArrayBuffer (array, byteOffset, length) {\r\n    if (byteOffset < 0 || array.byteLength < byteOffset) {\r\n      throw new RangeError('\"offset\" is outside of buffer bounds')\r\n    }\r\n\r\n    if (array.byteLength < byteOffset + (length || 0)) {\r\n      throw new RangeError('\"length\" is outside of buffer bounds')\r\n    }\r\n\r\n    var buf\r\n    if (byteOffset === undefined && length === undefined) {\r\n      buf = new Uint8Array(array)\r\n    } else if (length === undefined) {\r\n      buf = new Uint8Array(array, byteOffset)\r\n    } else {\r\n      buf = new Uint8Array(array, byteOffset, length)\r\n    }\r\n\r\n    // Return an augmented `Uint8Array` instance\r\n    buf.__proto__ = Buffer.prototype\r\n    return buf\r\n  }\r\n\r\n  function fromObject (obj) {\r\n    if (Buffer.isBuffer(obj)) {\r\n      var len = checked(obj.length) | 0\r\n      var buf = createBuffer(len)\r\n\r\n      if (buf.length === 0) {\r\n        return buf\r\n      }\r\n\r\n      obj.copy(buf, 0, 0, len)\r\n      return buf\r\n    }\r\n\r\n    if (obj) {\r\n      if (ArrayBuffer.isView(obj) || 'length' in obj) {\r\n        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\r\n          return createBuffer(0)\r\n        }\r\n        return fromArrayLike(obj)\r\n      }\r\n\r\n      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\r\n        return fromArrayLike(obj.data)\r\n      }\r\n    }\r\n\r\n    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object.')\r\n  }\r\n\r\n  function checked (length) {\r\n    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\r\n    // length is NaN (which is otherwise coerced to zero.)\r\n    if (length >= K_MAX_LENGTH) {\r\n      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\r\n                           'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\r\n    }\r\n    return length | 0\r\n  }\r\n\r\n  function SlowBuffer (length) {\r\n    if (+length != length) { // eslint-disable-line eqeqeq\r\n      length = 0\r\n    }\r\n    return Buffer.alloc(+length)\r\n  }\r\n\r\n  Buffer.isBuffer = function isBuffer (b) {\r\n    return b != null && b._isBuffer === true\r\n  }\r\n\r\n  Buffer.compare = function compare (a, b) {\r\n    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\r\n      throw new TypeError('Arguments must be Buffers')\r\n    }\r\n\r\n    if (a === b) return 0\r\n\r\n    var x = a.length\r\n    var y = b.length\r\n\r\n    for (var i = 0, len = Math.min(x, y); i < len; ++i) {\r\n      if (a[i] !== b[i]) {\r\n        x = a[i]\r\n        y = b[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  Buffer.isEncoding = function isEncoding (encoding) {\r\n    switch (String(encoding).toLowerCase()) {\r\n      case 'hex':\r\n      case 'utf8':\r\n      case 'utf-8':\r\n      case 'ascii':\r\n      case 'latin1':\r\n      case 'binary':\r\n      case 'base64':\r\n      case 'ucs2':\r\n      case 'ucs-2':\r\n      case 'utf16le':\r\n      case 'utf-16le':\r\n        return true\r\n      default:\r\n        return false\r\n    }\r\n  }\r\n\r\n  Buffer.concat = function concat (list, length) {\r\n    if (!Array.isArray(list)) {\r\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n    }\r\n\r\n    if (list.length === 0) {\r\n      return Buffer.alloc(0)\r\n    }\r\n\r\n    var i\r\n    if (length === undefined) {\r\n      length = 0\r\n      for (i = 0; i < list.length; ++i) {\r\n        length += list[i].length\r\n      }\r\n    }\r\n\r\n    var buffer = Buffer.allocUnsafe(length)\r\n    var pos = 0\r\n    for (i = 0; i < list.length; ++i) {\r\n      var buf = list[i]\r\n      if (ArrayBuffer.isView(buf)) {\r\n        buf = Buffer.from(buf)\r\n      }\r\n      if (!Buffer.isBuffer(buf)) {\r\n        throw new TypeError('\"list\" argument must be an Array of Buffers')\r\n      }\r\n      buf.copy(buffer, pos)\r\n      pos += buf.length\r\n    }\r\n    return buffer\r\n  }\r\n\r\n  function byteLength (string, encoding) {\r\n    if (Buffer.isBuffer(string)) {\r\n      return string.length\r\n    }\r\n    if (ArrayBuffer.isView(string) || isArrayBuffer(string)) {\r\n      return string.byteLength\r\n    }\r\n    if (typeof string !== 'string') {\r\n      string = '' + string\r\n    }\r\n\r\n    var len = string.length\r\n    if (len === 0) return 0\r\n\r\n    // Use a for loop to avoid recursion\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'ascii':\r\n        case 'latin1':\r\n        case 'binary':\r\n          return len\r\n        case 'utf8':\r\n        case 'utf-8':\r\n        case undefined:\r\n          return utf8ToBytes(string).length\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return len * 2\r\n        case 'hex':\r\n          return len >>> 1\r\n        case 'base64':\r\n          return base64ToBytes(string).length\r\n        default:\r\n          if (loweredCase) return utf8ToBytes(string).length // assume utf8\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n  Buffer.byteLength = byteLength\r\n\r\n  function slowToString (encoding, start, end) {\r\n    var loweredCase = false\r\n\r\n    // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\r\n    // property of a typed array.\r\n\r\n    // This behaves neither like String nor Uint8Array in that we set start/end\r\n    // to their upper/lower bounds if the value passed is out of range.\r\n    // undefined is handled specially as per ECMA-262 6th Edition,\r\n    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\r\n    if (start === undefined || start < 0) {\r\n      start = 0\r\n    }\r\n    // Return early if start > this.length. Done here to prevent potential uint32\r\n    // coercion fail below.\r\n    if (start > this.length) {\r\n      return ''\r\n    }\r\n\r\n    if (end === undefined || end > this.length) {\r\n      end = this.length\r\n    }\r\n\r\n    if (end <= 0) {\r\n      return ''\r\n    }\r\n\r\n    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\r\n    end >>>= 0\r\n    start >>>= 0\r\n\r\n    if (end <= start) {\r\n      return ''\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    while (true) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexSlice(this, start, end)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Slice(this, start, end)\r\n\r\n        case 'ascii':\r\n          return asciiSlice(this, start, end)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Slice(this, start, end)\r\n\r\n        case 'base64':\r\n          return base64Slice(this, start, end)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return utf16leSlice(this, start, end)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = (encoding + '').toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\r\n  // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\r\n  // reliably in a browserify context because there could be multiple different\r\n  // copies of the 'buffer' package in use. This method works even for Buffer\r\n  // instances that were created from another copy of the `buffer` package.\r\n  // See: https://github.com/feross/buffer/issues/154\r\n  Buffer.prototype._isBuffer = true\r\n\r\n  function swap (b, n, m) {\r\n    var i = b[n]\r\n    b[n] = b[m]\r\n    b[m] = i\r\n  }\r\n\r\n  Buffer.prototype.swap16 = function swap16 () {\r\n    var len = this.length\r\n    if (len % 2 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 16-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 2) {\r\n      swap(this, i, i + 1)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap32 = function swap32 () {\r\n    var len = this.length\r\n    if (len % 4 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 32-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 4) {\r\n      swap(this, i, i + 3)\r\n      swap(this, i + 1, i + 2)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.swap64 = function swap64 () {\r\n    var len = this.length\r\n    if (len % 8 !== 0) {\r\n      throw new RangeError('Buffer size must be a multiple of 64-bits')\r\n    }\r\n    for (var i = 0; i < len; i += 8) {\r\n      swap(this, i, i + 7)\r\n      swap(this, i + 1, i + 6)\r\n      swap(this, i + 2, i + 5)\r\n      swap(this, i + 3, i + 4)\r\n    }\r\n    return this\r\n  }\r\n\r\n  Buffer.prototype.toString = function toString () {\r\n    var length = this.length\r\n    if (length === 0) return ''\r\n    if (arguments.length === 0) return utf8Slice(this, 0, length)\r\n    return slowToString.apply(this, arguments)\r\n  }\r\n\r\n  Buffer.prototype.toLocaleString = Buffer.prototype.toString\r\n\r\n  Buffer.prototype.equals = function equals (b) {\r\n    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\r\n    if (this === b) return true\r\n    return Buffer.compare(this, b) === 0\r\n  }\r\n\r\n  Buffer.prototype.inspect = function inspect () {\r\n    var str = ''\r\n    var max = Buffer.INSPECT_MAX_BYTES\r\n    if (this.length > 0) {\r\n      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\r\n      if (this.length > max) str += ' ... '\r\n    }\r\n    return '<Buffer ' + str + '>'\r\n  }\r\n\r\n  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\r\n    if (!Buffer.isBuffer(target)) {\r\n      throw new TypeError('Argument must be a Buffer')\r\n    }\r\n\r\n    if (start === undefined) {\r\n      start = 0\r\n    }\r\n    if (end === undefined) {\r\n      end = target ? target.length : 0\r\n    }\r\n    if (thisStart === undefined) {\r\n      thisStart = 0\r\n    }\r\n    if (thisEnd === undefined) {\r\n      thisEnd = this.length\r\n    }\r\n\r\n    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\r\n      throw new RangeError('out of range index')\r\n    }\r\n\r\n    if (thisStart >= thisEnd && start >= end) {\r\n      return 0\r\n    }\r\n    if (thisStart >= thisEnd) {\r\n      return -1\r\n    }\r\n    if (start >= end) {\r\n      return 1\r\n    }\r\n\r\n    start >>>= 0\r\n    end >>>= 0\r\n    thisStart >>>= 0\r\n    thisEnd >>>= 0\r\n\r\n    if (this === target) return 0\r\n\r\n    var x = thisEnd - thisStart\r\n    var y = end - start\r\n    var len = Math.min(x, y)\r\n\r\n    var thisCopy = this.slice(thisStart, thisEnd)\r\n    var targetCopy = target.slice(start, end)\r\n\r\n    for (var i = 0; i < len; ++i) {\r\n      if (thisCopy[i] !== targetCopy[i]) {\r\n        x = thisCopy[i]\r\n        y = targetCopy[i]\r\n        break\r\n      }\r\n    }\r\n\r\n    if (x < y) return -1\r\n    if (y < x) return 1\r\n    return 0\r\n  }\r\n\r\n  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\r\n  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\r\n  //\r\n  // Arguments:\r\n  // - buffer - a Buffer to search\r\n  // - val - a string, Buffer, or number\r\n  // - byteOffset - an index into `buffer`; will be clamped to an int32\r\n  // - encoding - an optional encoding, relevant is val is a string\r\n  // - dir - true for indexOf, false for lastIndexOf\r\n  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\r\n    // Empty buffer means no match\r\n    if (buffer.length === 0) return -1\r\n\r\n    // Normalize byteOffset\r\n    if (typeof byteOffset === 'string') {\r\n      encoding = byteOffset\r\n      byteOffset = 0\r\n    } else if (byteOffset > 0x7fffffff) {\r\n      byteOffset = 0x7fffffff\r\n    } else if (byteOffset < -0x80000000) {\r\n      byteOffset = -0x80000000\r\n    }\r\n    byteOffset = +byteOffset  // Coerce to Number.\r\n    if (numberIsNaN(byteOffset)) {\r\n      // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\r\n      byteOffset = dir ? 0 : (buffer.length - 1)\r\n    }\r\n\r\n    // Normalize byteOffset: negative offsets start from the end of the buffer\r\n    if (byteOffset < 0) byteOffset = buffer.length + byteOffset\r\n    if (byteOffset >= buffer.length) {\r\n      if (dir) return -1\r\n      else byteOffset = buffer.length - 1\r\n    } else if (byteOffset < 0) {\r\n      if (dir) byteOffset = 0\r\n      else return -1\r\n    }\r\n\r\n    // Normalize val\r\n    if (typeof val === 'string') {\r\n      val = Buffer.from(val, encoding)\r\n    }\r\n\r\n    // Finally, search either indexOf (if dir is true) or lastIndexOf\r\n    if (Buffer.isBuffer(val)) {\r\n      // Special case: looking for empty string/buffer always fails\r\n      if (val.length === 0) {\r\n        return -1\r\n      }\r\n      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\r\n    } else if (typeof val === 'number') {\r\n      val = val & 0xFF // Search for a byte value [0-255]\r\n      if (typeof Uint8Array.prototype.indexOf === 'function') {\r\n        if (dir) {\r\n          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\r\n        } else {\r\n          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\r\n        }\r\n      }\r\n      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\r\n    }\r\n\r\n    throw new TypeError('val must be string, number or Buffer')\r\n  }\r\n\r\n  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {\r\n    var indexSize = 1\r\n    var arrLength = arr.length\r\n    var valLength = val.length\r\n\r\n    if (encoding !== undefined) {\r\n      encoding = String(encoding).toLowerCase()\r\n      if (encoding === 'ucs2' || encoding === 'ucs-2' ||\r\n          encoding === 'utf16le' || encoding === 'utf-16le') {\r\n        if (arr.length < 2 || val.length < 2) {\r\n          return -1\r\n        }\r\n        indexSize = 2\r\n        arrLength /= 2\r\n        valLength /= 2\r\n        byteOffset /= 2\r\n      }\r\n    }\r\n\r\n    function read (buf, i) {\r\n      if (indexSize === 1) {\r\n        return buf[i]\r\n      } else {\r\n        return buf.readUInt16BE(i * indexSize)\r\n      }\r\n    }\r\n\r\n    var i\r\n    if (dir) {\r\n      var foundIndex = -1\r\n      for (i = byteOffset; i < arrLength; i++) {\r\n        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\r\n          if (foundIndex === -1) foundIndex = i\r\n          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\r\n        } else {\r\n          if (foundIndex !== -1) i -= i - foundIndex\r\n          foundIndex = -1\r\n        }\r\n      }\r\n    } else {\r\n      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\r\n      for (i = byteOffset; i >= 0; i--) {\r\n        var found = true\r\n        for (var j = 0; j < valLength; j++) {\r\n          if (read(arr, i + j) !== read(val, j)) {\r\n            found = false\r\n            break\r\n          }\r\n        }\r\n        if (found) return i\r\n      }\r\n    }\r\n\r\n    return -1\r\n  }\r\n\r\n  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {\r\n    return this.indexOf(val, byteOffset, encoding) !== -1\r\n  }\r\n\r\n  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\r\n  }\r\n\r\n  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\r\n    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\r\n  }\r\n\r\n  function hexWrite (buf, string, offset, length) {\r\n    offset = Number(offset) || 0\r\n    var remaining = buf.length - offset\r\n    if (!length) {\r\n      length = remaining\r\n    } else {\r\n      length = Number(length)\r\n      if (length > remaining) {\r\n        length = remaining\r\n      }\r\n    }\r\n\r\n    var strLen = string.length\r\n\r\n    if (length > strLen / 2) {\r\n      length = strLen / 2\r\n    }\r\n    for (var i = 0; i < length; ++i) {\r\n      var parsed = parseInt(string.substr(i * 2, 2), 16)\r\n      if (numberIsNaN(parsed)) return i\r\n      buf[offset + i] = parsed\r\n    }\r\n    return i\r\n  }\r\n\r\n  function utf8Write (buf, string, offset, length) {\r\n    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  function asciiWrite (buf, string, offset, length) {\r\n    return blitBuffer(asciiToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function latin1Write (buf, string, offset, length) {\r\n    return asciiWrite(buf, string, offset, length)\r\n  }\r\n\r\n  function base64Write (buf, string, offset, length) {\r\n    return blitBuffer(base64ToBytes(string), buf, offset, length)\r\n  }\r\n\r\n  function ucs2Write (buf, string, offset, length) {\r\n    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\r\n  }\r\n\r\n  Buffer.prototype.write = function write (string, offset, length, encoding) {\r\n    // Buffer#write(string)\r\n    if (offset === undefined) {\r\n      encoding = 'utf8'\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, encoding)\r\n    } else if (length === undefined && typeof offset === 'string') {\r\n      encoding = offset\r\n      length = this.length\r\n      offset = 0\r\n    // Buffer#write(string, offset[, length][, encoding])\r\n    } else if (isFinite(offset)) {\r\n      offset = offset >>> 0\r\n      if (isFinite(length)) {\r\n        length = length >>> 0\r\n        if (encoding === undefined) encoding = 'utf8'\r\n      } else {\r\n        encoding = length\r\n        length = undefined\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        'Buffer.write(string, encoding, offset[, length]) is no longer supported'\r\n      )\r\n    }\r\n\r\n    var remaining = this.length - offset\r\n    if (length === undefined || length > remaining) length = remaining\r\n\r\n    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\r\n      throw new RangeError('Attempt to write outside buffer bounds')\r\n    }\r\n\r\n    if (!encoding) encoding = 'utf8'\r\n\r\n    var loweredCase = false\r\n    for (;;) {\r\n      switch (encoding) {\r\n        case 'hex':\r\n          return hexWrite(this, string, offset, length)\r\n\r\n        case 'utf8':\r\n        case 'utf-8':\r\n          return utf8Write(this, string, offset, length)\r\n\r\n        case 'ascii':\r\n          return asciiWrite(this, string, offset, length)\r\n\r\n        case 'latin1':\r\n        case 'binary':\r\n          return latin1Write(this, string, offset, length)\r\n\r\n        case 'base64':\r\n          // Warning: maxLength not taken into account in base64Write\r\n          return base64Write(this, string, offset, length)\r\n\r\n        case 'ucs2':\r\n        case 'ucs-2':\r\n        case 'utf16le':\r\n        case 'utf-16le':\r\n          return ucs2Write(this, string, offset, length)\r\n\r\n        default:\r\n          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\r\n          encoding = ('' + encoding).toLowerCase()\r\n          loweredCase = true\r\n      }\r\n    }\r\n  }\r\n\r\n  Buffer.prototype.toJSON = function toJSON () {\r\n    return {\r\n      type: 'Buffer',\r\n      data: Array.prototype.slice.call(this._arr || this, 0)\r\n    }\r\n  }\r\n\r\n  function base64Slice (buf, start, end) {\r\n    if (start === 0 && end === buf.length) {\r\n      return base64.fromByteArray(buf)\r\n    } else {\r\n      return base64.fromByteArray(buf.slice(start, end))\r\n    }\r\n  }\r\n\r\n  function utf8Slice (buf, start, end) {\r\n    end = Math.min(buf.length, end)\r\n    var res = []\r\n\r\n    var i = start\r\n    while (i < end) {\r\n      var firstByte = buf[i]\r\n      var codePoint = null\r\n      var bytesPerSequence = (firstByte > 0xEF) ? 4\r\n        : (firstByte > 0xDF) ? 3\r\n        : (firstByte > 0xBF) ? 2\r\n        : 1\r\n\r\n      if (i + bytesPerSequence <= end) {\r\n        var secondByte, thirdByte, fourthByte, tempCodePoint\r\n\r\n        switch (bytesPerSequence) {\r\n          case 1:\r\n            if (firstByte < 0x80) {\r\n              codePoint = firstByte\r\n            }\r\n            break\r\n          case 2:\r\n            secondByte = buf[i + 1]\r\n            if ((secondByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\r\n              if (tempCodePoint > 0x7F) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 3:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\r\n              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n            break\r\n          case 4:\r\n            secondByte = buf[i + 1]\r\n            thirdByte = buf[i + 2]\r\n            fourthByte = buf[i + 3]\r\n            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\r\n              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\r\n              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\r\n                codePoint = tempCodePoint\r\n              }\r\n            }\r\n        }\r\n      }\r\n\r\n      if (codePoint === null) {\r\n        // we did not generate a valid codePoint so insert a\r\n        // replacement char (U+FFFD) and advance only 1 byte\r\n        codePoint = 0xFFFD\r\n        bytesPerSequence = 1\r\n      } else if (codePoint > 0xFFFF) {\r\n        // encode to utf16 (surrogate pair dance)\r\n        codePoint -= 0x10000\r\n        res.push(codePoint >>> 10 & 0x3FF | 0xD800)\r\n        codePoint = 0xDC00 | codePoint & 0x3FF\r\n      }\r\n\r\n      res.push(codePoint)\r\n      i += bytesPerSequence\r\n    }\r\n\r\n    return decodeCodePointsArray(res)\r\n  }\r\n\r\n  // Based on http://stackoverflow.com/a/22747272/680742, the browser with\r\n  // the lowest limit is Chrome, with 0x10000 args.\r\n  // We go 1 magnitude less, for safety\r\n  var MAX_ARGUMENTS_LENGTH = 0x1000\r\n\r\n  function decodeCodePointsArray (codePoints) {\r\n    var len = codePoints.length\r\n    if (len <= MAX_ARGUMENTS_LENGTH) {\r\n      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\r\n    }\r\n\r\n    // Decode in chunks to avoid \"call stack size exceeded\".\r\n    var res = ''\r\n    var i = 0\r\n    while (i < len) {\r\n      res += String.fromCharCode.apply(\r\n        String,\r\n        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\r\n      )\r\n    }\r\n    return res\r\n  }\r\n\r\n  function asciiSlice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i] & 0x7F)\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function latin1Slice (buf, start, end) {\r\n    var ret = ''\r\n    end = Math.min(buf.length, end)\r\n\r\n    for (var i = start; i < end; ++i) {\r\n      ret += String.fromCharCode(buf[i])\r\n    }\r\n    return ret\r\n  }\r\n\r\n  function hexSlice (buf, start, end) {\r\n    var len = buf.length\r\n\r\n    if (!start || start < 0) start = 0\r\n    if (!end || end < 0 || end > len) end = len\r\n\r\n    var out = ''\r\n    for (var i = start; i < end; ++i) {\r\n      out += toHex(buf[i])\r\n    }\r\n    return out\r\n  }\r\n\r\n  function utf16leSlice (buf, start, end) {\r\n    var bytes = buf.slice(start, end)\r\n    var res = ''\r\n    for (var i = 0; i < bytes.length; i += 2) {\r\n      res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\r\n    }\r\n    return res\r\n  }\r\n\r\n  Buffer.prototype.slice = function slice (start, end) {\r\n    var len = this.length\r\n    start = ~~start\r\n    end = end === undefined ? len : ~~end\r\n\r\n    if (start < 0) {\r\n      start += len\r\n      if (start < 0) start = 0\r\n    } else if (start > len) {\r\n      start = len\r\n    }\r\n\r\n    if (end < 0) {\r\n      end += len\r\n      if (end < 0) end = 0\r\n    } else if (end > len) {\r\n      end = len\r\n    }\r\n\r\n    if (end < start) end = start\r\n\r\n    var newBuf = this.subarray(start, end)\r\n    // Return an augmented `Uint8Array` instance\r\n    newBuf.__proto__ = Buffer.prototype\r\n    return newBuf\r\n  }\r\n\r\n  /*\r\n   * Need to make sure that buffer isn't trying to write out of bounds.\r\n   */\r\n  function checkOffset (offset, ext, length) {\r\n    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\r\n    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\r\n  }\r\n\r\n  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      checkOffset(offset, byteLength, this.length)\r\n    }\r\n\r\n    var val = this[offset + --byteLength]\r\n    var mul = 1\r\n    while (byteLength > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --byteLength] * mul\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    return this[offset]\r\n  }\r\n\r\n  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return this[offset] | (this[offset + 1] << 8)\r\n  }\r\n\r\n  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    return (this[offset] << 8) | this[offset + 1]\r\n  }\r\n\r\n  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return ((this[offset]) |\r\n        (this[offset + 1] << 8) |\r\n        (this[offset + 2] << 16)) +\r\n        (this[offset + 3] * 0x1000000)\r\n  }\r\n\r\n  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] * 0x1000000) +\r\n      ((this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var val = this[offset]\r\n    var mul = 1\r\n    var i = 0\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      val += this[offset + i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) checkOffset(offset, byteLength, this.length)\r\n\r\n    var i = byteLength\r\n    var mul = 1\r\n    var val = this[offset + --i]\r\n    while (i > 0 && (mul *= 0x100)) {\r\n      val += this[offset + --i] * mul\r\n    }\r\n    mul *= 0x80\r\n\r\n    if (val >= mul) val -= Math.pow(2, 8 * byteLength)\r\n\r\n    return val\r\n  }\r\n\r\n  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 1, this.length)\r\n    if (!(this[offset] & 0x80)) return (this[offset])\r\n    return ((0xff - this[offset] + 1) * -1)\r\n  }\r\n\r\n  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset] | (this[offset + 1] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 2, this.length)\r\n    var val = this[offset + 1] | (this[offset] << 8)\r\n    return (val & 0x8000) ? val | 0xFFFF0000 : val\r\n  }\r\n\r\n  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset]) |\r\n      (this[offset + 1] << 8) |\r\n      (this[offset + 2] << 16) |\r\n      (this[offset + 3] << 24)\r\n  }\r\n\r\n  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n\r\n    return (this[offset] << 24) |\r\n      (this[offset + 1] << 16) |\r\n      (this[offset + 2] << 8) |\r\n      (this[offset + 3])\r\n  }\r\n\r\n  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, true, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 4, this.length)\r\n    return ieee754.read(this, offset, false, 23, 4)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, true, 52, 8)\r\n  }\r\n\r\n  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkOffset(offset, 8, this.length)\r\n    return ieee754.read(this, offset, false, 52, 8)\r\n  }\r\n\r\n  function checkInt (buf, value, offset, ext, max, min) {\r\n    if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\r\n    if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var mul = 1\r\n    var i = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    byteLength = byteLength >>> 0\r\n    if (!noAssert) {\r\n      var maxBytes = Math.pow(2, 8 * byteLength) - 1\r\n      checkInt(this, value, offset, byteLength, maxBytes, 0)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      this[offset + i] = (value / mul) & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset + 3] = (value >>> 24)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = 0\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset] = value & 0xFF\r\n    while (++i < byteLength && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      var limit = Math.pow(2, (8 * byteLength) - 1)\r\n\r\n      checkInt(this, value, offset, byteLength, limit - 1, -limit)\r\n    }\r\n\r\n    var i = byteLength - 1\r\n    var mul = 1\r\n    var sub = 0\r\n    this[offset + i] = value & 0xFF\r\n    while (--i >= 0 && (mul *= 0x100)) {\r\n      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\r\n        sub = 1\r\n      }\r\n      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\r\n    }\r\n\r\n    return offset + byteLength\r\n  }\r\n\r\n  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\r\n    if (value < 0) value = 0xff + value + 1\r\n    this[offset] = (value & 0xff)\r\n    return offset + 1\r\n  }\r\n\r\n  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\r\n    this[offset] = (value >>> 8)\r\n    this[offset + 1] = (value & 0xff)\r\n    return offset + 2\r\n  }\r\n\r\n  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    this[offset] = (value & 0xff)\r\n    this[offset + 1] = (value >>> 8)\r\n    this[offset + 2] = (value >>> 16)\r\n    this[offset + 3] = (value >>> 24)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\r\n    if (value < 0) value = 0xffffffff + value + 1\r\n    this[offset] = (value >>> 24)\r\n    this[offset + 1] = (value >>> 16)\r\n    this[offset + 2] = (value >>> 8)\r\n    this[offset + 3] = (value & 0xff)\r\n    return offset + 4\r\n  }\r\n\r\n  function checkIEEE754 (buf, value, offset, ext, max, min) {\r\n    if (offset + ext > buf.length) throw new RangeError('Index out of range')\r\n    if (offset < 0) throw new RangeError('Index out of range')\r\n  }\r\n\r\n  function writeFloat (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 23, 4)\r\n    return offset + 4\r\n  }\r\n\r\n  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\r\n    return writeFloat(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  function writeDouble (buf, value, offset, littleEndian, noAssert) {\r\n    value = +value\r\n    offset = offset >>> 0\r\n    if (!noAssert) {\r\n      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\r\n    }\r\n    ieee754.write(buf, value, offset, littleEndian, 52, 8)\r\n    return offset + 8\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, true, noAssert)\r\n  }\r\n\r\n  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\r\n    return writeDouble(this, value, offset, false, noAssert)\r\n  }\r\n\r\n  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\r\n  Buffer.prototype.copy = function copy (target, targetStart, start, end) {\r\n    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\r\n    if (!start) start = 0\r\n    if (!end && end !== 0) end = this.length\r\n    if (targetStart >= target.length) targetStart = target.length\r\n    if (!targetStart) targetStart = 0\r\n    if (end > 0 && end < start) end = start\r\n\r\n    // Copy 0 bytes; we're done\r\n    if (end === start) return 0\r\n    if (target.length === 0 || this.length === 0) return 0\r\n\r\n    // Fatal error conditions\r\n    if (targetStart < 0) {\r\n      throw new RangeError('targetStart out of bounds')\r\n    }\r\n    if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\r\n    if (end < 0) throw new RangeError('sourceEnd out of bounds')\r\n\r\n    // Are we oob?\r\n    if (end > this.length) end = this.length\r\n    if (target.length - targetStart < end - start) {\r\n      end = target.length - targetStart + start\r\n    }\r\n\r\n    var len = end - start\r\n\r\n    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\r\n      // Use built-in when available, missing from IE11\r\n      this.copyWithin(targetStart, start, end)\r\n    } else if (this === target && start < targetStart && targetStart < end) {\r\n      // descending copy from end\r\n      for (var i = len - 1; i >= 0; --i) {\r\n        target[i + targetStart] = this[i + start]\r\n      }\r\n    } else {\r\n      Uint8Array.prototype.set.call(\r\n        target,\r\n        this.subarray(start, end),\r\n        targetStart\r\n      )\r\n    }\r\n\r\n    return len\r\n  }\r\n\r\n  // Usage:\r\n  //    buffer.fill(number[, offset[, end]])\r\n  //    buffer.fill(buffer[, offset[, end]])\r\n  //    buffer.fill(string[, offset[, end]][, encoding])\r\n  Buffer.prototype.fill = function fill (val, start, end, encoding) {\r\n    // Handle string cases:\r\n    if (typeof val === 'string') {\r\n      if (typeof start === 'string') {\r\n        encoding = start\r\n        start = 0\r\n        end = this.length\r\n      } else if (typeof end === 'string') {\r\n        encoding = end\r\n        end = this.length\r\n      }\r\n      if (encoding !== undefined && typeof encoding !== 'string') {\r\n        throw new TypeError('encoding must be a string')\r\n      }\r\n      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\r\n        throw new TypeError('Unknown encoding: ' + encoding)\r\n      }\r\n      if (val.length === 1) {\r\n        var code = val.charCodeAt(0)\r\n        if ((encoding === 'utf8' && code < 128) ||\r\n            encoding === 'latin1') {\r\n          // Fast path: If `val` fits into a single byte, use that numeric value.\r\n          val = code\r\n        }\r\n      }\r\n    } else if (typeof val === 'number') {\r\n      val = val & 255\r\n    }\r\n\r\n    // Invalid ranges are not set to a default, so can range check early.\r\n    if (start < 0 || this.length < start || this.length < end) {\r\n      throw new RangeError('Out of range index')\r\n    }\r\n\r\n    if (end <= start) {\r\n      return this\r\n    }\r\n\r\n    start = start >>> 0\r\n    end = end === undefined ? this.length : end >>> 0\r\n\r\n    if (!val) val = 0\r\n\r\n    var i\r\n    if (typeof val === 'number') {\r\n      for (i = start; i < end; ++i) {\r\n        this[i] = val\r\n      }\r\n    } else {\r\n      var bytes = Buffer.isBuffer(val)\r\n        ? val\r\n        : new Buffer(val, encoding)\r\n      var len = bytes.length\r\n      if (len === 0) {\r\n        throw new TypeError('The value \"' + val +\r\n          '\" is invalid for argument \"value\"')\r\n      }\r\n      for (i = 0; i < end - start; ++i) {\r\n        this[i + start] = bytes[i % len]\r\n      }\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // HELPER FUNCTIONS\r\n  // ================\r\n\r\n  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\r\n\r\n  function base64clean (str) {\r\n    // Node takes equal signs as end of the Base64 encoding\r\n    str = str.split('=')[0]\r\n    // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\r\n    str = str.trim().replace(INVALID_BASE64_RE, '')\r\n    // Node converts strings with length < 2 to ''\r\n    if (str.length < 2) return ''\r\n    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\r\n    while (str.length % 4 !== 0) {\r\n      str = str + '='\r\n    }\r\n    return str\r\n  }\r\n\r\n  function toHex (n) {\r\n    if (n < 16) return '0' + n.toString(16)\r\n    return n.toString(16)\r\n  }\r\n\r\n  function utf8ToBytes (string, units) {\r\n    units = units || Infinity\r\n    var codePoint\r\n    var length = string.length\r\n    var leadSurrogate = null\r\n    var bytes = []\r\n\r\n    for (var i = 0; i < length; ++i) {\r\n      codePoint = string.charCodeAt(i)\r\n\r\n      // is surrogate component\r\n      if (codePoint > 0xD7FF && codePoint < 0xE000) {\r\n        // last char was a lead\r\n        if (!leadSurrogate) {\r\n          // no lead yet\r\n          if (codePoint > 0xDBFF) {\r\n            // unexpected trail\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          } else if (i + 1 === length) {\r\n            // unpaired lead\r\n            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n            continue\r\n          }\r\n\r\n          // valid lead\r\n          leadSurrogate = codePoint\r\n\r\n          continue\r\n        }\r\n\r\n        // 2 leads in a row\r\n        if (codePoint < 0xDC00) {\r\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n          leadSurrogate = codePoint\r\n          continue\r\n        }\r\n\r\n        // valid surrogate pair\r\n        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\r\n      } else if (leadSurrogate) {\r\n        // valid bmp char, but last char was a lead\r\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\r\n      }\r\n\r\n      leadSurrogate = null\r\n\r\n      // encode utf8\r\n      if (codePoint < 0x80) {\r\n        if ((units -= 1) < 0) break\r\n        bytes.push(codePoint)\r\n      } else if (codePoint < 0x800) {\r\n        if ((units -= 2) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x6 | 0xC0,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x10000) {\r\n        if ((units -= 3) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0xC | 0xE0,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else if (codePoint < 0x110000) {\r\n        if ((units -= 4) < 0) break\r\n        bytes.push(\r\n          codePoint >> 0x12 | 0xF0,\r\n          codePoint >> 0xC & 0x3F | 0x80,\r\n          codePoint >> 0x6 & 0x3F | 0x80,\r\n          codePoint & 0x3F | 0x80\r\n        )\r\n      } else {\r\n        throw new Error('Invalid code point')\r\n      }\r\n    }\r\n\r\n    return bytes\r\n  }\r\n\r\n  function asciiToBytes (str) {\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      // Node's code seems to be doing this and not & 0x7F..\r\n      byteArray.push(str.charCodeAt(i) & 0xFF)\r\n    }\r\n    return byteArray\r\n  }\r\n\r\n  function utf16leToBytes (str, units) {\r\n    var c, hi, lo\r\n    var byteArray = []\r\n    for (var i = 0; i < str.length; ++i) {\r\n      if ((units -= 2) < 0) break\r\n\r\n      c = str.charCodeAt(i)\r\n      hi = c >> 8\r\n      lo = c % 256\r\n      byteArray.push(lo)\r\n      byteArray.push(hi)\r\n    }\r\n\r\n    return byteArray\r\n  }\r\n\r\n  function base64ToBytes (str) {\r\n    return base64.toByteArray(base64clean(str))\r\n  }\r\n\r\n  function blitBuffer (src, dst, offset, length) {\r\n    for (var i = 0; i < length; ++i) {\r\n      if ((i + offset >= dst.length) || (i >= src.length)) break\r\n      dst[i + offset] = src[i]\r\n    }\r\n    return i\r\n  }\r\n\r\n  // ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\r\n  // but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\r\n  function isArrayBuffer (obj) {\r\n    return obj instanceof ArrayBuffer ||\r\n      (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\r\n        typeof obj.byteLength === 'number')\r\n  }\r\n\r\n  function numberIsNaN (obj) {\r\n    return obj !== obj // eslint-disable-line no-self-compare\r\n  }\r\n\r\n  return binary.Buffer = Buffer;\r\n\r\n});\ndefine('skylark-data-files/error-strings',[\r\n  \"./files\",\r\n  \"./error-codes\"\r\n],function (files,ErrorCodes) {\r\n  'use strict';\r\n\r\n  /* tslint:disable:variable-name */\r\n  /**\r\n   * Strings associated with each error code.\r\n   * @hidden\r\n   */\r\n  const ErrorStrings = {};\r\n  ErrorStrings[ErrorCodes.EPERM] = 'Operation not permitted.';\r\n  ErrorStrings[ErrorCodes.ENOENT] = 'No such file or directory.';\r\n  ErrorStrings[ErrorCodes.EIO] = 'Input/output error.';\r\n  ErrorStrings[ErrorCodes.EBADF] = 'Bad file descriptor.';\r\n  ErrorStrings[ErrorCodes.EACCES] = 'Permission denied.';\r\n  ErrorStrings[ErrorCodes.EBUSY] = 'Resource busy or locked.';\r\n  ErrorStrings[ErrorCodes.EEXIST] = 'File exists.';\r\n  ErrorStrings[ErrorCodes.ENOTDIR] = 'File is not a directory.';\r\n  ErrorStrings[ErrorCodes.EISDIR] = 'File is a directory.';\r\n  ErrorStrings[ErrorCodes.EINVAL] = 'Invalid argument.';\r\n  ErrorStrings[ErrorCodes.EFBIG] = 'File is too big.';\r\n  ErrorStrings[ErrorCodes.ENOSPC] = 'No space left on disk.';\r\n  ErrorStrings[ErrorCodes.EROFS] = 'Cannot modify a read-only file system.';\r\n  ErrorStrings[ErrorCodes.ENOTEMPTY] = 'Directory is not empty.';\r\n  ErrorStrings[ErrorCodes.ENOTSUP] = 'Operation is not supported.';\r\n\r\n  return files.ErrorStrings = ErrorStrings;\r\n});\r\n  \ndefine('skylark-data-files/file-error',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    \"./error-strings\"\r\n],function (Buffer,files,ErrorCodes,ErrorStrings) {\r\n   'use strict';\r\n   \r\n\r\n    /* tslint:enable:variable-name */\r\n    /**\r\n     * Represents a BrowserFS error. Passed back to applications after a failed\r\n     * call to the BrowserFS API.\r\n     */\r\n    class FileError extends Error {\r\n        /**\r\n         * Represents a BrowserFS error. Passed back to applications after a failed\r\n         * call to the BrowserFS API.\r\n         *\r\n         * Error codes mirror those returned by regular Unix file operations, which is\r\n         * what Node returns.\r\n         * @constructor FileError\r\n         * @param type The type of the error.\r\n         * @param [message] A descriptive error message.\r\n         */\r\n        constructor(type, message = ErrorStrings[type], path) {\r\n            super(message);\r\n            // Unsupported.\r\n            this.syscall = \"\";\r\n            this.errno = type;\r\n            this.code = ErrorCodes[type];\r\n            this.path = path;\r\n            this.stack = new Error().stack;\r\n            this.message = `Error: ${this.code}: ${message}${this.path ? `, '${this.path}'` : ''}`;\r\n        }\r\n        static fromJSON(json) {\r\n            const err = new FileError(0);\r\n            err.errno = json.errno;\r\n            err.code = json.code;\r\n            err.path = json.path;\r\n            err.stack = json.stack;\r\n            err.message = json.message;\r\n            return err;\r\n        }\r\n        /**\r\n         * Creates an FileError object from a buffer.\r\n         */\r\n        static fromBuffer(buffer, i = 0) {\r\n            return FileError.fromJSON(JSON.parse(buffer.toString('utf8', i + 4, i + 4 + buffer.readUInt32LE(i))));\r\n        }\r\n        static create(code, p) {\r\n            return new FileError(code, ErrorStrings[code], p);\r\n        }\r\n        static ENOENT(path) {\r\n            return this.create(ErrorCodes.ENOENT, path);\r\n        }\r\n        static EEXIST(path) {\r\n            return this.create(ErrorCodes.EEXIST, path);\r\n        }\r\n        static EISDIR(path) {\r\n            return this.create(ErrorCodes.EISDIR, path);\r\n        }\r\n        static ENOTDIR(path) {\r\n            return this.create(ErrorCodes.ENOTDIR, path);\r\n        }\r\n        static EPERM(path) {\r\n            return this.create(ErrorCodes.EPERM, path);\r\n        }\r\n        static ENOTEMPTY(path) {\r\n            return this.create(ErrorCodes.ENOTEMPTY, path);\r\n        }\r\n        /**\r\n         * @return A friendly error message.\r\n         */\r\n        toString() {\r\n            return this.message;\r\n        }\r\n        toJSON() {\r\n            return {\r\n                errno: this.errno,\r\n                code: this.code,\r\n                path: this.path,\r\n                stack: this.stack,\r\n                message: this.message\r\n            };\r\n        }\r\n        /**\r\n         * Writes the API error into a buffer.\r\n         */\r\n        writeToBuffer(buffer = Buffer.alloc(this.bufferSize()), i = 0) {\r\n            const bytesWritten = buffer.write(JSON.stringify(this.toJSON()), i + 4);\r\n            buffer.writeUInt32LE(bytesWritten, i);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * The size of the API error in buffer-form in bytes.\r\n         */\r\n        bufferSize() {\r\n            // 4 bytes for string length.\r\n            return 4 + Buffer.byteLength(JSON.stringify(this.toJSON()));\r\n        }\r\n    }\r\n\r\n    return files.FileError = FileError;\r\n\r\n});\ndefine('skylark-data-files/base-file',[\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\"\r\n], function (files,ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Base class that contains shared implementations of functions for the file\r\n     * object.\r\n     */\r\n    class BaseFile {\r\n        sync(cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        datasync(cb) {\r\n            this.sync(cb);\r\n        }\r\n        datasyncSync() {\r\n            return this.syncSync();\r\n        }\r\n        chown(uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chmod(mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n    return files.BaseFile = BaseFile;\r\n});\ndefine('skylark-data-files/file-flag',[\r\n  \"./files\",\r\n  './error-codes',\r\n  \"./file-error\",\r\n  \"./action-type\"\r\n], function (files,ErrorCodes,FileError,ActionType) {\r\n    'use strict';\r\n\r\n\r\n\r\n  /**\r\n   * Represents one of the following file flags. A convenience object.\r\n   *\r\n   * * `'r'` - Open file for reading. An exception occurs if the file does not exist.\r\n   * * `'r+'` - Open file for reading and writing. An exception occurs if the file does not exist.\r\n   * * `'rs'` - Open file for reading in synchronous mode. Instructs the filesystem to not cache writes.\r\n   * * `'rs+'` - Open file for reading and writing, and opens the file in synchronous mode.\r\n   * * `'w'` - Open file for writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx'` - Like 'w' but opens the file in exclusive mode.\r\n   * * `'w+'` - Open file for reading and writing. The file is created (if it does not exist) or truncated (if it exists).\r\n   * * `'wx+'` - Like 'w+' but opens the file in exclusive mode.\r\n   * * `'a'` - Open file for appending. The file is created if it does not exist.\r\n   * * `'ax'` - Like 'a' but opens the file in exclusive mode.\r\n   * * `'a+'` - Open file for reading and appending. The file is created if it does not exist.\r\n   * * `'ax+'` - Like 'a+' but opens the file in exclusive mode.\r\n   *\r\n   * Exclusive mode ensures that the file path is newly created.\r\n   */\r\n  class FileFlag {\r\n      /**\r\n       * This should never be called directly.\r\n       * @param modeStr The string representing the mode\r\n       * @throw when the mode string is invalid\r\n       */\r\n      constructor(flagStr) {\r\n          this.flagStr = flagStr;\r\n          if (FileFlag.validFlagStrs.indexOf(flagStr) < 0) {\r\n              throw new FileError(ErrorCodes.EINVAL, \"Invalid flag: \" + flagStr);\r\n          }\r\n      }\r\n      /**\r\n       * Get an object representing the given file flag.\r\n       * @param modeStr The string representing the flag\r\n       * @return The FileFlag object representing the flag\r\n       * @throw when the flag string is invalid\r\n       */\r\n      static getFileFlag(flagStr) {\r\n          // Check cache first.\r\n          if (FileFlag.flagCache.hasOwnProperty(flagStr)) {\r\n              return FileFlag.flagCache[flagStr];\r\n          }\r\n          return FileFlag.flagCache[flagStr] = new FileFlag(flagStr);\r\n      }\r\n      /**\r\n       * Get the underlying flag string for this flag.\r\n       */\r\n      getFlagString() {\r\n          return this.flagStr;\r\n      }\r\n      /**\r\n       * Returns true if the file is readable.\r\n       */\r\n      isReadable() {\r\n          return this.flagStr.indexOf('r') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is writeable.\r\n       */\r\n      isWriteable() {\r\n          return this.flagStr.indexOf('w') !== -1 || this.flagStr.indexOf('a') !== -1 || this.flagStr.indexOf('+') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file mode should truncate.\r\n       */\r\n      isTruncating() {\r\n          return this.flagStr.indexOf('w') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is appendable.\r\n       */\r\n      isAppendable() {\r\n          return this.flagStr.indexOf('a') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in synchronous mode.\r\n       */\r\n      isSynchronous() {\r\n          return this.flagStr.indexOf('s') !== -1;\r\n      }\r\n      /**\r\n       * Returns true if the file is open in exclusive mode.\r\n       */\r\n      isExclusive() {\r\n          return this.flagStr.indexOf('x') !== -1;\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path existing.\r\n       */\r\n      pathExistsAction() {\r\n          if (this.isExclusive()) {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n          else if (this.isTruncating()) {\r\n              return ActionType.TRUNCATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.NOP;\r\n          }\r\n      }\r\n      /**\r\n       * Returns one of the static fields on this object that indicates the\r\n       * appropriate response to the path not existing.\r\n       */\r\n      pathNotExistsAction() {\r\n          if ((this.isWriteable() || this.isAppendable()) && this.flagStr !== 'r+') {\r\n              return ActionType.CREATE_FILE;\r\n          }\r\n          else {\r\n              return ActionType.THROW_EXCEPTION;\r\n          }\r\n      }\r\n  }\r\n  // Contains cached FileMode instances.\r\n  FileFlag.flagCache = {};\r\n  // Array of valid mode strings.\r\n  FileFlag.validFlagStrs = ['r', 'r+', 'rs', 'rs+', 'w', 'wx', 'w+', 'wx+', 'a', 'ax', 'a+', 'ax+'];\r\n\r\n\r\n\r\n  return files.FileFlag = FileFlag;\r\n});\ndefine('skylark-data-files/file-type',[\r\n  \"./files\"\r\n],function (files) {\r\n  'use strict';\r\n\r\n  /**\r\n    * Indicates the type of the given file. Applied to 'mode'.\r\n    */\r\n  var FileType;\r\n  (function (FileType) {\r\n      FileType[FileType[\"FILE\"] = 32768] = \"FILE\";\r\n      FileType[FileType[\"DIRECTORY\"] = 16384] = \"DIRECTORY\";\r\n      FileType[FileType[\"SYMLINK\"] = 40960] = \"SYMLINK\";\r\n  })(FileType || (FileType = {}));\r\n\r\n  return files.FileType = FileType;\r\n});\r\n  \ndefine('skylark-data-files/stats',[\r\n    'skylark-langx-binary/buffer',\r\n    \"./files\",\r\n    \"./file-type\"\r\n],function (Buffer,files,FileType) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Emulation of Node's `fs.Stats` object.\r\n     *\r\n     * Attribute descriptions are from `man 2 stat'\r\n     * @see http://nodejs.org/api/fs.html#fs_class_fs_stats\r\n     * @see http://man7.org/linux/man-pages/man2/stat.2.html\r\n     */\r\n    class Stats {\r\n        /**\r\n         * Provides information about a particular entry in the file system.\r\n         * @param itemType Type of the item (FILE, DIRECTORY, SYMLINK, or SOCKET)\r\n         * @param size Size of the item in bytes. For directories/symlinks,\r\n         *   this is normally the size of the struct that represents the item.\r\n         * @param mode Unix-style file mode (e.g. 0o644)\r\n         * @param atimeMs time of last access, in milliseconds since epoch\r\n         * @param mtimeMs time of last modification, in milliseconds since epoch\r\n         * @param ctimeMs time of last time file status was changed, in milliseconds since epoch\r\n         * @param birthtimeMs time of file creation, in milliseconds since epoch\r\n         */\r\n        constructor(itemType, size, mode, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {\r\n            /**\r\n             * UNSUPPORTED ATTRIBUTES\r\n             * I assume no one is going to need these details, although we could fake\r\n             * appropriate values if need be.\r\n             */\r\n            // ID of device containing file\r\n            this.dev = 0;\r\n            // inode number\r\n            this.ino = 0;\r\n            // device ID (if special file)\r\n            this.rdev = 0;\r\n            // number of hard links\r\n            this.nlink = 1;\r\n            // blocksize for file system I/O\r\n            this.blksize = 4096;\r\n            // @todo Maybe support these? atm, it's a one-user filesystem.\r\n            // user ID of owner\r\n            this.uid = 0;\r\n            // group ID of owner\r\n            this.gid = 0;\r\n            // XXX: Some file systems stash data on stats objects.\r\n            this.fileData = null;\r\n            this.size = size;\r\n            let currentTime = 0;\r\n            if (typeof (atimeMs) !== 'number') {\r\n                currentTime = Date.now();\r\n                atimeMs = currentTime;\r\n            }\r\n            if (typeof (mtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                mtimeMs = currentTime;\r\n            }\r\n            if (typeof (ctimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                ctimeMs = currentTime;\r\n            }\r\n            if (typeof (birthtimeMs) !== 'number') {\r\n                if (!currentTime) {\r\n                    currentTime = Date.now();\r\n                }\r\n                birthtimeMs = currentTime;\r\n            }\r\n            this.atimeMs = atimeMs;\r\n            this.ctimeMs = ctimeMs;\r\n            this.mtimeMs = mtimeMs;\r\n            this.birthtimeMs = birthtimeMs;\r\n            if (!mode) {\r\n                switch (itemType) {\r\n                    case FileType.FILE:\r\n                        this.mode = 0x1a4;\r\n                        break;\r\n                    case FileType.DIRECTORY:\r\n                    default:\r\n                        this.mode = 0x1ff;\r\n                }\r\n            }\r\n            else {\r\n                this.mode = mode;\r\n            }\r\n            // number of 512B blocks allocated\r\n            this.blocks = Math.ceil(size / 512);\r\n            // Check if mode also includes top-most bits, which indicate the file's\r\n            // type.\r\n            if (this.mode < 0x1000) {\r\n                this.mode |= itemType;\r\n            }\r\n        }\r\n        static fromBuffer(buffer) {\r\n            const size = buffer.readUInt32LE(0), mode = buffer.readUInt32LE(4), atime = buffer.readDoubleLE(8), mtime = buffer.readDoubleLE(16), ctime = buffer.readDoubleLE(24);\r\n            return new Stats(mode & 0xF000, size, mode & 0xFFF, atime, mtime, ctime);\r\n        }\r\n        /**\r\n         * Clones the stats object.\r\n         */\r\n        static clone(s) {\r\n            return new Stats(s.mode & 0xF000, s.size, s.mode & 0xFFF, s.atimeMs, s.mtimeMs, s.ctimeMs, s.birthtimeMs);\r\n        }\r\n        get atime() {\r\n            return new Date(this.atimeMs);\r\n        }\r\n        get mtime() {\r\n            return new Date(this.mtimeMs);\r\n        }\r\n        get ctime() {\r\n            return new Date(this.ctimeMs);\r\n        }\r\n        get birthtime() {\r\n            return new Date(this.birthtimeMs);\r\n        }\r\n        toBuffer() {\r\n            const buffer = Buffer.alloc(32);\r\n            buffer.writeUInt32LE(this.size, 0);\r\n            buffer.writeUInt32LE(this.mode, 4);\r\n            buffer.writeDoubleLE(this.atime.getTime(), 8);\r\n            buffer.writeDoubleLE(this.mtime.getTime(), 16);\r\n            buffer.writeDoubleLE(this.ctime.getTime(), 24);\r\n            return buffer;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a symbolic link (only valid through lstat)\r\n         */\r\n        isSymbolicLink() {\r\n            return (this.mode & 0xF000) === FileType.SYMLINK;\r\n        }\r\n        /**\r\n         * Change the mode of the file. We use this helper function to prevent messing\r\n         * up the type of the file, which is encoded in mode.\r\n         */\r\n        chmod(mode) {\r\n            this.mode = (this.mode & 0xF000) | mode;\r\n        }\r\n        // We don't support the following types of files.\r\n        isSocket() {\r\n            return false;\r\n        }\r\n        isBlockDevice() {\r\n            return false;\r\n        }\r\n        isCharacterDevice() {\r\n            return false;\r\n        }\r\n        isFIFO() {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    return files.Stats = Stats;\r\n});\ndefine('skylark-data-files/file-system',[\r\n    \"skylark-langx-funcs/defer\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"./files\",\r\n    './error-codes',\r\n    \"./file-error\",\r\n    './file-flag',\r\n    './stats'\r\n], function (setImmediate,Buffer, paths, files,ErrorCodes,FileError, FileFlag,  Stats) {\r\n    'use strict';\r\n\r\n\r\n    /** Used for unit testing. Defaults to a NOP. */\r\n    let wrapCbHook = function (cb, numArgs) {\r\n        return cb;\r\n    };\r\n    /**\r\n     * Wraps a callback function, ensuring it is invoked through setImmediate.\r\n     * @hidden\r\n     */\r\n    function wrapCb(cb, numArgs) {\r\n        if (typeof cb !== 'function') {\r\n            throw new Error('Callback must be a function.');\r\n        }\r\n        const hookedCb = wrapCbHook(cb, numArgs);\r\n        // We could use `arguments`, but Function.call/apply is expensive. And we only\r\n        // need to handle 1-3 arguments\r\n        switch (numArgs) {\r\n            case 1:\r\n                return function (arg1) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1);\r\n                    });\r\n                };\r\n            case 2:\r\n                return function (arg1, arg2) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2);\r\n                    });\r\n                };\r\n            case 3:\r\n                return function (arg1, arg2, arg3) {\r\n                    setImmediate(function () {\r\n                        return hookedCb(arg1, arg2, arg3);\r\n                    });\r\n                };\r\n            default:\r\n                throw new Error('Invalid invocation of wrapCb.');\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function assertRoot(fs) {\r\n        if (fs) {\r\n            return fs;\r\n        }\r\n        throw new FileError(ErrorCodes.EIO, `Initialize BrowserFS with a file system using BrowserFS.initialize(filesystem)`);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeMode(mode, def) {\r\n        switch (typeof mode) {\r\n            case 'number':\r\n                // (path, flag, mode, cb?)\r\n                return mode;\r\n            case 'string':\r\n                // (path, flag, modeString, cb?)\r\n                const trueMode = parseInt(mode, 8);\r\n                if (!isNaN(trueMode)) {\r\n                    return trueMode;\r\n                }\r\n                // Invalid string.\r\n                return def;\r\n            default:\r\n                return def;\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeTime(time) {\r\n        if (time instanceof Date) {\r\n            return time;\r\n        }\r\n        else if (typeof time === 'number') {\r\n            return new Date(time * 1000);\r\n        }\r\n        else {\r\n            throw new FileError(ErrorCodes.EINVAL, `Invalid time.`);\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizePath(p) {\r\n        // Node doesn't allow null characters in paths.\r\n        if (p.indexOf('\\u0000') >= 0) {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must be a string without null bytes.');\r\n        }\r\n        else if (p === '') {\r\n            throw new FileError(ErrorCodes.EINVAL, 'Path must not be empty.');\r\n        }\r\n        return paths.resolve(p);\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    function normalizeOptions(options, defEnc, defFlag, defMode) {\r\n        // typeof null === 'object' so special-case handing is needed.\r\n        switch (options === null ? 'null' : typeof options) {\r\n            case 'object':\r\n                return {\r\n                    encoding: typeof options['encoding'] !== 'undefined' ? options['encoding'] : defEnc,\r\n                    flag: typeof options['flag'] !== 'undefined' ? options['flag'] : defFlag,\r\n                    mode: normalizeMode(options['mode'], defMode)\r\n                };\r\n            case 'string':\r\n                return {\r\n                    encoding: options,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            case 'null':\r\n            case 'undefined':\r\n            case 'function':\r\n                return {\r\n                    encoding: defEnc,\r\n                    flag: defFlag,\r\n                    mode: defMode\r\n                };\r\n            default:\r\n                throw new TypeError(`\"options\" must be a string or an object, got ${typeof options} instead.`);\r\n        }\r\n    }\r\n    /**\r\n     * The default callback is a NOP.\r\n     * @hidden\r\n     * @private\r\n     */\r\n    function nopCb() {\r\n        // NOP.\r\n    }\r\n    /**\r\n     * The node frontend to all filesystems.\r\n     * This layer handles:\r\n     *\r\n     * * Sanity checking inputs.\r\n     * * Normalizing paths.\r\n     * * Resetting stack depth for asynchronous operations which may not go through\r\n     *   the browser by wrapping all input callbacks using `setImmediate`.\r\n     * * Performing the requested operation through the filesystem or the file\r\n     *   descriptor, as appropriate.\r\n     * * Handling optional arguments and setting default arguments.\r\n     * @see http://nodejs.org/api/fs.html\r\n     */\r\n    class FileSystem {\r\n        constructor() {\r\n            /* tslint:enable:variable-name */\r\n            this.F_OK = 0;\r\n            this.R_OK = 4;\r\n            this.W_OK = 2;\r\n            this.X_OK = 1;\r\n            this.root = null;\r\n            this.fdMap = {};\r\n            this.nextFd = 100;\r\n        }\r\n        initialize(rootFS) {\r\n            if (!rootFS.constructor.isAvailable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Tried to instantiate BrowserFS with an unavailable file system.');\r\n            }\r\n            return this.root = rootFS;\r\n        }\r\n        /**\r\n         * converts Date or number to a fractional UNIX timestamp\r\n         * Grabbed from NodeJS sources (lib/fs.js)\r\n         */\r\n        _toUnixTimestamp(time) {\r\n            if (typeof time === 'number') {\r\n                return time;\r\n            }\r\n            else if (time instanceof Date) {\r\n                return time.getTime() / 1000;\r\n            }\r\n            throw new Error(\"Cannot parse time: \" + time);\r\n        }\r\n        /**\r\n         * **NONSTANDARD**: Grab the FileSystem instance that backs this API.\r\n         * @return [BrowserFS.FileSystem | null] Returns null if the file system has\r\n         *   not been initialized.\r\n         */\r\n        getRootFS() {\r\n            if (this.root) {\r\n                return this.root;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        // FILE OR DIRECTORY METHODS\r\n        /**\r\n         * Asynchronous rename. No arguments other than a possible exception are given\r\n         * to the completion callback.\r\n         * @param oldPath\r\n         * @param newPath\r\n         * @param callback\r\n         */\r\n        rename(oldPath, newPath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).rename(normalizePath(oldPath), normalizePath(newPath), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous rename.\r\n         * @param oldPath\r\n         * @param newPath\r\n         */\r\n        renameSync(oldPath, newPath) {\r\n            assertRoot(this.root).renameSync(normalizePath(oldPath), normalizePath(newPath));\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * Then call the callback argument with either true or false.\r\n         * @example Sample invocation\r\n         *   fs.exists('/etc/passwd', function (exists) {\r\n         *     util.debug(exists ? \"it's there\" : \"no passwd!\");\r\n         *   });\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        exists(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).exists(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return newCb(false);\r\n            }\r\n        }\r\n        /**\r\n         * Test whether or not the given path exists by checking with the file system.\r\n         * @param path\r\n         * @return [boolean]\r\n         */\r\n        existsSync(path) {\r\n            try {\r\n                return assertRoot(this.root).existsSync(normalizePath(path));\r\n            }\r\n            catch (e) {\r\n                // Doesn't return an error. If something bad happens, we assume it just\r\n                // doesn't exist.\r\n                return false;\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        stat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), false, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        statSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), false);\r\n        }\r\n        /**\r\n         * Asynchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        lstat(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                return assertRoot(this.root).stat(normalizePath(path), true, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lstat`.\r\n         * `lstat()` is identical to `stat()`, except that if path is a symbolic link,\r\n         * then the link itself is stat-ed, not the file that it refers to.\r\n         * @param path\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        lstatSync(path) {\r\n            return assertRoot(this.root).statSync(normalizePath(path), true);\r\n        }\r\n        truncate(path, arg2 = 0, cb = nopCb) {\r\n            let len = 0;\r\n            if (typeof arg2 === 'function') {\r\n                cb = arg2;\r\n            }\r\n            else if (typeof arg2 === 'number') {\r\n                len = arg2;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (len < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                return assertRoot(this.root).truncate(normalizePath(path), len, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `truncate`.\r\n         * @param path\r\n         * @param len\r\n         */\r\n        truncateSync(path, len = 0) {\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            return assertRoot(this.root).truncateSync(normalizePath(path), len);\r\n        }\r\n        /**\r\n         * Asynchronous `unlink`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        unlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                return assertRoot(this.root).unlink(normalizePath(path), newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `unlink`.\r\n         * @param path\r\n         */\r\n        unlinkSync(path) {\r\n            return assertRoot(this.root).unlinkSync(normalizePath(path));\r\n        }\r\n        open(path, flag, arg2, cb = nopCb) {\r\n            const mode = normalizeMode(arg2, 0x1a4);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                assertRoot(this.root).open(normalizePath(path), FileFlag.getFileFlag(flag), mode, (e, file) => {\r\n                    if (file) {\r\n                        newCb(e, this.getFdForFile(file));\r\n                    }\r\n                    else {\r\n                        newCb(e);\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous file open.\r\n         * @see http://www.manpagez.com/man/2/open/\r\n         * @param path\r\n         * @param flags\r\n         * @param mode defaults to `0644`\r\n         * @return [BrowserFS.File]\r\n         */\r\n        openSync(path, flag, mode = 0x1a4) {\r\n            return this.getFdForFile(assertRoot(this.root).openSync(normalizePath(path), FileFlag.getFileFlag(flag), normalizeMode(mode, 0x1a4)));\r\n        }\r\n        readFile(filename, arg2 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options['flag']);\r\n                if (!flag.isReadable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.'));\r\n                }\r\n                return assertRoot(this.root).readFile(normalizePath(filename), options.encoding, flag, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        readFileSync(filename, arg2 = {}) {\r\n            const options = normalizeOptions(arg2, null, 'r', null);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to readFile must allow for reading.');\r\n            }\r\n            return assertRoot(this.root).readFileSync(normalizePath(filename), options.encoding, flag);\r\n        }\r\n        writeFile(filename, data, arg3 = {}, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isWriteable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.'));\r\n                }\r\n                return assertRoot(this.root).writeFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                return newCb(e);\r\n            }\r\n        }\r\n        writeFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'w', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to writeFile must allow for writing.');\r\n            }\r\n            return assertRoot(this.root).writeFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        appendFile(filename, data, arg3, cb = nopCb) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const flag = FileFlag.getFileFlag(options.flag);\r\n                if (!flag.isAppendable()) {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.'));\r\n                }\r\n                assertRoot(this.root).appendFile(normalizePath(filename), data, options.encoding, flag, options.mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        appendFileSync(filename, data, arg3) {\r\n            const options = normalizeOptions(arg3, 'utf8', 'a', 0x1a4);\r\n            const flag = FileFlag.getFileFlag(options.flag);\r\n            if (!flag.isAppendable()) {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Flag passed to appendFile must allow for appending.');\r\n            }\r\n            return assertRoot(this.root).appendFileSync(normalizePath(filename), data, options.encoding, flag, options.mode);\r\n        }\r\n        // FILE DESCRIPTOR METHODS\r\n        /**\r\n         * Asynchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fstat(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                file.stat(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fstat`.\r\n         * `fstat()` is identical to `stat()`, except that the file to be stat-ed is\r\n         * specified by the file descriptor `fd`.\r\n         * @param fd\r\n         * @return [BrowserFS.node.fs.Stats]\r\n         */\r\n        fstatSync(fd) {\r\n            return this.fd2file(fd).statSync();\r\n        }\r\n        /**\r\n         * Asynchronous close.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        close(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).close((e) => {\r\n                    if (!e) {\r\n                        this.closeFd(fd);\r\n                    }\r\n                    newCb(e);\r\n                });\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous close.\r\n         * @param fd\r\n         */\r\n        closeSync(fd) {\r\n            this.fd2file(fd).closeSync();\r\n            this.closeFd(fd);\r\n        }\r\n        ftruncate(fd, arg2, cb = nopCb) {\r\n            const length = typeof arg2 === 'number' ? arg2 : 0;\r\n            cb = typeof arg2 === 'function' ? arg2 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (length < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL);\r\n                }\r\n                file.truncate(length, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous ftruncate.\r\n         * @param fd\r\n         * @param len\r\n         */\r\n        ftruncateSync(fd, len = 0) {\r\n            const file = this.fd2file(fd);\r\n            if (len < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL);\r\n            }\r\n            file.truncateSync(len);\r\n        }\r\n        /**\r\n         * Asynchronous fsync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fsync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).sync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fsync.\r\n         * @param fd\r\n         */\r\n        fsyncSync(fd) {\r\n            this.fd2file(fd).syncSync();\r\n        }\r\n        /**\r\n         * Asynchronous fdatasync.\r\n         * @param fd\r\n         * @param callback\r\n         */\r\n        fdatasync(fd, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                this.fd2file(fd).datasync(newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous fdatasync.\r\n         * @param fd\r\n         */\r\n        fdatasyncSync(fd) {\r\n            this.fd2file(fd).datasyncSync();\r\n        }\r\n        write(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let buffer, offset, length, position = null;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]], cb?)\r\n                let encoding = 'utf8';\r\n                switch (typeof arg3) {\r\n                    case 'function':\r\n                        // (fd, string, cb)\r\n                        cb = arg3;\r\n                        break;\r\n                    case 'number':\r\n                        // (fd, string, position, encoding?, cb?)\r\n                        position = arg3;\r\n                        encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                        cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                        break;\r\n                    default:\r\n                        // ...try to find the callback and get out of here!\r\n                        cb = typeof arg4 === 'function' ? arg4 : typeof arg5 === 'function' ? arg5 : cb;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid arguments.'));\r\n                }\r\n                buffer = Buffer.from(arg2, encoding);\r\n                offset = 0;\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?, cb?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n            }\r\n            const newCb = wrapCb(cb, 3);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.write(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        writeSync(fd, arg2, arg3, arg4, arg5) {\r\n            let buffer, offset = 0, length, position;\r\n            if (typeof arg2 === 'string') {\r\n                // Signature 1: (fd, string, [position?, [encoding?]])\r\n                position = typeof arg3 === 'number' ? arg3 : null;\r\n                const encoding = typeof arg4 === 'string' ? arg4 : 'utf8';\r\n                offset = 0;\r\n                buffer = Buffer.from(arg2, encoding);\r\n                length = buffer.length;\r\n            }\r\n            else {\r\n                // Signature 2: (fd, buffer, offset, length, position?)\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = typeof arg5 === 'number' ? arg5 : null;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            return file.writeSync(buffer, offset, length, position);\r\n        }\r\n        read(fd, arg2, arg3, arg4, arg5, cb = nopCb) {\r\n            let position, offset, length, buffer, newCb;\r\n            if (typeof arg2 === 'number') {\r\n                // legacy interface\r\n                // (fd, length, position, encoding, callback)\r\n                length = arg2;\r\n                position = arg3;\r\n                const encoding = arg4;\r\n                cb = typeof arg5 === 'function' ? arg5 : cb;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                // XXX: Inefficient.\r\n                // Wrap the cb so we shelter upper layers of the API from these\r\n                // shenanigans.\r\n                newCb = wrapCb((err, bytesRead, buf) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    cb(err, buf.toString(encoding), bytesRead);\r\n                }, 3);\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n                newCb = wrapCb(cb, 3);\r\n            }\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (position === undefined || position === null) {\r\n                    position = file.getPos();\r\n                }\r\n                file.read(buffer, offset, length, position, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        readSync(fd, arg2, arg3, arg4, arg5) {\r\n            let shenanigans = false;\r\n            let buffer, offset, length, position, encoding = 'utf8';\r\n            if (typeof arg2 === 'number') {\r\n                length = arg2;\r\n                position = arg3;\r\n                encoding = arg4;\r\n                offset = 0;\r\n                buffer = Buffer.alloc(length);\r\n                shenanigans = true;\r\n            }\r\n            else {\r\n                buffer = arg2;\r\n                offset = arg3;\r\n                length = arg4;\r\n                position = arg5;\r\n            }\r\n            const file = this.fd2file(fd);\r\n            if (position === undefined || position === null) {\r\n                position = file.getPos();\r\n            }\r\n            const rv = file.readSync(buffer, offset, length, position);\r\n            if (!shenanigans) {\r\n                return rv;\r\n            }\r\n            else {\r\n                return [buffer.toString(encoding), rv];\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        fchown(fd, uid, gid, callback = nopCb) {\r\n            const newCb = wrapCb(callback, 1);\r\n            try {\r\n                this.fd2file(fd).chown(uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchown`.\r\n         * @param fd\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        fchownSync(fd, uid, gid) {\r\n            this.fd2file(fd).chownSync(uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        fchmod(fd, mode, cb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n                this.fd2file(fd).chmod(numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `fchmod`.\r\n         * @param fd\r\n         * @param mode\r\n         */\r\n        fchmodSync(fd, mode) {\r\n            const numMode = typeof mode === 'string' ? parseInt(mode, 8) : mode;\r\n            this.fd2file(fd).chmodSync(numMode);\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        futimes(fd, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const file = this.fd2file(fd);\r\n                if (typeof atime === 'number') {\r\n                    atime = new Date(atime * 1000);\r\n                }\r\n                if (typeof mtime === 'number') {\r\n                    mtime = new Date(mtime * 1000);\r\n                }\r\n                file.utimes(atime, mtime, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change the file timestamps of a file referenced by the supplied file\r\n         * descriptor.\r\n         * @param fd\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        futimesSync(fd, atime, mtime) {\r\n            this.fd2file(fd).utimesSync(normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        // DIRECTORY-ONLY METHODS\r\n        /**\r\n         * Asynchronous `rmdir`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        rmdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).rmdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `rmdir`.\r\n         * @param path\r\n         */\r\n        rmdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).rmdirSync(path);\r\n        }\r\n        /**\r\n         * Asynchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         * @param callback\r\n         */\r\n        mkdir(path, mode, cb = nopCb) {\r\n            if (typeof mode === 'function') {\r\n                cb = mode;\r\n                mode = 0x1ff;\r\n            }\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).mkdir(path, mode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `mkdir`.\r\n         * @param path\r\n         * @param mode defaults to `0777`\r\n         */\r\n        mkdirSync(path, mode) {\r\n            assertRoot(this.root).mkdirSync(normalizePath(path), normalizeMode(mode, 0x1ff));\r\n        }\r\n        /**\r\n         * Asynchronous `readdir`. Reads the contents of a directory.\r\n         * The callback gets two arguments `(err, files)` where `files` is an array of\r\n         * the names of the files in the directory excluding `'.'` and `'..'`.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readdir(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readdir(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `readdir`. Reads the contents of a directory.\r\n         * @param path\r\n         * @return [String[]]\r\n         */\r\n        readdirSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readdirSync(path);\r\n        }\r\n        // SYMLINK METHODS\r\n        /**\r\n         * Asynchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param callback\r\n         */\r\n        link(srcpath, dstpath, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).link(srcpath, dstpath, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `link`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         */\r\n        linkSync(srcpath, dstpath) {\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, arg3, cb = nopCb) {\r\n            const type = typeof arg3 === 'string' ? arg3 : 'file';\r\n            cb = typeof arg3 === 'function' ? arg3 : cb;\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                if (type !== 'file' && type !== 'dir') {\r\n                    return newCb(new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type));\r\n                }\r\n                srcpath = normalizePath(srcpath);\r\n                dstpath = normalizePath(dstpath);\r\n                assertRoot(this.root).symlink(srcpath, dstpath, type, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `symlink`.\r\n         * @param srcpath\r\n         * @param dstpath\r\n         * @param type can be either `'dir'` or `'file'` (default is `'file'`)\r\n         */\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (!type) {\r\n                type = 'file';\r\n            }\r\n            else if (type !== 'file' && type !== 'dir') {\r\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid type: \" + type);\r\n            }\r\n            srcpath = normalizePath(srcpath);\r\n            dstpath = normalizePath(dstpath);\r\n            return assertRoot(this.root).symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        /**\r\n         * Asynchronous readlink.\r\n         * @param path\r\n         * @param callback\r\n         */\r\n        readlink(path, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).readlink(path, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous readlink.\r\n         * @param path\r\n         * @return [String]\r\n         */\r\n        readlinkSync(path) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).readlinkSync(path);\r\n        }\r\n        // PROPERTY OPERATIONS\r\n        /**\r\n         * Asynchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        chown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, false, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        chownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, false, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         * @param callback\r\n         */\r\n        lchown(path, uid, gid, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).chown(path, true, uid, gid, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchown`.\r\n         * @param path\r\n         * @param uid\r\n         * @param gid\r\n         */\r\n        lchownSync(path, uid, gid) {\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chownSync(path, true, uid, gid);\r\n        }\r\n        /**\r\n         * Asynchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        chmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), false, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `chmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        chmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 0) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            path = normalizePath(path);\r\n            assertRoot(this.root).chmodSync(path, false, numMode);\r\n        }\r\n        /**\r\n         * Asynchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         * @param callback\r\n         */\r\n        lchmod(path, mode, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                const numMode = normalizeMode(mode, -1);\r\n                if (numMode < 0) {\r\n                    throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n                }\r\n                assertRoot(this.root).chmod(normalizePath(path), true, numMode, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `lchmod`.\r\n         * @param path\r\n         * @param mode\r\n         */\r\n        lchmodSync(path, mode) {\r\n            const numMode = normalizeMode(mode, -1);\r\n            if (numMode < 1) {\r\n                throw new FileError(ErrorCodes.EINVAL, `Invalid mode.`);\r\n            }\r\n            assertRoot(this.root).chmodSync(normalizePath(path), true, numMode);\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         * @param callback\r\n         */\r\n        utimes(path, atime, mtime, cb = nopCb) {\r\n            const newCb = wrapCb(cb, 1);\r\n            try {\r\n                assertRoot(this.root).utimes(normalizePath(path), normalizeTime(atime), normalizeTime(mtime), newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Change file timestamps of the file referenced by the supplied path.\r\n         * @param path\r\n         * @param atime\r\n         * @param mtime\r\n         */\r\n        utimesSync(path, atime, mtime) {\r\n            assertRoot(this.root).utimesSync(normalizePath(path), normalizeTime(atime), normalizeTime(mtime));\r\n        }\r\n        realpath(path, arg2, cb = nopCb) {\r\n            const cache = typeof (arg2) === 'object' ? arg2 : {};\r\n            cb = typeof (arg2) === 'function' ? arg2 : nopCb;\r\n            const newCb = wrapCb(cb, 2);\r\n            try {\r\n                path = normalizePath(path);\r\n                assertRoot(this.root).realpath(path, cache, newCb);\r\n            }\r\n            catch (e) {\r\n                newCb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `realpath`.\r\n         * @param path\r\n         * @param cache An object literal of mapped paths that can be used to\r\n         *   force a specific path resolution or avoid additional `fs.stat` calls for\r\n         *   known real paths.\r\n         * @return [String]\r\n         */\r\n        realpathSync(path, cache = {}) {\r\n            path = normalizePath(path);\r\n            return assertRoot(this.root).realpathSync(path, cache);\r\n        }\r\n        watchFile(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        unwatchFile(filename, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        watch(filename, arg2, listener = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        access(path, arg2, cb = nopCb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        accessSync(path, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createReadStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        createWriteStream(path, options) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * For unit testing. Passes all incoming callbacks to cbWrapper for wrapping.\r\n         */\r\n        wrapCallbacks(cbWrapper) {\r\n            wrapCbHook = cbWrapper;\r\n        }\r\n        getFdForFile(file) {\r\n            const fd = this.nextFd++;\r\n            this.fdMap[fd] = file;\r\n            return fd;\r\n        }\r\n        fd2file(fd) {\r\n            const rv = this.fdMap[fd];\r\n            if (rv) {\r\n                return rv;\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EBADF, 'Invalid file descriptor.');\r\n            }\r\n        }\r\n        closeFd(fd) {\r\n            delete this.fdMap[fd];\r\n        }\r\n    }\r\n    \r\n    return files.FileSystem = FileSystem;\r\n});\ndefine('skylark-data-files/utils',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    './file-error',\r\n    './error-codes'\r\n], function (Buffer,paths, FileError, ErrorCodes) {\r\n    'use strict';\r\n\r\n    function deprecationMessage(print, fsName, opts) {\r\n        if (print) {\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(`[${fsName}] Direct file system constructor usage is deprecated for this file system, and will be removed in the next major version. Please use the '${fsName}.Create(${JSON.stringify(opts)}, callback)' method instead. See https://github.com/jvilk/BrowserFS/issues/176 for more details.`);\r\n            // tslint:enable-next-line:no-console\r\n        }\r\n    }\r\n    /**\r\n     * Checks for any IE version, including IE11 which removed MSIE from the\r\n     * userAgent string.\r\n     * @hidden\r\n     */\r\n    const isIE = typeof navigator !== \"undefined\" && !!(/(msie) ([\\w.]+)/.exec(navigator.userAgent.toLowerCase()) || navigator.userAgent.indexOf('Trident') !== -1);\r\n    /**\r\n     * Check if we're in a web worker.\r\n     * @hidden\r\n     */\r\n    const isWebWorker = typeof window === \"undefined\";\r\n    /**\r\n     * Throws an exception. Called on code paths that should be impossible.\r\n     * @hidden\r\n     */\r\n    function fail() {\r\n        throw new Error(\"BFS has reached an impossible code path; please file a bug.\");\r\n    }\r\n    /**\r\n     * Synchronous recursive makedir.\r\n     * @hidden\r\n     */\r\n    function mkdirpSync(p, mode, fs) {\r\n        if (!fs.existsSync(p)) {\r\n            mkdirpSync(paths.dirname(p), mode, fs);\r\n            fs.mkdirSync(p, mode);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into an array buffer. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2ArrayBuffer(buff) {\r\n        const u8 = buffer2Uint8array(buff), u8offset = u8.byteOffset, u8Len = u8.byteLength;\r\n        if (u8offset === 0 && u8Len === u8.buffer.byteLength) {\r\n            return u8.buffer;\r\n        }\r\n        else {\r\n            return u8.buffer.slice(u8offset, u8offset + u8Len);\r\n        }\r\n    }\r\n    /**\r\n     * Converts a buffer into a Uint8Array. Attempts to do so in a\r\n     * zero-copy manner, e.g. the array references the same memory.\r\n     * @hidden\r\n     */\r\n    function buffer2Uint8array(buff) {\r\n        if (buff instanceof Uint8Array) {\r\n            // BFS & Node v4.0 buffers *are* Uint8Arrays.\r\n            return buff;\r\n        }\r\n        else {\r\n            // Uint8Arrays can be constructed from arrayish numbers.\r\n            // At this point, we assume this isn't a BFS array.\r\n            return new Uint8Array(buff);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given arrayish object into a Buffer. Attempts to\r\n     * be zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayish2Buffer(arr) {\r\n        if (arr instanceof Buffer) {\r\n            return arr;\r\n        }\r\n        else if (arr instanceof Uint8Array) {\r\n            return uint8Array2Buffer(arr);\r\n        }\r\n        else {\r\n            return Buffer.from(arr);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given Uint8Array into a Buffer. Attempts to be zero-copy.\r\n     * @hidden\r\n     */\r\n    function uint8Array2Buffer(u8) {\r\n        if (u8 instanceof Buffer) {\r\n            return u8;\r\n        }\r\n        else if (u8.byteOffset === 0 && u8.byteLength === u8.buffer.byteLength) {\r\n            return arrayBuffer2Buffer(u8.buffer);\r\n        }\r\n        else {\r\n            return Buffer.from(u8.buffer, u8.byteOffset, u8.byteLength);\r\n        }\r\n    }\r\n    /**\r\n     * Converts the given array buffer into a Buffer. Attempts to be\r\n     * zero-copy.\r\n     * @hidden\r\n     */\r\n    function arrayBuffer2Buffer(ab) {\r\n        return Buffer.from(ab);\r\n    }\r\n    /**\r\n     * Copies a slice of the given buffer\r\n     * @hidden\r\n     */\r\n    function copyingSlice(buff, start = 0, end = buff.length) {\r\n        if (start < 0 || end < 0 || end > buff.length || start > end) {\r\n            throw new TypeError(`Invalid slice bounds on buffer of length ${buff.length}: [${start}, ${end}]`);\r\n        }\r\n        if (buff.length === 0) {\r\n            // Avoid s0 corner case in ArrayBuffer case.\r\n            return emptyBuffer();\r\n        }\r\n        else {\r\n            const u8 = buffer2Uint8array(buff), s0 = buff[0], newS0 = (s0 + 1) % 0xFF;\r\n            buff[0] = newS0;\r\n            if (u8[0] === newS0) {\r\n                // Same memory. Revert & copy.\r\n                u8[0] = s0;\r\n                return uint8Array2Buffer(u8.slice(start, end));\r\n            }\r\n            else {\r\n                // Revert.\r\n                buff[0] = s0;\r\n                return uint8Array2Buffer(u8.subarray(start, end));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyBuff = null;\r\n    /**\r\n     * Returns an empty buffer.\r\n     * @hidden\r\n     */\r\n    function emptyBuffer() {\r\n        if (emptyBuff) {\r\n            return emptyBuff;\r\n        }\r\n        return emptyBuff = Buffer.alloc(0);\r\n    }\r\n    /**\r\n     * Option validator for a Buffer file system option.\r\n     * @hidden\r\n     */\r\n    function bufferValidator(v, cb) {\r\n        if (Buffer.isBuffer(v)) {\r\n            cb();\r\n        }\r\n        else {\r\n            cb(new FileError(ErrorCodes.EINVAL, `option must be a Buffer.`));\r\n        }\r\n    }\r\n    /**\r\n     * Checks that the given options object is valid for the file system options.\r\n     * @hidden\r\n     */\r\n    function checkOptions(fsType, opts, cb) {\r\n        const optsInfo = fsType.Options;\r\n        const fsName = fsType.Name;\r\n        let pendingValidators = 0;\r\n        let callbackCalled = false;\r\n        let loopEnded = false;\r\n        function validatorCallback(e) {\r\n            if (!callbackCalled) {\r\n                if (e) {\r\n                    callbackCalled = true;\r\n                    cb(e);\r\n                }\r\n                pendingValidators--;\r\n                if (pendingValidators === 0 && loopEnded) {\r\n                    cb();\r\n                }\r\n            }\r\n        }\r\n        // Check for required options.\r\n        for (const optName in optsInfo) {\r\n            if (optsInfo.hasOwnProperty(optName)) {\r\n                const opt = optsInfo[optName];\r\n                const providedValue = opts[optName];\r\n                if (providedValue === undefined || providedValue === null) {\r\n                    if (!opt.optional) {\r\n                        // Required option, not provided.\r\n                        // Any incorrect options provided? Which ones are close to the provided one?\r\n                        // (edit distance 5 === close)\r\n                        const incorrectOptions = Object.keys(opts).filter((o) => !(o in optsInfo)).map((a) => {\r\n                            return { str: a, distance: levenshtein(optName, a) };\r\n                        }).filter((o) => o.distance < 5).sort((a, b) => a.distance - b.distance);\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Required option '${optName}' not provided.${incorrectOptions.length > 0 ? ` You provided unrecognized option '${incorrectOptions[0].str}'; perhaps you meant to type '${optName}'.` : ''}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    // Else: Optional option, not provided. That is OK.\r\n                }\r\n                else {\r\n                    // Option provided! Check type.\r\n                    let typeMatches = false;\r\n                    if (Array.isArray(opt.type)) {\r\n                        typeMatches = opt.type.indexOf(typeof (providedValue)) !== -1;\r\n                    }\r\n                    else {\r\n                        typeMatches = typeof (providedValue) === opt.type;\r\n                    }\r\n                    if (!typeMatches) {\r\n                        // Validators may be synchronous.\r\n                        if (callbackCalled) {\r\n                            return;\r\n                        }\r\n                        callbackCalled = true;\r\n                        return cb(new FileError(ErrorCodes.EINVAL, `[${fsName}] Value provided for option ${optName} is not the proper type. Expected ${Array.isArray(opt.type) ? `one of {${opt.type.join(\", \")}}` : opt.type}, but received ${typeof (providedValue)}\\nOption description: ${opt.description}`));\r\n                    }\r\n                    else if (opt.validator) {\r\n                        pendingValidators++;\r\n                        opt.validator(providedValue, validatorCallback);\r\n                    }\r\n                    // Otherwise: All good!\r\n                }\r\n            }\r\n        }\r\n        loopEnded = true;\r\n        if (pendingValidators === 0 && !callbackCalled) {\r\n            cb();\r\n        }\r\n    }\r\n\r\n    return {\r\n        deprecationMessage: deprecationMessage,\r\n        isIE: isIE,\r\n        isWebWorker: isWebWorker,\r\n        fail: fail,\r\n        mkdirpSync: mkdirpSync,\r\n        buffer2ArrayBuffer: buffer2ArrayBuffer,\r\n        buffer2Uint8array: buffer2Uint8array,\r\n        arrayish2Buffer: arrayish2Buffer,\r\n        uint8Array2Buffer: uint8Array2Buffer,\r\n        arrayBuffer2Buffer: arrayBuffer2Buffer,\r\n        copyingSlice: copyingSlice,\r\n        emptyBuffer: emptyBuffer,\r\n        bufferValidator: bufferValidator,\r\n        checkOptions: checkOptions\r\n    };\r\n});\ndefine('skylark-data-files/preload-file',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"./files\",\r\n    \"./error-codes\",\r\n    './file-error',\r\n    \"./stats\",\r\n    \"./base-file\",\r\n    './utils'\r\n], function (Buffer,files,ErrorCodes,FileError,Stats,BaseFile, utils) {\r\n    'use strict';\r\n\r\n    ////fs     '../core/node_fs',\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * An implementation of the File interface that operates on a file that is\r\n     * completely in-memory. PreloadFiles are backed by a Buffer.\r\n     *\r\n     * This is also an abstract class, as it lacks an implementation of 'sync' and\r\n     * 'close'. Each filesystem that wishes to use this file representation must\r\n     * extend this class and implement those two methods.\r\n     * @todo 'close' lever that disables functionality once closed.\r\n     */\r\n    class PreloadFile extends BaseFile {\r\n        /**\r\n         * Creates a file with the given path and, optionally, the given contents. Note\r\n         * that, if contents is specified, it will be mutated by the file!\r\n         * @param _fs The file system that created the file.\r\n         * @param _path\r\n         * @param _mode The mode that the file was opened using.\r\n         *   Dictates permissions and where the file pointer starts.\r\n         * @param _stat The stats object for the given file.\r\n         *   PreloadFile will mutate this object. Note that this object must contain\r\n         *   the appropriate mode that the file was opened as.\r\n         * @param contents A buffer containing the entire\r\n         *   contents of the file. PreloadFile will mutate this buffer. If not\r\n         *   specified, we assume it is a new file.\r\n         */\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super();\r\n            this._pos = 0;\r\n            this._dirty = false;\r\n            this._fs = _fs;\r\n            this._path = _path;\r\n            this._flag = _flag;\r\n            this._stat = _stat;\r\n            this._buffer = contents ? contents : emptyBuffer();\r\n            // Note: This invariant is *not* maintained once the file starts getting\r\n            // modified.\r\n            // Note: Only actually matters if file is readable, as writeable modes may\r\n            // truncate/append to file.\r\n            if (this._stat.size !== this._buffer.length && this._flag.isReadable()) {\r\n                throw new Error(`Invalid buffer: Buffer is ${this._buffer.length} long, yet Stats object specifies that file is ${this._stat.size} long.`);\r\n            }\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get the underlying buffer for this file. !!DO NOT MUTATE!! Will mess up dirty tracking.\r\n         */\r\n        getBuffer() {\r\n            return this._buffer;\r\n        }\r\n        /**\r\n         * NONSTANDARD: Get underlying stats for this file. !!DO NOT MUTATE!!\r\n         */\r\n        getStats() {\r\n            return this._stat;\r\n        }\r\n        getFlag() {\r\n            return this._flag;\r\n        }\r\n        /**\r\n         * Get the path to this file.\r\n         * @return [String] The path to the file.\r\n         */\r\n        getPath() {\r\n            return this._path;\r\n        }\r\n        /**\r\n         * Get the current file position.\r\n         *\r\n         * We emulate the following bug mentioned in the Node documentation:\r\n         * > On Linux, positional writes don't work when the file is opened in append\r\n         *   mode. The kernel ignores the position argument and always appends the data\r\n         *   to the end of the file.\r\n         * @return [Number] The current file position.\r\n         */\r\n        getPos() {\r\n            if (this._flag.isAppendable()) {\r\n                return this._stat.size;\r\n            }\r\n            return this._pos;\r\n        }\r\n        /**\r\n         * Advance the current file position by the indicated number of positions.\r\n         * @param [Number] delta\r\n         */\r\n        advancePos(delta) {\r\n            return this._pos += delta;\r\n        }\r\n        /**\r\n         * Set the file position.\r\n         * @param [Number] newPos\r\n         */\r\n        setPos(newPos) {\r\n            return this._pos = newPos;\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous sync. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            try {\r\n                this.syncSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous sync.\r\n         */\r\n        syncSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * **Core**: Asynchronous close. Must be implemented by subclasses of this\r\n         * class.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            try {\r\n                this.closeSync();\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * **Core**: Synchronous close.\r\n         */\r\n        closeSync() {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Asynchronous `stat`.\r\n         * @param [Function(BrowserFS.FileError, BrowserFS.node.fs.Stats)] cb\r\n         */\r\n        stat(cb) {\r\n            try {\r\n                cb(null, Stats.clone(this._stat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous `stat`.\r\n         */\r\n        statSync() {\r\n            return Stats.clone(this._stat);\r\n        }\r\n        /**\r\n         * Asynchronous truncate.\r\n         * @param [Number] len\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        truncate(len, cb) {\r\n            try {\r\n                this.truncateSync(len);\r\n                if (this._flag.isSynchronous() && !fs.getRootFS().supportsSynch()) {\r\n                    this.sync(cb);\r\n                }\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                return cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Synchronous truncate.\r\n         * @param [Number] len\r\n         */\r\n        truncateSync(len) {\r\n            this._dirty = true;\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            this._stat.mtimeMs = Date.now();\r\n            if (len > this._buffer.length) {\r\n                const buf = Buffer.alloc(len - this._buffer.length, 0);\r\n                // Write will set @_stat.size for us.\r\n                this.writeSync(buf, 0, buf.length, this._buffer.length);\r\n                if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                    this.syncSync();\r\n                }\r\n                return;\r\n            }\r\n            this._stat.size = len;\r\n            // Truncate buffer to 'len'.\r\n            const newBuff = Buffer.alloc(len);\r\n            this._buffer.copy(newBuff, 0, 0, len);\r\n            this._buffer = newBuff;\r\n            if (this._flag.isSynchronous() && fs.getRootFS().supportsSynch()) {\r\n                this.syncSync();\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.write multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)]\r\n         *   cb The number specifies the number of bytes written into the file.\r\n         */\r\n        write(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.writeSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Write buffer to the file.\r\n         * Note that it is unsafe to use fs.writeSync multiple times on the same file\r\n         * without waiting for the callback.\r\n         * @param [BrowserFS.node.Buffer] buffer Buffer containing the data to write to\r\n         *  the file.\r\n         * @param [Number] offset Offset in the buffer to start reading data from.\r\n         * @param [Number] length The amount of bytes to write to the file.\r\n         * @param [Number] position Offset from the beginning of the file where this\r\n         *   data should be written. If position is null, the data will be written at\r\n         *   the current position.\r\n         * @return [Number]\r\n         */\r\n        writeSync(buffer, offset, length, position) {\r\n            this._dirty = true;\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            if (!this._flag.isWriteable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a writeable mode.');\r\n            }\r\n            const endFp = position + length;\r\n            if (endFp > this._stat.size) {\r\n                this._stat.size = endFp;\r\n                if (endFp > this._buffer.length) {\r\n                    // Extend the buffer!\r\n                    const newBuff = Buffer.alloc(endFp);\r\n                    this._buffer.copy(newBuff);\r\n                    this._buffer = newBuff;\r\n                }\r\n            }\r\n            const len = buffer.copy(this._buffer, position, offset, offset + length);\r\n            this._stat.mtimeMs = Date.now();\r\n            if (this._flag.isSynchronous()) {\r\n                this.syncSync();\r\n                return len;\r\n            }\r\n            this.setPos(position + len);\r\n            return len;\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @param [Function(BrowserFS.FileError, Number, BrowserFS.node.Buffer)] cb The\r\n         *   number is the number of bytes read\r\n         */\r\n        read(buffer, offset, length, position, cb) {\r\n            try {\r\n                cb(null, this.readSync(buffer, offset, length, position), buffer);\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Read data from the file.\r\n         * @param [BrowserFS.node.Buffer] buffer The buffer that the data will be\r\n         *   written to.\r\n         * @param [Number] offset The offset within the buffer where writing will\r\n         *   start.\r\n         * @param [Number] length An integer specifying the number of bytes to read.\r\n         * @param [Number] position An integer specifying where to begin reading from\r\n         *   in the file. If position is null, data will be read from the current file\r\n         *   position.\r\n         * @return [Number]\r\n         */\r\n        readSync(buffer, offset, length, position) {\r\n            if (!this._flag.isReadable()) {\r\n                throw new FileError(ErrorCodes.EPERM, 'File not opened with a readable mode.');\r\n            }\r\n            if (position === undefined || position === null) {\r\n                position = this.getPos();\r\n            }\r\n            const endRead = position + length;\r\n            if (endRead > this._stat.size) {\r\n                length = this._stat.size - position;\r\n            }\r\n            const rv = this._buffer.copy(buffer, offset, position, position + length);\r\n            this._stat.atimeMs = Date.now();\r\n            this._pos = position + length;\r\n            return rv;\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number|String] mode\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        chmod(mode, cb) {\r\n            try {\r\n                this.chmodSync(mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        /**\r\n         * Asynchronous `fchmod`.\r\n         * @param [Number] mode\r\n         */\r\n        chmodSync(mode) {\r\n            if (!this._fs.supportsProps()) {\r\n                throw new FileError(ErrorCodes.ENOTSUP);\r\n            }\r\n            this._dirty = true;\r\n            this._stat.chmod(mode);\r\n            this.syncSync();\r\n        }\r\n        isDirty() {\r\n            return this._dirty;\r\n        }\r\n        /**\r\n         * Resets the dirty bit. Should only be called after a sync has completed successfully.\r\n         */\r\n        resetDirty() {\r\n            this._dirty = false;\r\n        }\r\n    }\r\n\r\n    return files.PreloadFile = PreloadFile;\r\n});\ndefine('skylark-data-files/no-sync-file',[\r\n     \"./files\",\r\n     \"./preload-file\"\r\n], function (files,PreloadFile) {\r\n    'use strict';\r\n    /**\r\n     * File class for the InMemory and XHR file systems.\r\n     * Doesn't sync to anything, so it works nicely for memory-only files.\r\n     */\r\n    class NoSyncFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        /**\r\n         * Asynchronous sync. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        sync(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous sync. Doesn't do anything.\r\n         */\r\n        syncSync() {\r\n            // NOP.\r\n        }\r\n        /**\r\n         * Asynchronous close. Doesn't do anything, simply calls the cb.\r\n         * @param [Function(BrowserFS.FileError)] cb\r\n         */\r\n        close(cb) {\r\n            cb();\r\n        }\r\n        /**\r\n         * Synchronous close. Doesn't do anything.\r\n         */\r\n        closeSync() {\r\n            // NOP.\r\n        }\r\n    }\r\n\r\n    return files.NoSyncFile = NoSyncFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/registry',[\r\n\t\"../files\"\r\n],function(files){\r\n\r\n\tvar cache = {}\r\n\r\n\tfunction get(name) {\r\n\t\treturn cache[name];\r\n\t}\r\n\r\n\tfunction add(name,provider) {\r\n\t\tcache[name] = provider;\r\n\t}\r\n\t\r\n\r\n\treturn files.providers.registry = {\r\n\t\tget,\r\n\t\tadd\r\n\t};\r\n});\ndefine('skylark-data-files/configure',[\r\n    \"./files\",\r\n    './file-system',\r\n    \"./error-codes\",\r\n    \"./file-error\",\r\n    './providers/registry',\r\n], function(files, FileSystem, ErrorCodes,FileError,registry) {\r\n    'use strict';\r\n\r\n    var fs = files.fs = new FileSystem();\r\n\r\n    /**\r\n     * Initializes BrowserFS with the given root file system.\r\n     */\r\n    function initialize(rootfs) {\r\n        return fs.initialize(rootfs);\r\n    }\r\n    /**\r\n     * Creates a file system with the given configuration, and initializes BrowserFS with it.\r\n     * See the FileSystemConfiguration type for more info on the configuration object.\r\n     */\r\n    function configure(config, cb) {\r\n        getFileSystem(config, (e, fs) => {\r\n            if (fs) {\r\n                initialize(fs);\r\n                cb(fs);\r\n            }\r\n            else {\r\n                cb(e);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Retrieve a file system with the given configuration.\r\n     * @param config A FileSystemConfiguration object. See FileSystemConfiguration for details.\r\n     * @param cb Called when the file system is constructed, or when an error occurs.\r\n     */\r\n    function getFileSystem(config, cb) {\r\n        const fsName = config['fs'];\r\n        if (!fsName) {\r\n            return cb(new FileError(ErrorCodes.EPERM, 'Missing \"fs\" property on configuration object.'));\r\n        }\r\n        const options = config['options'];\r\n        let waitCount = 0;\r\n        let called = false;\r\n        function finish() {\r\n            if (!called) {\r\n                called = true;\r\n                const fsc = registry.get(fsName);\r\n                if (!fsc) {\r\n                    cb(new FileError(ErrorCodes.EPERM, `File system ${fsName} is not available in BrowserFS.`));\r\n                }\r\n                else {\r\n                    fsc.Create(options, cb);\r\n                }\r\n            }\r\n        }\r\n        if (options !== null && typeof (options) === \"object\") {\r\n            let finishedIterating = false;\r\n            const props = Object.keys(options).filter((k) => k !== 'fs');\r\n            // Check recursively if other fields have 'fs' properties.\r\n            props.forEach((p) => {\r\n                const d = options[p];\r\n                if (d !== null && typeof (d) === \"object\" && d['fs']) {\r\n                    waitCount++;\r\n                    getFileSystem(d, function (e, fs) {\r\n                        waitCount--;\r\n                        if (e) {\r\n                            if (called) {\r\n                                return;\r\n                            }\r\n                            called = true;\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            options[p] = fs;\r\n                            if (waitCount === 0 && finishedIterating) {\r\n                                finish();\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n            finishedIterating = true;\r\n        }\r\n        if (waitCount === 0) {\r\n            finish();\r\n        }\r\n    }\r\n\r\n    return files.configure = configure;\r\n});\ndefine('skylark-data-files/providers/base-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils'\r\n], function (Bufer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Basic filesystem class. Most filesystems should extend this class, as it\r\n     * provides default implementations for a handful of methods.\r\n     */\r\n    class BaseProvider {\r\n        supportsLinks() {\r\n            return false;\r\n        }\r\n        diskSpace(p, cb) {\r\n            cb(0, 0);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         */\r\n        openFile(p, flag, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFile(p, flag, mode, cb) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            const mustBeFile = (e, stats) => {\r\n                if (e) {\r\n                    // File does not exist.\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            // Ensure parent exists.\r\n                            return this.stat(paths.dirname(p), false, (e, parentStats) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (parentStats && !parentStats.isDirectory()) {\r\n                                    cb(FileError.ENOTDIR(paths.dirname(p)));\r\n                                }\r\n                                else {\r\n                                    this.createFile(p, flag, mode, cb);\r\n                                }\r\n                            });\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.ENOENT(p));\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n                else {\r\n                    // File exists.\r\n                    if (stats && stats.isDirectory()) {\r\n                        return cb(FileError.EISDIR(p));\r\n                    }\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.THROW_EXCEPTION:\r\n                            return cb(FileError.EEXIST(p));\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            // NOTE: In a previous implementation, we deleted the file and\r\n                            // re-created it. However, this created a race condition if another\r\n                            // asynchronous request was trying to read the file, as the file\r\n                            // would not exist for a small period of time.\r\n                            return this.openFile(p, flag, (e, fd) => {\r\n                                if (e) {\r\n                                    cb(e);\r\n                                }\r\n                                else if (fd) {\r\n                                    fd.truncate(0, () => {\r\n                                        fd.sync(() => {\r\n                                            cb(null, fd);\r\n                                        });\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    fail();\r\n                                }\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this.openFile(p, flag, cb);\r\n                        default:\r\n                            return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.'));\r\n                    }\r\n                }\r\n            };\r\n            this.stat(p, false, mustBeFile);\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        statSync(p, isLstat) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Opens the file at path p with the given flag. The file must exist.\r\n         * @param p The path to open.\r\n         * @param flag The flag to use when opening the file.\r\n         * @return A File object corresponding to the opened file.\r\n         */\r\n        openFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        /**\r\n         * Create the file at path p with the given mode. Then, open it with the given\r\n         * flag.\r\n         */\r\n        createFileSync(p, flag, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        openSync(p, flag, mode) {\r\n            // Check if the path exists, and is a file.\r\n            let stats;\r\n            try {\r\n                stats = this.statSync(p, false);\r\n            }\r\n            catch (e) {\r\n                // File does not exist.\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        // Ensure parent exists.\r\n                        const parentStats = this.statSync(paths.dirname(p), false);\r\n                        if (!parentStats.isDirectory()) {\r\n                            throw FileError.ENOTDIR(paths.dirname(p));\r\n                        }\r\n                        return this.createFileSync(p, flag, mode);\r\n                    case ActionType.THROW_EXCEPTION:\r\n                        throw FileError.ENOENT(p);\r\n                    default:\r\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n                }\r\n            }\r\n            // File exists.\r\n            if (stats.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            switch (flag.pathExistsAction()) {\r\n                case ActionType.THROW_EXCEPTION:\r\n                    throw FileError.EEXIST(p);\r\n                case ActionType.TRUNCATE_FILE:\r\n                    // Delete file.\r\n                    this.unlinkSync(p);\r\n                    // Create file. Use the same mode as the old file.\r\n                    // Node itself modifies the ctime when this occurs, so this action\r\n                    // will preserve that behavior if the underlying file system\r\n                    // supports those properties.\r\n                    return this.createFileSync(p, flag, stats.mode);\r\n                case ActionType.NOP:\r\n                    return this.openFileSync(p, flag, mode);\r\n                default:\r\n                    throw new FileError(ErrorCodes.EINVAL, 'Invalid FileFlag object.');\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        unlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        rmdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        rmdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        mkdirSync(p, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readdir(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readdirSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        exists(p, cb) {\r\n            this.stat(p, null, function (err) {\r\n                cb(!err);\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            try {\r\n                this.statSync(p, true);\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n        realpath(p, cache, cb) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(null, addPaths);\r\n                }\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                this.exists(p, function (doesExist) {\r\n                    if (doesExist) {\r\n                        cb(null, p);\r\n                    }\r\n                    else {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this.supportsLinks()) {\r\n                // The path could contain symlinks. Split up the path,\r\n                // resolve any symlinks, return the resolved string.\r\n                const splitPath = p.split(paths.sep);\r\n                // TODO: Simpler to just pass through file, find sep and such.\r\n                for (let i = 0; i < splitPath.length; i++) {\r\n                    const addPaths = splitPath.slice(0, i + 1);\r\n                    splitPath[i] = paths.join.apply(path, addPaths);\r\n                }\r\n                return splitPath.join(paths.sep);\r\n            }\r\n            else {\r\n                // No symlinks. We just need to verify that it exists.\r\n                if (this.existsSync(p)) {\r\n                    return p;\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        truncate(p, len, cb) {\r\n            this.open(p, FileFlag.getFileFlag('r+'), 0x1a4, (function (er, fd) {\r\n                if (er) {\r\n                    return cb(er);\r\n                }\r\n                fd.truncate(len, (function (er) {\r\n                    fd.close((function (er2) {\r\n                        cb(er || er2);\r\n                    }));\r\n                }));\r\n            }));\r\n        }\r\n        truncateSync(p, len) {\r\n            const fd = this.openSync(p, FileFlag.getFileFlag('r+'), 0x1a4);\r\n            // Need to safely close FD, regardless of whether or not truncate succeeds.\r\n            try {\r\n                fd.truncateSync(len);\r\n            }\r\n            catch (e) {\r\n                throw e;\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, (err, fd) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err, arg) {\r\n                    fd.close(function (err2) {\r\n                        if (!err) {\r\n                            err = err2;\r\n                        }\r\n                        return oldCb(err, arg);\r\n                    });\r\n                };\r\n                fd.stat((err, stat) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    // Allocate buffer.\r\n                    const buf = Buffer.alloc(stat.size);\r\n                    fd.read(buf, 0, stat.size, 0, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        else if (encoding === null) {\r\n                            return cb(err, buf);\r\n                        }\r\n                        try {\r\n                            cb(null, buf.toString(encoding));\r\n                        }\r\n                        catch (e) {\r\n                            cb(e);\r\n                        }\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, 0x1a4);\r\n            try {\r\n                const stat = fd.statSync();\r\n                // Allocate buffer.\r\n                const buf = Buffer.alloc(stat.size);\r\n                fd.readSync(buf, 0, stat.size, 0);\r\n                fd.closeSync();\r\n                if (encoding === null) {\r\n                    return buf;\r\n                }\r\n                return buf.toString(encoding);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            // Get file.\r\n            this.open(fname, flag, 0x1a4, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                try {\r\n                    if (typeof data === 'string') {\r\n                        data = Buffer.from(data, encoding);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    return cb(e);\r\n                }\r\n                // Write into file.\r\n                fd.write(data, 0, data.length, 0, cb);\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            // Get file.\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                // Write into file.\r\n                fd.writeSync(data, 0, data.length, 0);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            // Wrap cb in file closing code.\r\n            const oldCb = cb;\r\n            this.open(fname, flag, mode, function (err, fd) {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                cb = function (err) {\r\n                    fd.close(function (err2) {\r\n                        oldCb(err ? err : err2);\r\n                    });\r\n                };\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.write(data, 0, data.length, null, cb);\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            const fd = this.openSync(fname, flag, mode);\r\n            try {\r\n                if (typeof data === 'string') {\r\n                    data = Buffer.from(data, encoding);\r\n                }\r\n                fd.writeSync(data, 0, data.length, null);\r\n            }\r\n            finally {\r\n                fd.closeSync();\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n        readlink(p, cb) {\r\n            cb(new FileError(ErrorCodes.ENOTSUP));\r\n        }\r\n        readlinkSync(p) {\r\n            throw new FileError(ErrorCodes.ENOTSUP);\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.BaseProvider = BaseProvider;\r\n});\ndefine('skylark-data-files/providers/dropbox/dropbox-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n    'use strict';\r\n\r\n    class DropboxFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            this._fs._syncFile(this.getPath(), this.getBuffer(), cb);\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n    return  DropboxFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/dropbox/dropbox-provider',[\n    \"skylark-langx-funcs/defer\",\n    \"skylark-langx-binary/buffer\",\n    \"skylark-langx-paths\",\n    \"../registry\",\n    \"../base-provider\",\n    '../../stats',\n    '../../file-type',\n    '../../file-error',\n    '../../error-codes',\n    '../../utils',\n    './dropbox-file'\n], function (setImmediate,Buffer,paths, registry,BaseProvider, Stats,FileType,FileError, ErrorCodes, utils,DropboxFile) {\n    'use strict';\n\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer } =  utils;\n///    const { Dropbox } =  dropbox_bridge;\n    const { dirname } =  paths;\n\n\n    /**\n     * Dropbox paths do not begin with a /, they just begin with a folder at the root node.\n     * Here, we strip the `/`.\n     * @param p An absolute path\n     */\n    function FixPath(p) {\n        if (p === '/') {\n            return '';\n        }\n        else {\n            return p;\n        }\n    }\n    /**\n     * HACK: Dropbox errors are FUBAR'd sometimes.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @param e\n     */\n    function ExtractTheFuckingError(e) {\n        const obj = e.error;\n        if (obj['.tag']) {\n            // Everything is OK.\n            return obj;\n        }\n        else if (obj['error']) {\n            // Terrible nested object bug.\n            const obj2 = obj.error;\n            if (obj2['.tag']) {\n                return obj2;\n            }\n            else if (obj2['reason'] && obj2['reason']['.tag']) {\n                return obj2.reason;\n            }\n            else {\n                return obj2;\n            }\n        }\n        else if (typeof (obj) === 'string') {\n            // Might be a fucking JSON object error.\n            try {\n                const obj2 = JSON.parse(obj);\n                if (obj2['error'] && obj2['error']['reason'] && obj2['error']['reason']['.tag']) {\n                    return obj2.error.reason;\n                }\n            }\n            catch (e) {\n                // Nope. Give up.\n            }\n        }\n        return obj;\n    }\n    /**\n     * Returns a user-facing error message given an error.\n     *\n     * HACK: Dropbox error messages sometimes lack a `user_message` field.\n     * Sometimes, they are even strings. Ugh.\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/146\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/145\n     * @url https://github.com/dropbox/dropbox-sdk-js/issues/144\n     * @param err An error.\n     */\n    function GetErrorMessage(err) {\n        if (err['user_message']) {\n            return err.user_message.text;\n        }\n        else if (err['error_summary']) {\n            return err.error_summary;\n        }\n        else if (typeof (err.error) === \"string\") {\n            return err.error;\n        }\n        else if (typeof (err.error) === \"object\") {\n            // DROPBOX BUG: Sometimes, error is a nested error.\n            return GetErrorMessage(err.error);\n        }\n        else {\n            throw new Error(`Dropbox's servers gave us a garbage error message: ${JSON.stringify(err)}`);\n        }\n    }\n    function LookupErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'not_found':\n                return FileError.ENOENT(p);\n            case 'not_file':\n                return FileError.EISDIR(p);\n            case 'not_folder':\n                return FileError.ENOTDIR(p);\n            case 'restricted_content':\n                return FileError.EPERM(p);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function WriteErrorToError(err, p, msg) {\n        switch (err['.tag']) {\n            case 'malformed_path':\n            case 'disallowed_name':\n                return new FileError(ErrorCodes.EBADF, msg, p);\n            case 'conflict':\n            case 'no_write_permission':\n            case 'team_folder':\n                return FileError.EPERM(p);\n            case 'insufficient_space':\n                return new FileError(ErrorCodes.ENOSPC, msg);\n            case 'other':\n            default:\n                return new FileError(ErrorCodes.EIO, msg, p);\n        }\n    }\n    function FilesDeleteWrapped(client, p, cb) {\n        const arg = {\n            path: FixPath(p)\n        };\n        client.filesDeleteV2(arg)\n            .then(() => {\n            cb();\n        }).catch((e) => {\n            const err = ExtractTheFuckingError(e);\n            switch (err['.tag']) {\n                case 'path_lookup':\n                    cb(LookupErrorToError(err.path_lookup, p, GetErrorMessage(e)));\n                    break;\n                case 'path_write':\n                    cb(WriteErrorToError(err.path_write, p, GetErrorMessage(e)));\n                    break;\n                case 'too_many_write_operations':\n                    setTimeout(() => FilesDeleteWrapped(client, p, cb), 500 + (300 * (Math.random())));\n                    break;\n                case 'other':\n                default:\n                    cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                    break;\n            }\n        });\n    }\n\n    /**\n     * A read/write file system backed by Dropbox cloud storage.\n     *\n     * Uses the Dropbox V2 API, and the 2.x JS SDK.\n     */\n    class DropboxProvider extends BaseProvider {\n        constructor(client) {\n            super();\n            this._client = client;\n        }\n        /**\n         * Creates a new DropboxProvider instance with the given options.\n         * Must be given an *authenticated* Dropbox client from 2.x JS SDK.\n         */\n        static Create(opts, cb) {\n            cb(null, new DropboxProvider(opts.client));\n        }\n        static isAvailable() {\n            // Checks if the Dropbox library is loaded.\n            return typeof Dropbox !== 'undefined';\n        }\n        getName() {\n            return DropboxProvider.Name;\n        }\n        isReadOnly() {\n            return false;\n        }\n        // Dropbox doesn't support symlinks, properties, or synchronous calls\n        // TODO: does it???\n        supportsSymlinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            return false;\n        }\n        /**\n         * Deletes *everything* in the file system. Mainly intended for unit testing!\n         * @param mainCb Called when operation completes.\n         */\n        empty(mainCb) {\n            this.readdir('/', (e, paths) => {\n                if (paths) {\n                    const next = (e) => {\n                        if (paths.length === 0) {\n                            mainCb();\n                        }\n                        else {\n                            FilesDeleteWrapped(this._client, paths.shift(), next);\n                        }\n                    };\n                    next();\n                }\n                else {\n                    mainCb(e);\n                }\n            });\n        }\n        rename(oldPath, newPath, cb) {\n            // Dropbox doesn't let you rename things over existing things, but POSIX does.\n            // So, we need to see if newPath exists...\n            this.stat(newPath, false, (e, stats) => {\n                const rename = () => {\n                    const relocationArg = {\n                        from_path: FixPath(oldPath),\n                        to_path: FixPath(newPath)\n                    };\n                    this._client.filesMoveV2(relocationArg)\n                        .then(() => cb())\n                        .catch(function (e) {\n                        const err = ExtractTheFuckingError(e);\n                        switch (err['.tag']) {\n                            case 'from_lookup':\n                                cb(LookupErrorToError(err.from_lookup, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'from_write':\n                                cb(WriteErrorToError(err.from_write, oldPath, GetErrorMessage(e)));\n                                break;\n                            case 'to':\n                                cb(WriteErrorToError(err.to, newPath, GetErrorMessage(e)));\n                                break;\n                            case 'cant_copy_shared_folder':\n                            case 'cant_nest_shared_folder':\n                                cb(new FileError(ErrorCodes.EPERM, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'cant_move_folder_into_itself':\n                            case 'duplicated_or_nested_paths':\n                                cb(new FileError(ErrorCodes.EBADF, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'too_many_files':\n                                cb(new FileError(ErrorCodes.ENOSPC, GetErrorMessage(e), oldPath));\n                                break;\n                            case 'other':\n                            default:\n                                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), oldPath));\n                                break;\n                        }\n                    });\n                };\n                if (e) {\n                    // Doesn't exist. Proceed!\n                    rename();\n                }\n                else if (oldPath === newPath) {\n                    // NOP if the path exists. Error if it doesn't exist.\n                    if (e) {\n                        cb(FileError.ENOENT(newPath));\n                    }\n                    else {\n                        cb();\n                    }\n                }\n                else if (stats && stats.isDirectory()) {\n                    // Exists, is a directory. Cannot rename over an existing directory.\n                    cb(FileError.EISDIR(newPath));\n                }\n                else {\n                    // Exists, is a file, and differs from oldPath. Delete and rename.\n                    this.unlink(newPath, (e) => {\n                        if (e) {\n                            cb(e);\n                        }\n                        else {\n                            rename();\n                        }\n                    });\n                }\n            });\n        }\n        stat(path, isLstat, cb) {\n            if (path === '/') {\n                // Dropbox doesn't support querying the root directory.\n                setImmediate(function () {\n                    cb(null, new Stats(FileType.DIRECTORY, 4096));\n                });\n                return;\n            }\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesGetMetadata(arg).then((ref) => {\n                switch (ref['.tag']) {\n                    case 'file':\n                        const fileMetadata = ref;\n                        // TODO: Parse time fields.\n                        cb(null, new Stats(FileType.FILE, fileMetadata.size));\n                        break;\n                    case 'folder':\n                        cb(null, new Stats(FileType.DIRECTORY, 4096));\n                        break;\n                    case 'deleted':\n                        cb(FileError.ENOENT(path));\n                        break;\n                    default:\n                        // Unknown.\n                        break;\n                }\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        cb(LookupErrorToError(err.path, path, GetErrorMessage(e)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        openFile(path, flags, cb) {\n            const downloadArg = {\n                path: FixPath(path)\n            };\n            this._client.filesDownload(downloadArg).then((res) => {\n                const b = res.fileBlob;\n                const fr = new FileReader();\n                fr.onload = () => {\n                    const ab = fr.result;\n                    cb(null, new DropboxFile(this, path, flags, new Stats(FileType.FILE, ab.byteLength), arrayBuffer2Buffer(ab)));\n                };\n                fr.readAsArrayBuffer(b);\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const dpError = err;\n                        cb(LookupErrorToError(dpError.path, path, GetErrorMessage(e)));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                        break;\n                }\n            });\n        }\n        createFile(p, flags, mode, cb) {\n            const fileData = Buffer.alloc(0);\n            const blob = new Blob([buffer2ArrayBuffer(fileData)], { type: \"octet/stream\" });\n            const commitInfo = {\n                contents: blob,\n                path: FixPath(p)\n            };\n            this._client.filesUpload(commitInfo).then((metadata) => {\n                cb(null, new DropboxFile(this, p, flags, new Stats(FileType.FILE, 0), fileData));\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                // HACK: Casting to 'any' since tag can be 'too_many_write_operations'.\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        // Retry in (500, 800) ms.\n                        setTimeout(() => this.createFile(p, flags, mode, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n        /**\n         * Delete a file\n         */\n        unlink(path, cb) {\n            // Must be a file. Check first.\n            this.stat(path, false, (e, stat) => {\n                if (stat) {\n                    if (stat.isDirectory()) {\n                        cb(FileError.EISDIR(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Delete a directory\n         */\n        rmdir(path, cb) {\n            this.readdir(path, (e, paths) => {\n                if (paths) {\n                    if (paths.length > 0) {\n                        cb(FileError.ENOTEMPTY(path));\n                    }\n                    else {\n                        FilesDeleteWrapped(this._client, path, cb);\n                    }\n                }\n                else {\n                    cb(e);\n                }\n            });\n        }\n        /**\n         * Create a directory\n         */\n        mkdir(p, mode, cb) {\n            // Dropbox's create_folder is recursive. Check if parent exists.\n            const parent = dirname(p);\n            this.stat(parent, false, (e, stats) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (stats && !stats.isDirectory()) {\n                    cb(FileError.ENOTDIR(parent));\n                }\n                else {\n                    const arg = {\n                        path: FixPath(p)\n                    };\n                    this._client.filesCreateFolderV2(arg).then(() => cb()).catch((e) => {\n                        const err = ExtractTheFuckingError(e);\n                        if (err['.tag'] === \"too_many_write_operations\") {\n                            // Retry in a bit.\n                            setTimeout(() => this.mkdir(p, mode, cb), 500 + (300 * (Math.random())));\n                        }\n                        else {\n                            cb(WriteErrorToError(ExtractTheFuckingError(e).path, p, GetErrorMessage(e)));\n                        }\n                    });\n                }\n            });\n        }\n        /**\n         * Get the names of the files in a directory\n         */\n        readdir(path, cb) {\n            const arg = {\n                path: FixPath(path)\n            };\n            this._client.filesListFolder(arg).then((res) => {\n                ContinueReadingDir(this._client, path, res, [], cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n        /**\n         * (Internal) Syncs file to Dropbox.\n         */\n        _syncFile(p, d, cb) {\n            const blob = new Blob([buffer2ArrayBuffer(d)], { type: \"octet/stream\" });\n            const arg = {\n                contents: blob,\n                path: FixPath(p),\n                mode: {\n                    '.tag': 'overwrite'\n                }\n            };\n            this._client.filesUpload(arg).then(() => {\n                cb();\n            }).catch((e) => {\n                const err = ExtractTheFuckingError(e);\n                switch (err['.tag']) {\n                    case 'path':\n                        const upError = err;\n                        cb(WriteErrorToError(upError.path.reason, p, GetErrorMessage(e)));\n                        break;\n                    case 'too_many_write_operations':\n                        setTimeout(() => this._syncFile(p, d, cb), 500 + (300 * (Math.random())));\n                        break;\n                    case 'other':\n                    default:\n                        cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), p));\n                        break;\n                }\n            });\n        }\n    }\n    DropboxProvider.Name = \"DropboxV2\";\n    DropboxProvider.Options = {\n        client: {\n            type: \"object\",\n            description: \"An *authenticated* Dropbox client. Must be from the 2.5.x JS SDK.\"\n        }\n    };\n    function ProcessListFolderError(e, path, cb) {\n        const err = ExtractTheFuckingError(e);\n        switch (err['.tag']) {\n            case 'path':\n                const pathError = err;\n                cb(LookupErrorToError(pathError.path, path, GetErrorMessage(e)));\n                break;\n            case 'other':\n            default:\n                cb(new FileError(ErrorCodes.EIO, GetErrorMessage(e), path));\n                break;\n        }\n    }\n    function ContinueReadingDir(client, path, res, previousEntries, cb) {\n        const newEntries = res.entries.map((e) => e.path_display).filter((p) => !!p);\n        const entries = previousEntries.concat(newEntries);\n        if (!res.has_more) {\n            cb(null, entries);\n        }\n        else {\n            const arg = {\n                cursor: res.cursor\n            };\n            client.filesListFolderContinue(arg).then((res) => {\n                ContinueReadingDir(client, path, res, entries, cb);\n            }).catch((e) => {\n                ProcessListFolderError(e, path, cb);\n            });\n        }\n    }\n\n    DropboxProvider.DropboxFile = DropboxFile;\n\n    return  DropboxProvider;\n    \n});\ndefine('skylark-data-files/providers/html5/html5-lfs-file',[\r\n    \"../../utils\",\r\n    '../../preload-file'\r\n], function (utils,PreloadFile) {\r\n    'use strict';\r\n\r\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\r\n\r\n    // A note about getFile and getDirectory options:\r\n    // These methods are called at numerous places in this file, and are passed\r\n    // some combination of these two options:\r\n    //   - create: If true, the entry will be created if it doesn't exist.\r\n    //             If false, an error will be thrown if it doesn't exist.\r\n    //   - exclusive: If true, only create the entry if it doesn't already exist,\r\n    //                and throw an error if it does.\r\n    class Html5LfsFile extends PreloadFile {\r\n        constructor(fs, entry, path, flag, stat, contents) {\r\n            super(fs, path, flag, stat, contents);\r\n            this._entry = entry;\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                return cb();\r\n            }\r\n            this._entry.createWriter((writer) => {\r\n                const buffer = this.getBuffer();\r\n                const blob = new Blob([buffer2ArrayBuffer(buffer)]);\r\n                const length = blob.size;\r\n                writer.onwriteend = (err) => {\r\n                    writer.onwriteend = null;\r\n                    writer.onerror = null;\r\n                    writer.truncate(length);\r\n                    this.resetDirty();\r\n                    cb();\r\n                };\r\n                writer.onerror = (err) => {\r\n                    cb(convertError(err, this.getPath(), false));\r\n                };\r\n                writer.write(blob);\r\n            });\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n    return Html5LfsFile;\r\n});\ndefine('skylark-data-files/providers/html5/html5-lfs-provider',[\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    '../../preload-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    \"./html5-lfs-file\"\n], function (async,paths,PreloadFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType, utils,Html5LfsFile) {\n    'use strict';\n\n    const asyncEach = async.each;\n\n    const { buffer2ArrayBuffer, arrayBuffer2Buffer } = utils;\n\n\n    /**\n     * @hidden\n     */\n    function isDirectoryEntry(entry) {\n        return entry.isDirectory;\n    }\n\n    /**\n     * @hidden\n     */\n    const _getFS = window.webkitRequestProvider || window.requestProvider || null;\n\n    /**\n     * @hidden\n     */\n    function _requestQuota(type, size, success, errorCallback) {\n        // We cast navigator and window to '<any>' because everything here is\n        // nonstandard functionality, despite the fact that Chrome has the only\n        // implementation of the HTML5FS and is likely driving the standardization\n        // process. Thus, these objects defined off of navigator and window are not\n        // present in the DefinitelyTyped TypeScript typings for Provider.\n        if (typeof navigator['webkitPersistentStorage'] !== 'undefined') {\n            switch (type) {\n                case window.PERSISTENT:\n                    navigator.webkitPersistentStorage.requestQuota(size, success, errorCallback);\n                    break;\n                case window.TEMPORARY:\n                    navigator.webkitTemporaryStorage.requestQuota(size, success, errorCallback);\n                    break;\n                default:\n                    errorCallback(new TypeError(`Invalid storage type: ${type}`));\n                    break;\n            }\n        }\n        else {\n            window.webkitStorageInfo.requestQuota(type, size, success, errorCallback);\n        }\n    }\n    /**\n     * @hidden\n     */\n    function _toArray(list) {\n        return Array.prototype.slice.call(list || [], 0);\n    }\n    /**\n     * Converts the given DOMError into an appropriate FileError.\n     * @url https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n     * @hidden\n     */\n    function convertError(err, p, expectedDir) {\n        switch (err.name) {\n            /* The user agent failed to create a file or directory due to the existence of a file or\n                directory with the same path.  */\n            case \"PathExistsError\":\n                return FileError.EEXIST(p);\n            /* The operation failed because it would cause the application to exceed its storage quota.  */\n            case 'QuotaExceededError':\n                return FileError.FileError(ErrorCodes.ENOSPC, p);\n            /*  A required file or directory could not be found at the time an operation was processed.   */\n            case 'NotFoundError':\n                return FileError.ENOENT(p);\n            /* This is a security error code to be used in situations not covered by any other error codes.\n                - A required file was unsafe for access within a Web application\n                - Too many calls are being made on filesystem resources */\n            case 'SecurityError':\n                return FileError.FileError(ErrorCodes.EACCES, p);\n            /* The modification requested was illegal. Examples of invalid modifications include moving a\n                directory into its own child, moving a file into its parent directory without changing its name,\n                or copying a directory to a path occupied by a file.  */\n            case 'InvalidModificationError':\n                return FileError.FileError(ErrorCodes.EPERM, p);\n            /* The user has attempted to look up a file or directory, but the Entry found is of the wrong type\n                [e.g. is a DirectoryEntry when the user requested a FileEntry].  */\n            case 'TypeMismatchError':\n                return FileError.FileError(expectedDir ? ErrorCodes.ENOTDIR : ErrorCodes.EISDIR, p);\n            /* A path or URL supplied to the API was malformed.  */\n            case \"EncodingError\":\n            /* An operation depended on state cached in an interface object, but that state that has changed\n                since it was read from disk.  */\n            case \"InvalidStateError\":\n            /* The user attempted to write to a file or directory which could not be modified due to the state\n                of the underlying filesystem.  */\n            case \"NoModificationAllowedError\":\n            default:\n                return FileError.FileError(ErrorCodes.EINVAL, p);\n        }\n    }\n\n    /**\n     * A read-write filesystem backed by the HTML5 Provider API.\n     *\n     * As the HTML5 Provider is only implemented in Blink, this interface is\n     * only available in Chrome.\n     */\n    class Html5LfsProvider extends BaseProvider {\n\n        /**\n         * @param size storage quota to request, in megabytes. Allocated value may be less.\n         * @param type window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\n         */\n        constructor(size = 5, type = window.PERSISTENT) {\n            super();\n            // Convert MB to bytes.\n            this.size = 1024 * 1024 * size;\n            this.type = type;\n        }\n\n        /**\n         * Creates an Html5LfsProvider instance with the given options.\n         */\n        static Create(opts, cb) {\n            const fs = new Html5LfsProvider(opts.size, opts.type);\n            fs._allocate((e) => e ? cb(e) : cb(null, fs));\n        }\n\n        static isAvailable() {\n            return !!_getFS;\n        }\n\n        getName() {\n            return Html5LfsProvider.Name;\n        }\n\n        isReadOnly() {\n            return false;\n        }\n\n        supportsSymlinks() {\n            return false;\n        }\n\n        supportsProps() {\n            return false;\n        }\n\n        supportsSynch() {\n            return false;\n        }\n\n        /**\n         * Deletes everything in the FS. Used for testing.\n         * Karma clears the storage after you quit it but not between runs of the test\n         * suite, and the tests expect an empty FS every time.\n         */\n        empty(mainCb) {\n            // Get a list of all entries in the root directory to delete them\n            this._readdir('/', (err, entries) => {\n                if (err) {\n                    mainCb(err);\n                }\n                else {\n                    // Called when every entry has been operated on\n                    const finished = (er) => {\n                        if (err) {\n                            mainCb(err);\n                        }\n                        else {\n                            mainCb();\n                        }\n                    };\n                    // Removes files and recursively removes directories\n                    const deleteEntry = (entry, cb) => {\n                        const succ = () => {\n                            cb();\n                        };\n                        const error = (err) => {\n                            cb(convertError(err, entry.fullPath, !entry.isDirectory));\n                        };\n                        if (isDirectoryEntry(entry)) {\n                            entry.removeRecursively(succ, error);\n                        }\n                        else {\n                            entry.remove(succ, error);\n                        }\n                    };\n                    // Loop through the entries and remove them, then call the callback\n                    // when they're all finished.\n                    asyncEach(entries, deleteEntry, finished);\n                }\n            });\n        }\n\n        rename(oldPath, newPath, cb) {\n            let semaphore = 2;\n            let successCount = 0;\n            const root = this.fs.root;\n            let currentPath = oldPath;\n            const error = (err) => {\n                if (--semaphore <= 0) {\n                    cb(convertError(err, currentPath, false));\n                }\n            };\n            const success = (file) => {\n                if (++successCount === 2) {\n                    return cb(new FileError(ErrorCodes.EINVAL, \"Something was identified as both a file and a directory. This should never happen.\"));\n                }\n                // SPECIAL CASE: If newPath === oldPath, and the path exists, then\n                // this operation trivially succeeds.\n                if (oldPath === newPath) {\n                    return cb();\n                }\n                // Get the new parent directory.\n                currentPath = paths.dirname(newPath);\n                root.getDirectory(currentPath, {}, (parentDir) => {\n                    currentPath = paths.basename(newPath);\n                    file.moveTo(parentDir, currentPath, (entry) => { cb(); }, (err) => {\n                        // SPECIAL CASE: If oldPath is a directory, and newPath is a\n                        // file, rename should delete the file and perform the move.\n                        if (file.isDirectory) {\n                            currentPath = newPath;\n                            // Unlink only works on files. Try to delete newPath.\n                            this.unlink(newPath, (e) => {\n                                if (e) {\n                                    // newPath is probably a directory.\n                                    error(err);\n                                }\n                                else {\n                                    // Recur, now that newPath doesn't exist.\n                                    this.rename(oldPath, newPath, cb);\n                                }\n                            });\n                        }\n                        else {\n                            error(err);\n                        }\n                    });\n                }, error);\n            };\n            // We don't know if oldPath is a *file* or a *directory*, and there's no\n            // way to stat items. So launch both requests, see which one succeeds.\n            root.getFile(oldPath, {}, success, error);\n            root.getDirectory(oldPath, {}, success, error);\n        }\n\n        stat(path, isLstat, cb) {\n            // Throw an error if the entry doesn't exist, because then there's nothing\n            // to stat.\n            const opts = {\n                create: false\n            };\n            // Called when the path has been successfully loaded as a file.\n            const loadAsFile = (entry) => {\n                const fileFromEntry = (file) => {\n                    const stat = new Stats(FileType.FILE, file.size);\n                    cb(null, stat);\n                };\n                entry.file(fileFromEntry, failedToLoad);\n            };\n            // Called when the path has been successfully loaded as a directory.\n            const loadAsDir = (dir) => {\n                // Directory entry size can't be determined from the HTML5 FS API, and is\n                // implementation-dependant anyway, so a dummy value is used.\n                const size = 4096;\n                const stat = new Stats(FileType.DIRECTORY, size);\n                cb(null, stat);\n            };\n            // Called when the path couldn't be opened as a directory or a file.\n            const failedToLoad = (err) => {\n                cb(convertError(err, path, false /* Unknown / irrelevant */));\n            };\n            // Called when the path couldn't be opened as a file, but might still be a\n            // directory.\n            const failedToLoadAsFile = () => {\n                this.fs.root.getDirectory(path, opts, loadAsDir, failedToLoad);\n            };\n            // No method currently exists to determine whether a path refers to a\n            // directory or a file, so this implementation tries both and uses the first\n            // one that succeeds.\n            this.fs.root.getFile(path, opts, loadAsFile, failedToLoadAsFile);\n        }\n        open(p, flags, mode, cb) {\n            // XXX: err is a DOMError\n            const error = (err) => {\n                if (err.name === 'InvalidModificationError' && flags.isExclusive()) {\n                    cb(FileError.EEXIST(p));\n                }\n                else {\n                    cb(convertError(err, p, false));\n                }\n            };\n            this.fs.root.getFile(p, {\n                create: flags.pathNotExistsAction() === ActionType.CREATE_FILE,\n                exclusive: flags.isExclusive()\n            }, (entry) => {\n                // Try to fetch corresponding file.\n                entry.file((file) => {\n                    const reader = new FileReader();\n                    reader.onloadend = (event) => {\n                        const bfsFile = this._makeFile(p, entry, flags, file, reader.result);\n                        cb(null, bfsFile);\n                    };\n                    reader.onerror = (ev) => {\n                        error(reader.error);\n                    };\n                    reader.readAsArrayBuffer(file);\n                }, error);\n            }, error);\n        }\n        unlink(path, cb) {\n            this._remove(path, cb, true);\n        }\n        rmdir(path, cb) {\n            // Check if directory is non-empty, first.\n            this.readdir(path, (e, files) => {\n                if (e) {\n                    cb(e);\n                }\n                else if (files.length > 0) {\n                    cb(FileError.ENOTEMPTY(path));\n                }\n                else {\n                    this._remove(path, cb, false);\n                }\n            });\n        }\n        mkdir(path, mode, cb) {\n            // Create the directory, but throw an error if it already exists, as per\n            // mkdir(1)\n            const opts = {\n                create: true,\n                exclusive: true\n            };\n            const success = (dir) => {\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            this.fs.root.getDirectory(path, opts, success, error);\n        }\n        /**\n         * Map _readdir's list of `FileEntry`s to their names and return that.\n         */\n        readdir(path, cb) {\n            this._readdir(path, (e, entries) => {\n                if (entries) {\n                    const rv = [];\n                    for (const entry of entries) {\n                        rv.push(entry.name);\n                    }\n                    cb(null, rv);\n                }\n                else {\n                    return cb(e);\n                }\n            });\n        }\n        /**\n         * Returns a BrowserFS object representing a File.\n         */\n        _makeFile(path, entry, flag, stat, data = new ArrayBuffer(0)) {\n            const stats = new Stats(FileType.FILE, stat.size);\n            const buffer = arrayBuffer2Buffer(data);\n            return new Html5LfsFile(this, entry, path, flag, stats, buffer);\n        }\n        /**\n         * Returns an array of `FileEntry`s. Used internally by empty and readdir.\n         */\n        _readdir(path, cb) {\n            const error = (err) => {\n                cb(convertError(err, path, true));\n            };\n            // Grab the requested directory.\n            this.fs.root.getDirectory(path, { create: false }, (dirEntry) => {\n                const reader = dirEntry.createReader();\n                let entries = [];\n                // Call the reader.readEntries() until no more results are returned.\n                const readEntries = () => {\n                    reader.readEntries(((results) => {\n                        if (results.length) {\n                            entries = entries.concat(_toArray(results));\n                            readEntries();\n                        }\n                        else {\n                            cb(null, entries);\n                        }\n                    }), error);\n                };\n                readEntries();\n            }, error);\n        }\n        \n        /**\n         * Requests a storage quota from the browser to back this FS.\n         */\n        _allocate(cb) {\n            const success = (fs) => {\n                this.fs = fs;\n                cb();\n            };\n            const error = (err) => {\n                cb(convertError(err, \"/\", true));\n            };\n            if (this.type === window.PERSISTENT) {\n                _requestQuota(this.type, this.size, (granted) => {\n                    _getFS(this.type, granted, success, error);\n                }, error);\n            }\n            else {\n                _getFS(this.type, this.size, success, error);\n            }\n        }\n        /**\n         * Delete a file or directory from the file system\n         * isFile should reflect which call was made to remove the it (`unlink` or\n         * `rmdir`). If this doesn't match what's actually at `path`, an error will be\n         * returned\n         */\n        _remove(path, cb, isFile) {\n            const success = (entry) => {\n                const succ = () => {\n                    cb();\n                };\n                const err = (err) => {\n                    cb(convertError(err, path, !isFile));\n                };\n                entry.remove(succ, err);\n            };\n            const error = (err) => {\n                cb(convertError(err, path, !isFile));\n            };\n            // Deleting the entry, so don't create it\n            const opts = {\n                create: false\n            };\n            if (isFile) {\n                this.fs.root.getFile(path, opts, success, error);\n            }\n            else {\n                this.fs.root.getDirectory(path, opts, success, error);\n            }\n        }\n    }\n    Html5LfsProvider.Name = \"Html5LfsProvider\";\n    Html5LfsProvider.Options = {\n        size: {\n            type: \"number\",\n            optional: true,\n            description: \"Storage quota to request, in megabytes. Allocated value may be less. Defaults to 5.\"\n        },\n        type: {\n            type: \"number\",\n            optional: true,\n            description: \"window.PERSISTENT or window.TEMPORARY. Defaults to PERSISTENT.\"\n        }\n    };\n\n    Html5LfsProvider.Html5LfsFile = Html5LfsFile;\n\n    return Html5LfsProvider;\n});\ndefine('skylark-data-files/providers/http/xhr',[\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error',\n    \"../../utils\"\n], function (Buffer,ErrorCodes,FileError,utils) {\n    'use strict';\n    /**\n     * Contains utility methods for performing a variety of tasks with\n     * XmlHttpRequest across browsers.\n     */\n    const { isIE, emptyBuffer } = utils;\n\n\n    const xhrIsAvailable = (typeof (XMLHttpRequest) !== \"undefined\" && XMLHttpRequest !== null);\n    function asyncDownloadFileModern(p, type, cb) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, true);\n        let jsonSupported = true;\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // Some browsers don't support the JSON response type.\n                // They either reset responseType, or throw an exception.\n                // @see https://github.com/Modernizr/Modernizr/blob/master/src/testXhrType.js\n                try {\n                    req.responseType = 'json';\n                    jsonSupported = req.responseType === 'json';\n                }\n                catch (e) {\n                    jsonSupported = false;\n                }\n                break;\n            default:\n                return cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n        }\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // XXX: WebKit-based browsers return *null* when XHRing an empty file.\n                            return cb(null, req.response ? Buffer.from(req.response) : emptyBuffer());\n                        case 'json':\n                            if (jsonSupported) {\n                                return cb(null, req.response);\n                            }\n                            else {\n                                return cb(null, JSON.parse(req.responseText));\n                            }\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    function syncDownloadFileModern(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        // On most platforms, we cannot set the responseType of synchronous downloads.\n        // @todo Test for this; IE10 allows this, as do older versions of Chrome/FF.\n        let data = null;\n        let err = null;\n        // Classic hack to download binary data as a string.\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            // Convert the text into a buffer.\n                            const text = req.responseText;\n                            data = Buffer.alloc(text.length);\n                            // Throw away the upper bits of each character.\n                            for (let i = 0; i < text.length; i++) {\n                                // This will automatically throw away the upper bit of each\n                                // character for us.\n                                data[i] = text.charCodeAt(i);\n                            }\n                            return;\n                        case 'json':\n                            data = JSON.parse(req.responseText);\n                            return;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                    return;\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    function syncDownloadFileIE10(p, type) {\n        const req = new XMLHttpRequest();\n        req.open('GET', p, false);\n        switch (type) {\n            case 'buffer':\n                req.responseType = 'arraybuffer';\n                break;\n            case 'json':\n                // IE10 does not support the JSON type.\n                break;\n            default:\n                throw new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type);\n        }\n        let data;\n        let err;\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    switch (type) {\n                        case 'buffer':\n                            data = Buffer.from(req.response);\n                            break;\n                        case 'json':\n                            data = JSON.parse(req.response);\n                            break;\n                    }\n                }\n                else {\n                    err = new FileError(ErrorCodes.EIO, `XHR error: response returned code ${req.status}`);\n                }\n            }\n        };\n        req.send();\n        if (err) {\n            throw err;\n        }\n        return data;\n    }\n    /**\n     * @hidden\n     */\n    function getFileSize(async, p, cb) {\n        const req = new XMLHttpRequest();\n        req.open('HEAD', p, async);\n        req.onreadystatechange = function (e) {\n            if (req.readyState === 4) {\n                if (req.status === 200) {\n                    try {\n                        return cb(null, parseInt(req.getResponseHeader('Content-Length') || '-1', 10));\n                    }\n                    catch (e) {\n                        // In the event that the header isn't present or there is an error...\n                        return cb(new FileError(ErrorCodes.EIO, \"XHR HEAD error: Could not read content-length.\"));\n                    }\n                }\n                else {\n                    return cb(new FileError(ErrorCodes.EIO, `XHR HEAD error: response returned code ${req.status}`));\n                }\n            }\n        };\n        req.send();\n    }\n    /**\n     * Asynchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let asyncDownloadFile = asyncDownloadFileModern;\n    /**\n     * Synchronously download a file as a buffer or a JSON object.\n     * Note that the third function signature with a non-specialized type is\n     * invalid, but TypeScript requires it when you specialize string arguments to\n     * constants.\n     * @hidden\n     */\n    let syncDownloadFile = (isIE && typeof Blob !== 'undefined') ? syncDownloadFileIE10 : syncDownloadFileModern;\n    /**\n     * Synchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeSync(p) {\n        let rv = -1;\n        getFileSize(false, p, function (err, size) {\n            if (err) {\n                throw err;\n            }\n            rv = size;\n        });\n        return rv;\n    }\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n    function getFileSizeAsync(p, cb) {\n        getFileSize(true, p, cb);\n    }\n\n\n\n    return {\n        xhrIsAvailable: xhrIsAvailable,\n        asyncDownloadFile: asyncDownloadFile,\n        syncDownloadFile: syncDownloadFile,\n        getFileSizeSync: getFileSizeSync,\n        getFileSizeAsync: getFileSizeAsync\n    };\n});\ndefine('skylark-data-files/providers/http/fetch',[\n    \"skylark-langx-binary/buffer\",\n    '../../error-codes',\n    '../../file-error'\n], function (Buffer,ErrorCodes,FileError) {\n    'use strict';\n\n\n    const fetchIsAvailable = (typeof (fetch) !== \"undefined\" && fetch !== null);\n\n    function fetchFileAsync(p, type, cb) {\n        let request;\n        try {\n            request = fetch(p);\n        }\n        catch (e) {\n            // XXX: fetch will throw a TypeError if the URL has credentials in it\n            return cb(new FileError(ErrorCodes.EINVAL, e.message));\n        }\n        request\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch error: response returned code ${res.status}`));\n            }\n            else {\n                switch (type) {\n                    case 'buffer':\n                        res.arrayBuffer()\n                            .then((buf) => cb(null, Buffer.from(buf)))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    case 'json':\n                        res.json()\n                            .then((json) => cb(null, json))\n                            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n                        break;\n                    default:\n                        cb(new FileError(ErrorCodes.EINVAL, \"Invalid download type: \" + type));\n                }\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    /**\n     * Asynchronously retrieves the size of the given file in bytes.\n     * @hidden\n     */\n\n    function fetchFileSizeAsync(p, cb) {\n        fetch(p, { method: 'HEAD' })\n            .then((res) => {\n            if (!res.ok) {\n                return cb(new FileError(ErrorCodes.EIO, `fetch HEAD error: response returned code ${res.status}`));\n            }\n            else {\n                return cb(null, parseInt(res.headers.get('Content-Length') || '-1', 10));\n            }\n        })\n            .catch((err) => cb(new FileError(ErrorCodes.EIO, err.message)));\n    }\n\n    return {\n        fetchIsAvailable: fetchIsAvailable,\n        fetchFileAsync: fetchFileAsync,\n        fetchFileSizeAsync: fetchFileSizeAsync\n    };\n});\ndefine('skylark-data-files/inodes/dir-inode',[\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a directory. Currently only contains the directory listing.\r\n     */\r\n    class DirInode {\r\n        /**\r\n         * Constructs an inode for a directory.\r\n         */\r\n        constructor(data = null) {\r\n            this.data = data;\r\n            this._ls = {};\r\n        }\r\n        isFile() {\r\n            return false;\r\n        }\r\n        isDir() {\r\n            return true;\r\n        }\r\n        getData() { return this.data; }\r\n        /**\r\n         * Return a Stats object for this inode.\r\n         * @todo Should probably remove this at some point. This isn't the\r\n         *       responsibility of the FileIndex.\r\n         */\r\n        getStats() {\r\n            return new Stats(FileType.DIRECTORY, 4096, 0x16D);\r\n        }\r\n        /**\r\n         * Returns the directory listing for this directory. Paths in the directory are\r\n         * relative to the directory's path.\r\n         * @return The directory listing for this directory.\r\n         */\r\n        getListing() {\r\n            return Object.keys(this._ls);\r\n        }\r\n        /**\r\n         * Returns the inode for the indicated item, or null if it does not exist.\r\n         * @param p Name of item in this directory.\r\n         */\r\n        getItem(p) {\r\n            const item = this._ls[p];\r\n            return item ? item : null;\r\n        }\r\n        /**\r\n         * Add the given item to the directory listing. Note that the given inode is\r\n         * not copied, and will be mutated by the DirInode if it is a DirInode.\r\n         * @param p Item name to add to the directory listing.\r\n         * @param inode The inode for the\r\n         *   item to add to the directory inode.\r\n         * @return True if it was added, false if it already existed.\r\n         */\r\n        addItem(p, inode) {\r\n            if (p in this._ls) {\r\n                return false;\r\n            }\r\n            this._ls[p] = inode;\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given item from the directory listing.\r\n         * @param p Name of item to remove from the directory listing.\r\n         * @return Returns the item\r\n         *   removed, or null if the item did not exist.\r\n         */\r\n        remItem(p) {\r\n            const item = this._ls[p];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            delete this._ls[p];\r\n            return item;\r\n        }\r\n    }\r\n\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    DirInode.isDirInode =  function isDirInode(inode) {\r\n        return !!inode && inode.isDir();\r\n    }\r\n\r\n\r\n    return DirInode;\r\n});\ndefine('skylark-data-files/inodes/file-inode',[\r\n], function () {\r\n    'use strict';\r\n\r\n    /**\r\n     * Inode for a file. Stores an arbitrary (filesystem-specific) data payload.\r\n     */\r\n    class FileInode {\r\n        constructor(data) {\r\n            this.data = data;\r\n        }\r\n        isFile() { return true; }\r\n        isDir() { return false; }\r\n        getData() { return this.data; }\r\n        setData(data) { this.data = data; }\r\n    }\r\n    /**\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    FileInode.isFileInode = function isFileInode(inode) {\r\n        return !!inode && inode.isFile();\r\n    };\r\n\r\n\r\n    return FileInode;\r\n\r\n});\ndefine('skylark-data-files/inodes/file-index',[\r\n    \"skylark-langx-paths\",\r\n    '../stats',\r\n    '../file-type',\r\n    \"./dir-inode\",\r\n    \"./file-inode\"\r\n], function (paths, Stats,FileType,DirInode,FileINode) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple class for storing a filesystem index. Assumes that all paths passed\r\n     * to it are *absolute* paths.\r\n     *\r\n     * Can be used as a partial or a full index, although care must be taken if used\r\n     * for the former purpose, especially when directories are concerned.\r\n     */\r\n    class FileIndex {\r\n        /**\r\n         * Constructs a new FileIndex.\r\n         */\r\n        constructor() {\r\n            // _index is a single-level key,value store that maps *directory* paths to\r\n            // DirInodes. File information is only contained in DirInodes themselves.\r\n            this._index = {};\r\n            // Create the root directory.\r\n            this.addPath('/', new DirInode());\r\n        }\r\n        /**\r\n         * Static method for constructing indices from a JSON listing.\r\n         * @param listing Directory listing generated by tools/XHRIndexer.coffee\r\n         * @return A new FileIndex object.\r\n         */\r\n        static fromListing(listing) {\r\n            const idx = new FileIndex();\r\n            // Add a root DirNode.\r\n            const rootInode = new DirInode();\r\n            idx._index['/'] = rootInode;\r\n            const queue = [['', listing, rootInode]];\r\n            while (queue.length > 0) {\r\n                let inode;\r\n                const next = queue.pop();\r\n                const pwd = next[0];\r\n                const tree = next[1];\r\n                const parent = next[2];\r\n                for (const node in tree) {\r\n                    if (tree.hasOwnProperty(node)) {\r\n                        const children = tree[node];\r\n                        const name = `${pwd}/${node}`;\r\n                        if (children) {\r\n                            idx._index[name] = inode = new DirInode();\r\n                            queue.push([name, children, inode]);\r\n                        }\r\n                        else {\r\n                            // This inode doesn't have correct size information, noted with -1.\r\n                            inode = new FileInode(new Stats(FileType.FILE, -1, 0x16D));\r\n                        }\r\n                        if (parent) {\r\n                            parent._ls[node] = inode;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return idx;\r\n        }\r\n        /**\r\n         * Runs the given function over all files in the index.\r\n         */\r\n        fileIterator(cb) {\r\n            for (const path in this._index) {\r\n                if (this._index.hasOwnProperty(path)) {\r\n                    const dir = this._index[path];\r\n                    const files = dir.getListing();\r\n                    for (const file of files) {\r\n                        const item = dir.getItem(file);\r\n                        if (isFileInode(item)) {\r\n                            cb(item.getData());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPath(path, inode) {\r\n            if (!inode) {\r\n                throw new Error('Inode must be specified');\r\n            }\r\n            if (path[0] !== '/') {\r\n                throw new Error('Path must be absolute, got: ' + path);\r\n            }\r\n            // Check if it already exists.\r\n            if (this._index.hasOwnProperty(path)) {\r\n                return this._index[path] === inode;\r\n            }\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[dirpath];\r\n            if (parent === undefined && path !== '/') {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                if (!this.addPath(dirpath, parent)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // Add myself to my parent.\r\n            if (path !== '/') {\r\n                if (!parent.addItem(itemname, inode)) {\r\n                    return false;\r\n                }\r\n            }\r\n            // If I'm a directory, add myself to the index.\r\n            if (isDirInode(inode)) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Adds the given absolute path to the index if it is not already in the index.\r\n         * The path is added without special treatment (no joining of adjacent separators, etc).\r\n         * Creates any needed parent directories.\r\n         * @param path The path to add to the index.\r\n         * @param inode The inode for the\r\n         *   path to add.\r\n         * @return 'True' if it was added or already exists, 'false' if there\r\n         *   was an issue adding it (e.g. item in path is a file, item exists but is\r\n         *   different).\r\n         * @todo If adding fails and implicitly creates directories, we do not clean up\r\n         *   the new empty directories.\r\n         */\r\n        addPathFast(path, inode) {\r\n            const itemNameMark = path.lastIndexOf('/');\r\n            const parentPath = itemNameMark === 0 ? \"/\" : path.substring(0, itemNameMark);\r\n            const itemName = path.substring(itemNameMark + 1);\r\n            // Try to add to its parent directory first.\r\n            let parent = this._index[parentPath];\r\n            if (parent === undefined) {\r\n                // Create parent.\r\n                parent = new DirInode();\r\n                this.addPathFast(parentPath, parent);\r\n            }\r\n            if (!parent.addItem(itemName, inode)) {\r\n                return false;\r\n            }\r\n            // If adding a directory, add to the index as well.\r\n            if (inode.isDir()) {\r\n                this._index[path] = inode;\r\n            }\r\n            return true;\r\n        }\r\n        /**\r\n         * Removes the given path. Can be a file or a directory.\r\n         * @return The removed item,\r\n         *   or null if it did not exist.\r\n         */\r\n        removePath(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Try to remove it from its parent directory first.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Remove myself from my parent.\r\n            const inode = parent.remItem(itemname);\r\n            if (inode === null) {\r\n                return null;\r\n            }\r\n            // If I'm a directory, remove myself from the index, and remove my children.\r\n            if (isDirInode(inode)) {\r\n                const children = inode.getListing();\r\n                for (const child of children) {\r\n                    this.removePath(path + '/' + child);\r\n                }\r\n                // Remove the directory from the index, unless it's the root.\r\n                if (path !== '/') {\r\n                    delete this._index[path];\r\n                }\r\n            }\r\n            return inode;\r\n        }\r\n        /**\r\n         * Retrieves the directory listing of the given path.\r\n         * @return An array of files in the given path, or 'null' if it does not exist.\r\n         */\r\n        ls(path) {\r\n            const item = this._index[path];\r\n            if (item === undefined) {\r\n                return null;\r\n            }\r\n            return item.getListing();\r\n        }\r\n        /**\r\n         * Returns the inode of the given item.\r\n         * @return Returns null if the item does not exist.\r\n         */\r\n        getInode(path) {\r\n            const splitPath = this._split_path(path);\r\n            const dirpath = splitPath[0];\r\n            const itemname = splitPath[1];\r\n            // Retrieve from its parent directory.\r\n            const parent = this._index[dirpath];\r\n            if (parent === undefined) {\r\n                return null;\r\n            }\r\n            // Root case\r\n            if (dirpath === path) {\r\n                return parent;\r\n            }\r\n            return parent.getItem(itemname);\r\n        }\r\n        /**\r\n         * Split into a (directory path, item name) pair\r\n         */\r\n        _split_path(p) {\r\n            const dirpath = paths.dirname(p);\r\n            const itemname = p.substr(dirpath.length + (dirpath === \"/\" ? 0 : 1));\r\n            return [dirpath, itemname];\r\n        }\r\n    }\r\n    \r\n\r\n    return FileIndex;\r\n});\ndefine('skylark-data-files/providers/http/http-provider',[\n    \"skylark-langx-async\",\n    \"skylark-langx-paths\",\n    '../../no-sync-file',\n    \"../base-provider\",\n    '../../error-codes',\n    '../../file-error',\n    '../../action-type',\n    '../../stats',\n    '../../file-type',\n    '../../utils',\n    './xhr',\n    './fetch',\n    '../../inodes/dir-inode',\n    '../../inodes/file-index',\n    '../../inodes/file-inode',\n\n], function (async,paths,NoSyncFile, BaseProvider, ErrorCodes, FileError,ActionType, Stats,FileType,  utils,xhr, fetch, DirInode,FileIndex,FileInode) {\n\n\n    'use strict';\n\n    const { copyingSlice }  = utils;\n\n    const { xhrIsAvailable, asyncDownloadFile, syncDownloadFile, getFileSizeAsync, getFileSizeSync }  = xhr;\n    const { fetchIsAvailable, fetchFileAsync, fetchFileSizeAsync }  = fetch;\n\n    const isFileInode = FileInode.isFileInode,\n          isDirInode = DirInode.isDirInode;\n    /**\n     * Try to convert the given buffer into a string, and pass it to the callback.\n     * Optimization that removes the needed try/catch into a helper function, as\n     * this is an uncommon case.\n     * @hidden\n     */\n    function tryToString(buff, encoding, cb) {\n        try {\n            cb(null, buff.toString(encoding));\n        }\n        catch (e) {\n            cb(e);\n        }\n    }\n    function syncNotAvailableError() {\n        throw new FileError(ErrorCodes.ENOTSUP, `Synchronous HTTP download methods are not available in this environment.`);\n    }\n    /**\n     * A simple filesystem backed by HTTP downloads. You must create a directory listing using the\n     * `make_http_index` tool provided by BrowserFS.\n     *\n     * If you install BrowserFS globally with `npm i -g browserfs`, you can generate a listing by\n     * running `make_http_index` in your terminal in the directory you would like to index:\n     *\n     * ```\n     * make_http_index > index.json\n     * ```\n     *\n     * Listings objects look like the following:\n     *\n     * ```json\n     * {\n     *   \"home\": {\n     *     \"jvilk\": {\n     *       \"someFile.txt\": null,\n     *       \"someDir\": {\n     *         // Empty directory\n     *       }\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * *This example has the folder `/home/jvilk` with subfile `someFile.txt` and subfolder `someDir`.*\n     */\n    class HttpProvider extends BaseProvider {\n        constructor(index, prefixUrl = '', preferXHR = false) {\n            super();\n            // prefix_url must end in a directory separator.\n            if (prefixUrl.length > 0 && prefixUrl.charAt(prefixUrl.length - 1) !== '/') {\n                prefixUrl = prefixUrl + '/';\n            }\n            this.prefixUrl = prefixUrl;\n            this._index = FileIndex.fromListing(index);\n            if (fetchIsAvailable && (!preferXHR || !xhrIsAvailable)) {\n                this._requestFileAsyncInternal = fetchFileAsync;\n                this._requestFileSizeAsyncInternal = fetchFileSizeAsync;\n            }\n            else {\n                this._requestFileAsyncInternal = asyncDownloadFile;\n                this._requestFileSizeAsyncInternal = getFileSizeAsync;\n            }\n            if (xhrIsAvailable) {\n                this._requestFileSyncInternal = syncDownloadFile;\n                this._requestFileSizeSyncInternal = getFileSizeSync;\n            }\n            else {\n                this._requestFileSyncInternal = syncNotAvailableError;\n                this._requestFileSizeSyncInternal = syncNotAvailableError;\n            }\n        }\n        /**\n         * Construct an HttpProvider file system backend with the given options.\n         */\n        static Create(opts, cb) {\n            if (opts.index === undefined) {\n                opts.index = `index.json`;\n            }\n            if (typeof (opts.index) === \"string\") {\n                asyncDownloadFile(opts.index, \"json\", (e, data) => {\n                    if (e) {\n                        cb(e);\n                    }\n                    else {\n                        cb(null, new HttpProvider(data, opts.baseUrl));\n                    }\n                });\n            }\n            else {\n                cb(null, new HttpProvider(opts.index, opts.baseUrl));\n            }\n        }\n        static isAvailable() {\n            return xhrIsAvailable || fetchIsAvailable;\n        }\n        empty() {\n            this._index.fileIterator(function (file) {\n                file.fileData = null;\n            });\n        }\n        getName() {\n            return HttpProvider.Name;\n        }\n        diskSpace(path, cb) {\n            // Read-only file system. We could calculate the total space, but that's not\n            // important right now.\n            cb(0, 0);\n        }\n        isReadOnly() {\n            return true;\n        }\n        supportsLinks() {\n            return false;\n        }\n        supportsProps() {\n            return false;\n        }\n        supportsSynch() {\n            // Synchronous operations are only available via the XHR interface for now.\n            return xhrIsAvailable;\n        }\n        /**\n         * Special HTTPFS function: Preload the given file into the index.\n         * @param [String] path\n         * @param [BrowserFS.Buffer] buffer\n         */\n        preloadFile(path, buffer) {\n            const inode = this._index.getInode(path);\n            if (isFileInode(inode)) {\n                if (inode === null) {\n                    throw FileError.ENOENT(path);\n                }\n                const stats = inode.getData();\n                stats.size = buffer.length;\n                stats.fileData = buffer;\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        stat(path, isLstat, cb) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    this._requestFileSizeAsync(path, function (e, size) {\n                        if (e) {\n                            return cb(e);\n                        }\n                        stats.size = size;\n                        cb(null, Stats.clone(stats));\n                    });\n                }\n                else {\n                    cb(null, Stats.clone(stats));\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n                cb(null, stats);\n            }\n            else {\n                cb(FileError.FileError(ErrorCodes.EINVAL, path));\n            }\n        }\n        statSync(path, isLstat) {\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            let stats;\n            if (isFileInode(inode)) {\n                stats = inode.getData();\n                // At this point, a non-opened file will still have default stats from the listing.\n                if (stats.size < 0) {\n                    stats.size = this._requestFileSizeSync(path);\n                }\n            }\n            else if (isDirInode(inode)) {\n                stats = inode.getStats();\n            }\n            else {\n                throw FileError.FileError(ErrorCodes.EINVAL, path);\n            }\n            return stats;\n        }\n        open(path, flags, mode, cb) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                return cb(new FileError(ErrorCodes.EPERM, path));\n            }\n            const self = this;\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                return cb(FileError.ENOENT(path));\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        return cb(FileError.EEXIST(path));\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), stats.fileData));\n                        }\n                        // @todo be lazier about actually requesting the file\n                        this._requestFileAsync(path, 'buffer', function (err, buffer) {\n                            if (err) {\n                                return cb(err);\n                            }\n                            // we don't initially have file sizes\n                            stats.size = buffer.length;\n                            stats.fileData = buffer;\n                            return cb(null, new NoSyncFile(self, path, flags, Stats.clone(stats), buffer));\n                        });\n                        break;\n                    default:\n                        return cb(new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.'));\n                }\n            }\n            else {\n                return cb(FileError.EISDIR(path));\n            }\n        }\n        openSync(path, flags, mode) {\n            // INVARIANT: You can't write to files on this file system.\n            if (flags.isWriteable()) {\n                throw new FileError(ErrorCodes.EPERM, path);\n            }\n            // Check if the path exists, and is a file.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            if (isFileInode(inode)) {\n                const stats = inode.getData();\n                switch (flags.pathExistsAction()) {\n                    case ActionType.THROW_EXCEPTION:\n                    case ActionType.TRUNCATE_FILE:\n                        throw FileError.EEXIST(path);\n                    case ActionType.NOP:\n                        // Use existing file contents.\n                        // XXX: Uh, this maintains the previously-used flag.\n                        if (stats.fileData) {\n                            return new NoSyncFile(this, path, flags, Stats.clone(stats), stats.fileData);\n                        }\n                        // @todo be lazier about actually requesting the file\n                        const buffer = this._requestFileSync(path, 'buffer');\n                        // we don't initially have file sizes\n                        stats.size = buffer.length;\n                        stats.fileData = buffer;\n                        return new NoSyncFile(this, path, flags, Stats.clone(stats), buffer);\n                    default:\n                        throw new FileError(ErrorCodes.EINVAL, 'Invalid FileMode object.');\n                }\n            }\n            else {\n                throw FileError.EISDIR(path);\n            }\n        }\n        readdir(path, cb) {\n            try {\n                cb(null, this.readdirSync(path));\n            }\n            catch (e) {\n                cb(e);\n            }\n        }\n        readdirSync(path) {\n            // Check if it exists.\n            const inode = this._index.getInode(path);\n            if (inode === null) {\n                throw FileError.ENOENT(path);\n            }\n            else if (isDirInode(inode)) {\n                return inode.getListing();\n            }\n            else {\n                throw FileError.ENOTDIR(path);\n            }\n        }\n        /**\n         * We have the entire file as a buffer; optimize readFile.\n         */\n        readFile(fname, encoding, flag, cb) {\n            // Wrap cb in file closing code.\n            const oldCb = cb;\n            // Get file.\n            this.open(fname, flag, 0x1a4, function (err, fd) {\n                if (err) {\n                    return cb(err);\n                }\n                cb = function (err, arg) {\n                    fd.close(function (err2) {\n                        if (!err) {\n                            err = err2;\n                        }\n                        return oldCb(err, arg);\n                    });\n                };\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    cb(err, copyingSlice(fdBuff));\n                }\n                else {\n                    tryToString(fdBuff, encoding, cb);\n                }\n            });\n        }\n        /**\n         * Specially-optimized readfile.\n         */\n        readFileSync(fname, encoding, flag) {\n            // Get file.\n            const fd = this.openSync(fname, flag, 0x1a4);\n            try {\n                const fdCast = fd;\n                const fdBuff = fdCast.getBuffer();\n                if (encoding === null) {\n                    return copyingSlice(fdBuff);\n                }\n                return fdBuff.toString(encoding);\n            }\n            finally {\n                fd.closeSync();\n            }\n        }\n        _getHTTPPath(filePath) {\n            if (filePath.charAt(0) === '/') {\n                filePath = filePath.slice(1);\n            }\n            return this.prefixUrl + filePath;\n        }\n        _requestFileAsync(p, type, cb) {\n            this._requestFileAsyncInternal(this._getHTTPPath(p), type, cb);\n        }\n        _requestFileSync(p, type) {\n            return this._requestFileSyncInternal(this._getHTTPPath(p), type);\n        }\n        /**\n         * Only requests the HEAD content, for the file size.\n         */\n        _requestFileSizeAsync(path, cb) {\n            this._requestFileSizeAsyncInternal(this._getHTTPPath(path), cb);\n        }\n        _requestFileSizeSync(path) {\n            return this._requestFileSizeSyncInternal(this._getHTTPPath(path));\n        }\n    }\n    HttpProvider.Name = \"http\";\n    HttpProvider.Options = {\n        index: {\n            type: [\"string\", \"object\"],\n            optional: true,\n            description: \"URL to a file index as a JSON file or the file index object itself, generated with the make_http_index script. Defaults to `index.json`.\"\n        },\n        baseUrl: {\n            type: \"string\",\n            optional: true,\n            description: \"Used as the URL prefix for fetched files. Default: Fetch files relative to the index.\"\n        },\n        preferXHR: {\n            type: \"boolean\",\n            optional: true,\n            description: \"Whether to prefer XmlHttpRequest or fetch for async operations if both are available. Default: false\"\n        }\n    };\n\n    return HttpProvider;\n});\ndefine('skylark-data-files/inodes/inode',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../stats',\r\n    '../file-type'\r\n], function (Buffer,Stats,FileType) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Generic inode definition that can easily be serialized.\r\n     */\r\n    class Inode {\r\n        constructor(id, size, mode, atime, mtime, ctime) {\r\n            this.id = id;\r\n            this.size = size;\r\n            this.mode = mode;\r\n            this.atime = atime;\r\n            this.mtime = mtime;\r\n            this.ctime = ctime;\r\n        }\r\n\r\n        /**\r\n         * Converts the buffer into an Inode.\r\n         */\r\n        static fromBuffer(buffer) {\r\n            if (buffer === undefined) {\r\n                throw new Error(\"NO\");\r\n            }\r\n            return new Inode(buffer.toString('ascii', 30), buffer.readUInt32LE(0), buffer.readUInt16LE(4), buffer.readDoubleLE(6), buffer.readDoubleLE(14), buffer.readDoubleLE(22));\r\n        }\r\n\r\n        /**\r\n         * Handy function that converts the Inode to a Node Stats object.\r\n         */\r\n        toStats() {\r\n            return new Stats((this.mode & 0xF000) === FileType.DIRECTORY ? FileType.DIRECTORY : FileType.FILE, this.size, this.mode, this.atime, this.mtime, this.ctime);\r\n        }\r\n\r\n        /**\r\n         * Get the size of this Inode, in bytes.\r\n         */\r\n        getSize() {\r\n            // ASSUMPTION: ID is ASCII (1 byte per char).\r\n            return 30 + this.id.length;\r\n        }\r\n\r\n        /**\r\n         * Writes the inode into the start of the buffer.\r\n         */\r\n        toBuffer(buff = Buffer.alloc(this.getSize())) {\r\n            buff.writeUInt32LE(this.size, 0);\r\n            buff.writeUInt16LE(this.mode, 4);\r\n            buff.writeDoubleLE(this.atime, 6);\r\n            buff.writeDoubleLE(this.mtime, 14);\r\n            buff.writeDoubleLE(this.ctime, 22);\r\n            buff.write(this.id, 30, this.id.length, 'ascii');\r\n            return buff;\r\n        }\r\n        \r\n        /**\r\n         * Updates the Inode using information from the stats object. Used by file\r\n         * systems at sync time, e.g.:\r\n         * - Program opens file and gets a File object.\r\n         * - Program mutates file. File object is responsible for maintaining\r\n         *   metadata changes locally -- typically in a Stats object.\r\n         * - Program closes file. File object's metadata changes are synced with the\r\n         *   file system.\r\n         * @return True if any changes have occurred.\r\n         */\r\n        update(stats) {\r\n            let hasChanged = false;\r\n            if (this.size !== stats.size) {\r\n                this.size = stats.size;\r\n                hasChanged = true;\r\n            }\r\n            if (this.mode !== stats.mode) {\r\n                this.mode = stats.mode;\r\n                hasChanged = true;\r\n            }\r\n            const atimeMs = stats.atime.getTime();\r\n            if (this.atime !== atimeMs) {\r\n                this.atime = atimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const mtimeMs = stats.mtime.getTime();\r\n            if (this.mtime !== mtimeMs) {\r\n                this.mtime = mtimeMs;\r\n                hasChanged = true;\r\n            }\r\n            const ctimeMs = stats.ctime.getTime();\r\n            if (this.ctime !== ctimeMs) {\r\n                this.ctime = ctimeMs;\r\n                hasChanged = true;\r\n            }\r\n            return hasChanged;\r\n        }\r\n        // XXX: Copied from Stats. Should reconcile these two into something more\r\n        //      compact.\r\n        /**\r\n         * @return [Boolean] True if this item is a file.\r\n         */\r\n        isFile() {\r\n            return (this.mode & 0xF000) === FileType.FILE;\r\n        }\r\n        /**\r\n         * @return [Boolean] True if this item is a directory.\r\n         */\r\n        isDirectory() {\r\n            return (this.mode & 0xF000) === FileType.DIRECTORY;\r\n        }\r\n    }\r\n\r\n\r\n    return Inode;\r\n});\ndefine('skylark-data-files/providers/async-key-value-file',[\r\n    \"../files\",\r\n    '../preload-file'\r\n], function (files, PreloadFile) {\r\n    'use strict';\r\n\r\n    class AsyncKeyValueFile extends PreloadFile {\r\n        constructor(_fs, _path, _flag, _stat, contents) {\r\n            super(_fs, _path, _flag, _stat, contents);\r\n        }\r\n        sync(cb) {\r\n            if (this.isDirty()) {\r\n                this._fs._sync(this.getPath(), this.getBuffer(), this.getStats(), (e) => {\r\n                    if (!e) {\r\n                        this.resetDirty();\r\n                    }\r\n                    cb(e);\r\n                });\r\n            }\r\n            else {\r\n                cb();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return files.providers.AsyncKeyValueFile = AsyncKeyValueFile;\r\n    \r\n});\ndefine('skylark-data-files/providers/async-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"skylark-data-collections/lru-cache\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"../file-type\",\r\n    '../utils',\r\n    \"../inodes/inode\",\r\n    \"./base-provider\",\r\n    \"./async-key-value-file\"\r\n ], function (GenerateRandomID,Buffer,paths,LRUCache, files, ErrorCodes, FileError, FileType, utils, Inode,BaseProvider,AsyncKeyValueFile) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    const ROOT_NODE_ID = \"/\";\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    let emptyDirNode = null;\r\n\r\n    /**\r\n     * Returns an empty directory node.\r\n     * @hidden\r\n     */\r\n    function getEmptyDirNode() {\r\n        if (emptyDirNode) {\r\n            return emptyDirNode;\r\n        }\r\n        return emptyDirNode = Buffer.from(\"{}\");\r\n    }\r\n\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it triggers the callback\r\n     * with 'e' and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noError(e, cb) {\r\n        if (e) {\r\n            cb(e);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Helper function. Checks if 'e' is defined. If so, it aborts the transaction,\r\n     * triggers the callback with 'e', and returns false. Otherwise, returns true.\r\n     * @hidden\r\n     */\r\n    function noErrorTx(e, tx, cb) {\r\n        if (e) {\r\n            tx.abort(() => {\r\n                cb(e);\r\n            });\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * An \"Asynchronous key-value file system\". Stores data to/retrieves data from\r\n     * an underlying asynchronous key-value store.\r\n     */\r\n    class AsyncKeyValueProvider extends BaseProvider {\r\n        constructor(cacheSize) {\r\n            super();\r\n            this._cache = null;\r\n            if (cacheSize > 0) {\r\n                this._cache = new LRUCache(cacheSize);\r\n            }\r\n        }\r\n\r\n        static isAvailable() { return true; }\r\n        /**\r\n         * Initializes the file system. Typically called by subclasses' async\r\n         * constructors.\r\n         */\r\n        init(store, cb) {\r\n            this.store = store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory(cb);\r\n        }\r\n\r\n        getName() { return this.store.name(); }\r\n        \r\n        isReadOnly() { return false; }\r\n        \r\n        supportsSymlinks() { return false; }\r\n        \r\n        supportsProps() { return false; }\r\n        \r\n        supportsSynch() { return false; }\r\n        \r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty(cb) {\r\n            if (this._cache) {\r\n                this._cache.removeAll();\r\n            }\r\n            this.store.clear((e) => {\r\n                if (noError(e, cb)) {\r\n                    // INVARIANT: Root always exists.\r\n                    this.makeRootDirectory(cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        rename(oldPath, newPath, cb) {\r\n            // TODO: Make rename compatible with the cache.\r\n            if (this._cache) {\r\n                // Clear and disable cache during renaming process.\r\n                const c = this._cache;\r\n                this._cache = null;\r\n                c.removeAll();\r\n                const oldCb = cb;\r\n                cb = (e) => {\r\n                    // Restore empty cache.\r\n                    this._cache = c;\r\n                    oldCb(e);\r\n                };\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            const oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath);\r\n            const newParent = paths.dirname(newPath), newName = paths.basename(newPath);\r\n            const inodes = {};\r\n            const lists = {};\r\n            let errorOccurred = false;\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                return cb(new FileError(ErrorCodes.EBUSY, oldParent));\r\n            }\r\n            /**\r\n             * Responsible for Phase 2 of the rename operation: Modifying and\r\n             * committing the directory listings. Called once we have successfully\r\n             * retrieved both the old and new parent's inodes and listings.\r\n             */\r\n            const theOleSwitcharoo = () => {\r\n                // Sanity check: Ensure both paths are present, and no error has occurred.\r\n                if (errorOccurred || !lists.hasOwnProperty(oldParent) || !lists.hasOwnProperty(newParent)) {\r\n                    return;\r\n                }\r\n                const oldParentList = lists[oldParent], oldParentINode = inodes[oldParent], newParentList = lists[newParent], newParentINode = inodes[newParent];\r\n                // Delete file from old parent.\r\n                if (!oldParentList[oldName]) {\r\n                    cb(FileError.ENOENT(oldPath));\r\n                }\r\n                else {\r\n                    const fileId = oldParentList[oldName];\r\n                    delete oldParentList[oldName];\r\n                    // Finishes off the renaming process by adding the file to the new\r\n                    // parent.\r\n                    const completeRename = () => {\r\n                        newParentList[newName] = fileId;\r\n                        // Commit old parent's list.\r\n                        tx.put(oldParentINode.id, Buffer.from(JSON.stringify(oldParentList)), true, (e) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (oldParent === newParent) {\r\n                                    // DONE!\r\n                                    tx.commit(cb);\r\n                                }\r\n                                else {\r\n                                    // Commit new parent's list.\r\n                                    tx.put(newParentINode.id, Buffer.from(JSON.stringify(newParentList)), true, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.commit(cb);\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    };\r\n                    if (newParentList[newName]) {\r\n                        // 'newPath' already exists. Check if it's a file or a directory, and\r\n                        // act accordingly.\r\n                        this.getINode(tx, newPath, newParentList[newName], (e, inode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (inode.isFile()) {\r\n                                    // Delete the file and continue.\r\n                                    tx.del(inode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            tx.del(newParentList[newName], (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    completeRename();\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Can't overwrite a directory using rename.\r\n                                    tx.abort((e) => {\r\n                                        cb(FileError.EPERM(newPath));\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        completeRename();\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Grabs a path's inode and directory listing, and shoves it into the\r\n             * inodes and lists hashes.\r\n             */\r\n            const processInodeAndListings = (p) => {\r\n                this.findINodeAndDirListing(tx, p, (e, node, dirList) => {\r\n                    if (e) {\r\n                        if (!errorOccurred) {\r\n                            errorOccurred = true;\r\n                            tx.abort(() => {\r\n                                cb(e);\r\n                            });\r\n                        }\r\n                        // If error has occurred already, just stop here.\r\n                    }\r\n                    else {\r\n                        inodes[p] = node;\r\n                        lists[p] = dirList;\r\n                        theOleSwitcharoo();\r\n                    }\r\n                });\r\n            };\r\n            processInodeAndListings(oldParent);\r\n            if (oldParent !== newParent) {\r\n                processInodeAndListings(newParent);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, inode.toStats());\r\n                }\r\n            });\r\n        }\r\n        createFile(p, flag, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer();\r\n            this.commitNewFile(tx, p, FileType.FILE, mode, data, (e, newFile) => {\r\n                if (noError(e, cb)) {\r\n                    cb(null, new AsyncKeyValueFile(this, p, flag, newFile.toStats(), data));\r\n                }\r\n            });\r\n        }\r\n\r\n        openFile(p, flag, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            // Step 1: Grab the file's inode.\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    // Step 2: Grab the file's data.\r\n                    tx.get(inode.id, (e, data) => {\r\n                        if (noError(e, cb)) {\r\n                            if (data === undefined) {\r\n                                cb(FileError.ENOENT(p));\r\n                            }\r\n                            else {\r\n                                cb(null, new AsyncKeyValueFile(this, p, flag, inode.toStats(), data));\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        unlink(p, cb) {\r\n            this.removeEntry(p, false, cb);\r\n        }\r\n        \r\n        rmdir(p, cb) {\r\n            // Check first if directory is empty.\r\n            this.readdir(p, (err, files) => {\r\n                if (err) {\r\n                    cb(err);\r\n                }\r\n                else if (files.length > 0) {\r\n                    cb(FileError.ENOTEMPTY(p));\r\n                }\r\n                else {\r\n                    this.removeEntry(p, true, cb);\r\n                }\r\n            });\r\n        }\r\n        \r\n        mkdir(p, mode, cb) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data, cb);\r\n        }\r\n        \r\n        readdir(p, cb) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, dirListing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, Object.keys(dirListing));\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        \r\n        _sync(p, data, stats, cb) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            // Step 1: Get the file node's ID.\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, fileInodeId) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    // Step 2: Get the file inode.\r\n                    this.getINode(tx, p, fileInodeId, (e, fileInode) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            const inodeChanged = fileInode.update(stats);\r\n                            // Step 3: Sync the data.\r\n                            tx.put(fileInode.id, data, true, (e) => {\r\n                                if (noErrorTx(e, tx, cb)) {\r\n                                    // Step 4: Sync the metadata (if it changed)!\r\n                                    if (inodeChanged) {\r\n                                        tx.put(fileInodeId, fileInode.toBuffer(), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                tx.commit(cb);\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else {\r\n                                        // No need to sync metadata; return.\r\n                                        tx.commit(cb);\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory(cb) {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            tx.get(ROOT_NODE_ID, (e, data) => {\r\n                if (e || data === undefined) {\r\n                    // Create new inode.\r\n                    const currTime = (new Date()).getTime(), \r\n                    // Mode 0666\r\n                    dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                    // If the root doesn't exist, the first random ID shouldn't exist,\r\n                    // either.\r\n                    tx.put(dirInode.id, getEmptyDirNode(), false, (e) => {\r\n                        if (noErrorTx(e, tx, cb)) {\r\n                            tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false, (e) => {\r\n                                if (e) {\r\n                                    tx.abort(() => { cb(e); });\r\n                                }\r\n                                else {\r\n                                    tx.commit(cb);\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // We're good.\r\n                    tx.commit(cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @param cb Passed an error or the ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename, cb) {\r\n            if (this._cache) {\r\n                const id = this._cache.get(paths.join(parent, filename));\r\n                if (id) {\r\n                    return cb(null, id);\r\n                }\r\n            }\r\n            const handleDirectoryListings = (e, inode, dirList) => {\r\n                if (e) {\r\n                    cb(e);\r\n                }\r\n                else if (dirList[filename]) {\r\n                    const id = dirList[filename];\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), id);\r\n                    }\r\n                    cb(null, id);\r\n                }\r\n                else {\r\n                    cb(FileError.ENOENT(paths.resolve(parent, filename)));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    if (this._cache) {\r\n                        this._cache.set(paths.join(parent, filename), ROOT_NODE_ID);\r\n                    }\r\n                    cb(null, ROOT_NODE_ID);\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root node.\r\n                    this.getINode(tx, parent, ROOT_NODE_ID, (e, inode) => {\r\n                        if (noError(e, cb)) {\r\n                            this.getDirListing(tx, parent, inode, (e, dirList) => {\r\n                                // handle_directory_listings will handle e for us.\r\n                                handleDirectoryListings(e, inode, dirList);\r\n                            });\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // Get the parent directory's INode, and find the file in its directory\r\n                // listing.\r\n                this.findINodeAndDirListing(tx, parent, handleDirectoryListings);\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @param cb Passed an error or the Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p, cb) {\r\n            this._findINode(tx, paths.dirname(p), paths.basename(p), (e, id) => {\r\n                if (noError(e, cb)) {\r\n                    this.getINode(tx, p, id, cb);\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         * @param cb Passed an error or the inode under the given id.\r\n         */\r\n        getINode(tx, p, id, cb) {\r\n            tx.get(id, (e, data) => {\r\n                if (noError(e, cb)) {\r\n                    if (data === undefined) {\r\n                        cb(FileError.ENOENT(p));\r\n                    }\r\n                    else {\r\n                        cb(null, Inode.fromBuffer(data));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode, cb) {\r\n            if (!inode.isDirectory()) {\r\n                cb(FileError.ENOTDIR(p));\r\n            }\r\n            else {\r\n                tx.get(inode.id, (e, data) => {\r\n                    if (noError(e, cb)) {\r\n                        try {\r\n                            cb(null, JSON.parse(data.toString()));\r\n                        }\r\n                        catch (e) {\r\n                            // Occurs when data is undefined, or corresponds to something other\r\n                            // than a directory listing. The latter should never occur unless\r\n                            // the file system is corrupted.\r\n                            cb(FileError.ENOENT(p));\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * Given a path to a directory, retrieves the corresponding INode and\r\n         * directory listing.\r\n         */\r\n        findINodeAndDirListing(tx, p, cb) {\r\n            this.findINode(tx, p, (e, inode) => {\r\n                if (noError(e, cb)) {\r\n                    this.getDirListing(tx, p, inode, (e, listing) => {\r\n                        if (noError(e, cb)) {\r\n                            cb(null, inode, listing);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Adds a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @param cb Passed an error or the GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data, cb) {\r\n            let retries = 0, currId;\r\n            const reroll = () => {\r\n                if (++retries === 5) {\r\n                    // Max retries hit. Return with an error.\r\n                    cb(new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.'));\r\n                }\r\n                else {\r\n                    // Try again.\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false, (e, committed) => {\r\n                        if (e || !committed) {\r\n                            reroll();\r\n                        }\r\n                        else {\r\n                            // Successfully stored under 'currId'.\r\n                            cb(null, currId);\r\n                        }\r\n                    });\r\n                }\r\n            };\r\n            reroll();\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @param cb Passed an error or the Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data, cb) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                return cb(FileError.EEXIST(p));\r\n            }\r\n            // Let's build a pyramid of code!\r\n            // Step 1: Get the parent directory's inode and directory listing\r\n            this.findINodeAndDirListing(tx, parentDir, (e, parentNode, dirListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (dirListing[fname]) {\r\n                        // File already exists.\r\n                        tx.abort(() => {\r\n                            cb(FileError.EEXIST(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Step 2: Commit data to store.\r\n                        this.addNewNode(tx, data, (e, dataId) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                // Step 3: Commit the file's inode to the store.\r\n                                const fileInode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                                this.addNewNode(tx, fileInode.toBuffer(), (e, fileInodeId) => {\r\n                                    if (noErrorTx(e, tx, cb)) {\r\n                                        // Step 4: Update parent directory's listing.\r\n                                        dirListing[fname] = fileInodeId;\r\n                                        tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true, (e) => {\r\n                                            if (noErrorTx(e, tx, cb)) {\r\n                                                // Step 5: Commit and return the new inode.\r\n                                                tx.commit((e) => {\r\n                                                    if (noErrorTx(e, tx, cb)) {\r\n                                                        cb(null, fileInode);\r\n                                                    }\r\n                                                });\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir, cb) {\r\n            // Eagerly delete from cache (harmless even if removal fails)\r\n            if (this._cache) {\r\n                this._cache.remove(p);\r\n            }\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), fileName = paths.basename(p);\r\n            // Step 1: Get parent directory's node and directory listing.\r\n            this.findINodeAndDirListing(tx, parent, (e, parentNode, parentListing) => {\r\n                if (noErrorTx(e, tx, cb)) {\r\n                    if (!parentListing[fileName]) {\r\n                        tx.abort(() => {\r\n                            cb(FileError.ENOENT(p));\r\n                        });\r\n                    }\r\n                    else {\r\n                        // Remove from directory listing of parent.\r\n                        const fileNodeId = parentListing[fileName];\r\n                        delete parentListing[fileName];\r\n                        // Step 2: Get file inode.\r\n                        this.getINode(tx, p, fileNodeId, (e, fileNode) => {\r\n                            if (noErrorTx(e, tx, cb)) {\r\n                                if (!isDir && fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.EISDIR(p));\r\n                                    });\r\n                                }\r\n                                else if (isDir && !fileNode.isDirectory()) {\r\n                                    tx.abort(() => {\r\n                                        cb(FileError.ENOTDIR(p));\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    // Step 3: Delete data.\r\n                                    tx.del(fileNode.id, (e) => {\r\n                                        if (noErrorTx(e, tx, cb)) {\r\n                                            // Step 4: Delete node.\r\n                                            tx.del(fileNodeId, (e) => {\r\n                                                if (noErrorTx(e, tx, cb)) {\r\n                                                    // Step 5: Update directory listing.\r\n                                                    tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true, (e) => {\r\n                                                        if (noErrorTx(e, tx, cb)) {\r\n                                                            tx.commit(cb);\r\n                                                        }\r\n                                                    });\r\n                                                }\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    return  files.providers.AsyncKeyValueProvider = AsyncKeyValueProvider;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-ro-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils'\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            this.tx = tx;\r\n            this.store = store;\r\n        }\r\n        get(key, cb) {\r\n            try {\r\n                const r = this.store.get(key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    // IDB returns the value 'undefined' when you try to get keys that\r\n                    // don't exist. The caller expects this behavior.\r\n                    const result = event.target.result;\r\n                    if (result === undefined) {\r\n                        cb(null, result);\r\n                    }\r\n                    else {\r\n                        // IDB data is stored as an ArrayBuffer\r\n                        cb(null, arrayBuffer2Buffer(result));\r\n                    }\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    return IndexedDBROTransaction;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-rw-transaction',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    '../../utils',\r\n    \"./indexed-db-ro-transaction\"\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  utils,IndexedDBROTransaction) {\r\n    'use strict';\r\n\r\n\r\n    const { arrayBuffer2Buffer, buffer2ArrayBuffer }  = utils;\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    class IndexedDBRWTransaction extends IndexedDBROTransaction {\r\n        constructor(tx, store) {\r\n            super(tx, store);\r\n        }\r\n        put(key, data, overwrite, cb) {\r\n            try {\r\n                const arraybuffer = buffer2ArrayBuffer(data);\r\n                let r;\r\n                // Note: 'add' will never overwrite an existing key.\r\n                r = overwrite ? this.store.put(arraybuffer, key) : this.store.add(arraybuffer, key);\r\n                // XXX: NEED TO RETURN FALSE WHEN ADD HAS A KEY CONFLICT. NO ERROR.\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb(null, true);\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        del(key, cb) {\r\n            try {\r\n                // NOTE: IE8 has a bug with identifiers named 'delete' unless used as a string\r\n                // like this.\r\n                // http://stackoverflow.com/a/26479152\r\n                const r = this.store['delete'](key);\r\n                r.onerror = onErrorHandler(cb);\r\n                r.onsuccess = (event) => {\r\n                    cb();\r\n                };\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        commit(cb) {\r\n            // Return to the event loop to commit the transaction.\r\n            setTimeout(cb, 0);\r\n        }\r\n        abort(cb) {\r\n            let _e = null;\r\n            try {\r\n                this.tx.abort();\r\n            }\r\n            catch (e) {\r\n                _e = convertError(e);\r\n            }\r\n            finally {\r\n                cb(_e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBRWTransaction;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-store',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * Converts a DOMException or a DOMError from an IndexedDB event into a\r\n     * standardized BrowserFS API error.\r\n     * @hidden\r\n     */\r\n    function convertError(e, message = e.toString()) {\r\n        switch (e.name) {\r\n            case \"NotFoundError\":\r\n                return new FileError(ErrorCodes.ENOENT, message);\r\n            case \"QuotaExceededError\":\r\n                return new FileError(ErrorCodes.ENOSPC, message);\r\n            default:\r\n                // The rest do not seem to map cleanly to standard error codes.\r\n                return new FileError(ErrorCodes.EIO, message);\r\n        }\r\n    }\r\n    /**\r\n     * Produces a new onerror handler for IDB. Our errors are always fatal, so we\r\n     * handle them generically: Call the user-supplied callback with a translated\r\n     * version of the error, and let the error bubble up.\r\n     * @hidden\r\n     */\r\n    function onErrorHandler(cb, code = ErrorCodes.EIO, message = null) {\r\n        return function (e) {\r\n            // Prevent the error from canceling the transaction.\r\n            e.preventDefault();\r\n            cb(new FileError(code, message !== null ? message : undefined));\r\n        };\r\n    }\r\n\r\n    class IndexedDBStore {\r\n        constructor(db, storeName) {\r\n            this.db = db;\r\n            this.storeName = storeName;\r\n        }\r\n        static Create(storeName, cb) {\r\n            const openReq = indexedDB.open(storeName, 1);\r\n            openReq.onupgradeneeded = (event) => {\r\n                const db = event.target.result;\r\n                // Huh. This should never happen; we're at version 1. Why does another\r\n                // database exist?\r\n                if (db.objectStoreNames.contains(storeName)) {\r\n                    db.deleteObjectStore(storeName);\r\n                }\r\n                db.createObjectStore(storeName);\r\n            };\r\n            openReq.onsuccess = (event) => {\r\n                cb(null, new IndexedDBStore(event.target.result, storeName));\r\n            };\r\n            openReq.onerror = onErrorHandler(cb, ErrorCodes.EACCES);\r\n        }\r\n        name() {\r\n            return IndexedDBProvider.Name + \" - \" + this.storeName;\r\n        }\r\n        clear(cb) {\r\n            try {\r\n                const tx = this.db.transaction(this.storeName, 'readwrite'), objectStore = tx.objectStore(this.storeName), r = objectStore.clear();\r\n                r.onsuccess = (event) => {\r\n                    // Use setTimeout to commit transaction.\r\n                    setTimeout(cb, 0);\r\n                };\r\n                r.onerror = onErrorHandler(cb);\r\n            }\r\n            catch (e) {\r\n                cb(convertError(e));\r\n            }\r\n        }\r\n        beginTransaction(type = 'readonly') {\r\n            const tx = this.db.transaction(this.storeName, type), objectStore = tx.objectStore(this.storeName);\r\n            if (type === 'readwrite') {\r\n                return new IndexedDBRWTransaction(tx, objectStore);\r\n            }\r\n            else if (type === 'readonly') {\r\n                return new IndexedDBROTransaction(tx, objectStore);\r\n            }\r\n            else {\r\n                throw new FileError(ErrorCodes.EINVAL, 'Invalid transaction type.');\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return IndexedDBStore;\r\n});\ndefine('skylark-data-files/providers/indexeddb/indexed-db-provider',[\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    '../async-key-value-provider',\r\n    \"../registry\",\r\n    '../../utils',\r\n    \"./indexed-db-store\",\r\n    \"./indexed-db-ro-transaction\",\r\n    \"./indexed-db-rw-transaction\"\r\n], function (FileError,ErrorCodes, AsyncKeyValueProvider,  registry,utils,IndexedDBStore,IndexedDBROTransaction,IndexedDBRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * Get the indexedDB constructor for the current browser.\r\n     * @hidden\r\n     */\r\n    const indexedDB = window.indexedDB ||\r\n        window.mozIndexedDB ||\r\n        window.webkitIndexedDB ||\r\n        window.msIndexedDB;\r\n    /**\r\n     * A file system that uses the IndexedDB key value file system.\r\n     */\r\n    class IndexedDBProvider extends AsyncKeyValueProvider {\r\n        constructor(cacheSize) {\r\n            super(cacheSize);\r\n        }\r\n        /**\r\n         * Constructs an IndexedDB file system with the given options.\r\n         */\r\n        static Create(opts = {}, cb) {\r\n            IndexedDBStore.Create(opts.storeName ? opts.storeName : 'browserfs', (e, store) => {\r\n                if (store) {\r\n                    const idbfs = new IndexedDBProvider(typeof (opts.cacheSize) === 'number' ? opts.cacheSize : 100);\r\n                    idbfs.init(store, (e) => {\r\n                        if (e) {\r\n                            cb(e);\r\n                        }\r\n                        else {\r\n                            cb(null, idbfs);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    cb(e);\r\n                }\r\n            });\r\n        }\r\n        static isAvailable() {\r\n            // In Safari's private browsing mode, indexedDB.open returns NULL.\r\n            // In Firefox, it throws an exception.\r\n            // In Chrome, it \"just works\", and clears the database when you leave the page.\r\n            // Untested: Opera, IE.\r\n            try {\r\n                return typeof indexedDB !== 'undefined' && null !== indexedDB.open(\"__browserfs_test__\");\r\n            }\r\n            catch (e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    IndexedDBProvider.Name = \"IndexedDB\";\r\n    IndexedDBProvider.Options = {\r\n        storeName: {\r\n            type: \"string\",\r\n            optional: true,\r\n            description: \"The name of this file system. You can have multiple IndexedDB file systems operating at once, but each must have a different name.\"\r\n        },\r\n        cacheSize: {\r\n            type: \"number\",\r\n            optional: true,\r\n            description: \"The size of the inode cache. Defaults to 100. A size of 0 or below disables caching.\"\r\n        }\r\n    };\r\n\r\n\r\n    IndexedDBProvider.IndexedDBROTransaction = IndexedDBROTransaction;\r\n    IndexedDBProvider.IndexedDBRWTransaction = IndexedDBRWTransaction;\r\n    IndexedDBProvider.IndexedDBStore = IndexedDBStore;\r\n\r\n    registry.add(\"indexedDB\",IndexedDBProvider);\r\n\r\n    return IndexedDBProvider;\r\n});\ndefine('skylark-data-files/providers/synchronous-provider',[\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    '../action-type',\r\n    '../file-flag',\r\n    '../utils',\r\n    \"./base-provider\"\r\n], function (Buffer,paths, files,ErrorCodes, FileError, ActionType, FileFlag, utils,BaseProvider) {\r\n    'use strict';\r\n\r\n    const { fail } = utils;\r\n\r\n    /**\r\n     * Implements the asynchronous API in terms of the synchronous API.\r\n     * @class SynchronousProvider\r\n     */\r\n    class SynchronousProvider extends BaseProvider {\r\n        supportsSynch() {\r\n            return true;\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            try {\r\n                this.renameSync(oldPath, newPath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            try {\r\n                cb(null, this.statSync(p, isLstat));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        open(p, flags, mode, cb) {\r\n            try {\r\n                cb(null, this.openSync(p, flags, mode));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            try {\r\n                this.unlinkSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            try {\r\n                this.rmdirSync(p);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            try {\r\n                this.mkdirSync(p, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            try {\r\n                cb(null, this.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            try {\r\n                this.chmodSync(p, isLchmod, mode);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            try {\r\n                this.chownSync(p, isLchown, uid, gid);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            try {\r\n                this.utimesSync(p, atime, mtime);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            try {\r\n                this.linkSync(srcpath, dstpath);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            try {\r\n                this.symlinkSync(srcpath, dstpath, type);\r\n                cb();\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        readlink(p, cb) {\r\n            try {\r\n                cb(null, this.readlinkSync(p));\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SynchronousProvider =  SynchronousProvider;\r\n});\ndefine('skylark-data-files/providers/sync-key-value-provider',[\r\n    \"skylark-langx-strings/generate-uuid\",\r\n    \"skylark-langx-binary/buffer\",\r\n    \"skylark-langx-paths\",\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error',\r\n    \"./base-provider\",\r\n    \"./synchronous-provider\",\r\n    '../utils'\r\n], function (GenerateRandomID, Buffer,paths,files,ErrorCodes, FileError,BaseProvider, SynchronousProvider,  utils) {\r\n    'use strict';\r\n\r\n    const { emptyBuffer } = utils;\r\n\r\n\r\n    /**\r\n     * A \"Synchronous key-value file system\". Stores data to/retrieves data from an\r\n     * underlying key-value store.\r\n     *\r\n     * We use a unique ID for each node in the file system. The root node has a\r\n     * fixed ID.\r\n     * @todo Introduce Node ID caching.\r\n     * @todo Check modes.\r\n     */\r\n    class SyncKeyValueProvider extends SynchronousProvider {\r\n        static isAvailable() { return true; }\r\n        constructor(options) {\r\n            super();\r\n            this.store = options.store;\r\n            // INVARIANT: Ensure that the root exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        getName() { return this.store.name(); }\r\n        isReadOnly() { return false; }\r\n        supportsSymlinks() { return false; }\r\n        supportsProps() { return false; }\r\n        supportsSynch() { return true; }\r\n        /**\r\n         * Delete all contents stored in the file system.\r\n         */\r\n        empty() {\r\n            this.store.clear();\r\n            // INVARIANT: Root always exists.\r\n            this.makeRootDirectory();\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            const tx = this.store.beginTransaction('readwrite'), oldParent = paths.dirname(oldPath), oldName = paths.basename(oldPath), newParent = paths.dirname(newPath), newName = paths.basename(newPath), \r\n            // Remove oldPath from parent's directory listing.\r\n            oldDirNode = this.findINode(tx, oldParent), oldDirList = this.getDirListing(tx, oldParent, oldDirNode);\r\n            if (!oldDirList[oldName]) {\r\n                throw FileError.ENOENT(oldPath);\r\n            }\r\n            const nodeId = oldDirList[oldName];\r\n            delete oldDirList[oldName];\r\n            // Invariant: Can't move a folder inside itself.\r\n            // This funny little hack ensures that the check passes only if oldPath\r\n            // is a subpath of newParent. We append '/' to avoid matching folders that\r\n            // are a substring of the bottom-most folder in the path.\r\n            if ((newParent + '/').indexOf(oldPath + '/') === 0) {\r\n                throw new FileError(ErrorCodes.EBUSY, oldParent);\r\n            }\r\n            // Add newPath to parent's directory listing.\r\n            let newDirNode, newDirList;\r\n            if (newParent === oldParent) {\r\n                // Prevent us from re-grabbing the same directory listing, which still\r\n                // contains oldName.\r\n                newDirNode = oldDirNode;\r\n                newDirList = oldDirList;\r\n            }\r\n            else {\r\n                newDirNode = this.findINode(tx, newParent);\r\n                newDirList = this.getDirListing(tx, newParent, newDirNode);\r\n            }\r\n            if (newDirList[newName]) {\r\n                // If it's a file, delete it.\r\n                const newNameNode = this.getINode(tx, newPath, newDirList[newName]);\r\n                if (newNameNode.isFile()) {\r\n                    try {\r\n                        tx.del(newNameNode.id);\r\n                        tx.del(newDirList[newName]);\r\n                    }\r\n                    catch (e) {\r\n                        tx.abort();\r\n                        throw e;\r\n                    }\r\n                }\r\n                else {\r\n                    // If it's a directory, throw a permissions error.\r\n                    throw FileError.EPERM(newPath);\r\n                }\r\n            }\r\n            newDirList[newName] = nodeId;\r\n            // Commit the two changed directory listings.\r\n            try {\r\n                tx.put(oldDirNode.id, Buffer.from(JSON.stringify(oldDirList)), true);\r\n                tx.put(newDirNode.id, Buffer.from(JSON.stringify(newDirList)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        statSync(p, isLstat) {\r\n            // Get the inode to the item, convert it into a Stats object.\r\n            return this.findINode(this.store.beginTransaction('readonly'), p).toStats();\r\n        }\r\n        createFileSync(p, flag, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = emptyBuffer(), newFile = this.commitNewFile(tx, p, FileType.FILE, mode, data);\r\n            // Open the file.\r\n            return new SyncKeyValueFile(this, p, flag, newFile.toStats(), data);\r\n        }\r\n        openFileSync(p, flag) {\r\n            const tx = this.store.beginTransaction('readonly'), node = this.findINode(tx, p), data = tx.get(node.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return new SyncKeyValueFile(this, p, flag, node.toStats(), data);\r\n        }\r\n        unlinkSync(p) {\r\n            this.removeEntry(p, false);\r\n        }\r\n        rmdirSync(p) {\r\n            // Check first if directory is empty.\r\n            if (this.readdirSync(p).length > 0) {\r\n                throw FileError.ENOTEMPTY(p);\r\n            }\r\n            else {\r\n                this.removeEntry(p, true);\r\n            }\r\n        }\r\n        mkdirSync(p, mode) {\r\n            const tx = this.store.beginTransaction('readwrite'), data = Buffer.from('{}');\r\n            this.commitNewFile(tx, p, FileType.DIRECTORY, mode, data);\r\n        }\r\n        readdirSync(p) {\r\n            const tx = this.store.beginTransaction('readonly');\r\n            return Object.keys(this.getDirListing(tx, p, this.findINode(tx, p)));\r\n        }\r\n        _syncSync(p, data, stats) {\r\n            // @todo Ensure mtime updates properly, and use that to determine if a data\r\n            //       update is required.\r\n            const tx = this.store.beginTransaction('readwrite'), \r\n            // We use the _findInode helper because we actually need the INode id.\r\n            fileInodeId = this._findINode(tx, paths.dirname(p), paths.basename(p)), fileInode = this.getINode(tx, p, fileInodeId), inodeChanged = fileInode.update(stats);\r\n            try {\r\n                // Sync data.\r\n                tx.put(fileInode.id, data, true);\r\n                // Sync metadata.\r\n                if (inodeChanged) {\r\n                    tx.put(fileInodeId, fileInode.toBuffer(), true);\r\n                }\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n        }\r\n        /**\r\n         * Checks if the root directory exists. Creates it if it doesn't.\r\n         */\r\n        makeRootDirectory() {\r\n            const tx = this.store.beginTransaction('readwrite');\r\n            if (tx.get(ROOT_NODE_ID) === undefined) {\r\n                // Create new inode.\r\n                const currTime = (new Date()).getTime(), \r\n                // Mode 0666\r\n                dirInode = new Inode(GenerateRandomID(), 4096, 511 | FileType.DIRECTORY, currTime, currTime, currTime);\r\n                // If the root doesn't exist, the first random ID shouldn't exist,\r\n                // either.\r\n                tx.put(dirInode.id, getEmptyDirNode(), false);\r\n                tx.put(ROOT_NODE_ID, dirInode.toBuffer(), false);\r\n                tx.commit();\r\n            }\r\n        }\r\n        /**\r\n         * Helper function for findINode.\r\n         * @param parent The parent directory of the file we are attempting to find.\r\n         * @param filename The filename of the inode we are attempting to find, minus\r\n         *   the parent.\r\n         * @return string The ID of the file's inode in the file system.\r\n         */\r\n        _findINode(tx, parent, filename) {\r\n            const readDirectory = (inode) => {\r\n                // Get the root's directory listing.\r\n                const dirList = this.getDirListing(tx, parent, inode);\r\n                // Get the file's ID.\r\n                if (dirList[filename]) {\r\n                    return dirList[filename];\r\n                }\r\n                else {\r\n                    throw FileError.ENOENT(paths.resolve(parent, filename));\r\n                }\r\n            };\r\n            if (parent === '/') {\r\n                if (filename === '') {\r\n                    // BASE CASE #1: Return the root's ID.\r\n                    return ROOT_NODE_ID;\r\n                }\r\n                else {\r\n                    // BASE CASE #2: Find the item in the root ndoe.\r\n                    return readDirectory(this.getINode(tx, parent, ROOT_NODE_ID));\r\n                }\r\n            }\r\n            else {\r\n                return readDirectory(this.getINode(tx, parent + paths.sep + filename, this._findINode(tx, paths.dirname(parent), paths.basename(parent))));\r\n            }\r\n        }\r\n        /**\r\n         * Finds the Inode of the given path.\r\n         * @param p The path to look up.\r\n         * @return The Inode of the path p.\r\n         * @todo memoize/cache\r\n         */\r\n        findINode(tx, p) {\r\n            return this.getINode(tx, p, this._findINode(tx, paths.dirname(p), paths.basename(p)));\r\n        }\r\n        /**\r\n         * Given the ID of a node, retrieves the corresponding Inode.\r\n         * @param tx The transaction to use.\r\n         * @param p The corresponding path to the file (used for error messages).\r\n         * @param id The ID to look up.\r\n         */\r\n        getINode(tx, p, id) {\r\n            const inode = tx.get(id);\r\n            if (inode === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return Inode.fromBuffer(inode);\r\n        }\r\n        /**\r\n         * Given the Inode of a directory, retrieves the corresponding directory\r\n         * listing.\r\n         */\r\n        getDirListing(tx, p, inode) {\r\n            if (!inode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            const data = tx.get(inode.id);\r\n            if (data === undefined) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            return JSON.parse(data.toString());\r\n        }\r\n        /**\r\n         * Creates a new node under a random ID. Retries 5 times before giving up in\r\n         * the exceedingly unlikely chance that we try to reuse a random GUID.\r\n         * @return The GUID that the data was stored under.\r\n         */\r\n        addNewNode(tx, data) {\r\n            const retries = 0;\r\n            let currId;\r\n            while (retries < 5) {\r\n                try {\r\n                    currId = GenerateRandomID();\r\n                    tx.put(currId, data, false);\r\n                    return currId;\r\n                }\r\n                catch (e) {\r\n                    // Ignore and reroll.\r\n                }\r\n            }\r\n            throw new FileError(ErrorCodes.EIO, 'Unable to commit data to key-value store.');\r\n        }\r\n        /**\r\n         * Commits a new file (well, a FILE or a DIRECTORY) to the file system with\r\n         * the given mode.\r\n         * Note: This will commit the transaction.\r\n         * @param p The path to the new file.\r\n         * @param type The type of the new file.\r\n         * @param mode The mode to create the new file with.\r\n         * @param data The data to store at the file's data node.\r\n         * @return The Inode for the new file.\r\n         */\r\n        commitNewFile(tx, p, type, mode, data) {\r\n            const parentDir = paths.dirname(p), fname = paths.basename(p), parentNode = this.findINode(tx, parentDir), dirListing = this.getDirListing(tx, parentDir, parentNode), currTime = (new Date()).getTime();\r\n            // Invariant: The root always exists.\r\n            // If we don't check this prior to taking steps below, we will create a\r\n            // file with name '' in root should p == '/'.\r\n            if (p === '/') {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            // Check if file already exists.\r\n            if (dirListing[fname]) {\r\n                throw FileError.EEXIST(p);\r\n            }\r\n            let fileNode;\r\n            try {\r\n                // Commit data.\r\n                const dataId = this.addNewNode(tx, data);\r\n                fileNode = new Inode(dataId, data.length, mode | type, currTime, currTime, currTime);\r\n                // Commit file node.\r\n                const fileNodeId = this.addNewNode(tx, fileNode.toBuffer());\r\n                // Update and commit parent directory listing.\r\n                dirListing[fname] = fileNodeId;\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(dirListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            tx.commit();\r\n            return fileNode;\r\n        }\r\n        /**\r\n         * Remove all traces of the given path from the file system.\r\n         * @param p The path to remove from the file system.\r\n         * @param isDir Does the path belong to a directory, or a file?\r\n         * @todo Update mtime.\r\n         */\r\n        removeEntry(p, isDir) {\r\n            const tx = this.store.beginTransaction('readwrite'), parent = paths.dirname(p), parentNode = this.findINode(tx, parent), parentListing = this.getDirListing(tx, parent, parentNode), fileName = paths.basename(p);\r\n            if (!parentListing[fileName]) {\r\n                throw FileError.ENOENT(p);\r\n            }\r\n            // Remove from directory listing of parent.\r\n            const fileNodeId = parentListing[fileName];\r\n            delete parentListing[fileName];\r\n            // Get file inode.\r\n            const fileNode = this.getINode(tx, p, fileNodeId);\r\n            if (!isDir && fileNode.isDirectory()) {\r\n                throw FileError.EISDIR(p);\r\n            }\r\n            else if (isDir && !fileNode.isDirectory()) {\r\n                throw FileError.ENOTDIR(p);\r\n            }\r\n            try {\r\n                // Delete data.\r\n                tx.del(fileNode.id);\r\n                // Delete node.\r\n                tx.del(fileNodeId);\r\n                // Update directory listing.\r\n                tx.put(parentNode.id, Buffer.from(JSON.stringify(parentListing)), true);\r\n            }\r\n            catch (e) {\r\n                tx.abort();\r\n                throw e;\r\n            }\r\n            // Success.\r\n            tx.commit();\r\n        }\r\n    }\r\n\r\n\r\n    return files.providers.SyncKeyValueProvider = SyncKeyValueProvider;\r\n});\ndefine('skylark-data-files/providers/simple-sync-rw-transaction',[\r\n    \"../files\",\r\n    \"../error-codes\",\r\n    '../file-error'\r\n], function (files, ErrorCodes, FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A simple RW transaction for simple synchronous key-value stores.\r\n     */\r\n    class SimpleSyncRWTransaction {\r\n        constructor(store) {\r\n            this.store = store;\r\n            /**\r\n             * Stores data in the keys we modify prior to modifying them.\r\n             * Allows us to roll back commits.\r\n             */\r\n            this.originalData = {};\r\n            /**\r\n             * List of keys modified in this transaction, if any.\r\n             */\r\n            this.modifiedKeys = [];\r\n        }\r\n        get(key) {\r\n            const val = this.store.get(key);\r\n            this.stashOldValue(key, val);\r\n            return val;\r\n        }\r\n        put(key, data, overwrite) {\r\n            this.markModified(key);\r\n            return this.store.put(key, data, overwrite);\r\n        }\r\n        del(key) {\r\n            this.markModified(key);\r\n            this.store.del(key);\r\n        }\r\n        commit() { }\r\n        abort() {\r\n            // Rollback old values.\r\n            for (const key of this.modifiedKeys) {\r\n                const value = this.originalData[key];\r\n                if (!value) {\r\n                    // Key didn't exist.\r\n                    this.store.del(key);\r\n                }\r\n                else {\r\n                    // Key existed. Store old value.\r\n                    this.store.put(key, value, true);\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Stashes given key value pair into `originalData` if it doesn't already\r\n         * exist. Allows us to stash values the program is requesting anyway to\r\n         * prevent needless `get` requests if the program modifies the data later\r\n         * on during the transaction.\r\n         */\r\n        stashOldValue(key, value) {\r\n            // Keep only the earliest value in the transaction.\r\n            if (!this.originalData.hasOwnProperty(key)) {\r\n                this.originalData[key] = value;\r\n            }\r\n        }\r\n        /**\r\n         * Marks the given key as modified, and stashes its value if it has not been\r\n         * stashed already.\r\n         */\r\n        markModified(key) {\r\n            if (this.modifiedKeys.indexOf(key) === -1) {\r\n                this.modifiedKeys.push(key);\r\n                if (!this.originalData.hasOwnProperty(key)) {\r\n                    this.originalData[key] = this.store.get(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return files.providers.SimpleSyncRWTransaction = SimpleSyncRWTransaction;\r\n});\ndefine('skylark-data-files/providers/inmemory/in-memory-store',[\r\n    '../simple-sync-rw-transaction'\r\n], function (SimpleSyncRWTransaction) {\r\n    'use strict';\r\n\r\n    /**\r\n     * A simple in-memory key-value store backed by a JavaScript object.\r\n     */\r\n    class InMemoryStore {\r\n        constructor() {\r\n            this.store = {};\r\n        }\r\n        clear() { this.store = {}; }\r\n        beginTransaction(type) {\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            return this.store[key];\r\n        }\r\n        put(key, data, overwrite) {\r\n            if (!overwrite && this.store.hasOwnProperty(key)) {\r\n                return false;\r\n            }\r\n            this.store[key] = data;\r\n            return true;\r\n        }\r\n        del(key) {\r\n            delete this.store[key];\r\n        }\r\n    }\r\n\r\n\r\n    return InMemoryStore;\r\n});\ndefine('skylark-data-files/providers/inmemory/in-memory-provider',[\n    '../sync-key-value-provider',\n    \"./in-memory-store\"\n], function (SyncKeyValueProvider,InMemoryStore) {\n    'use strict';\n\n    /**\n     * A simple in-memory file system backed by an InMemoryStore.\n     * Files are not persisted across page loads.\n     */\n    class InMemoryProvider extends SyncKeyValueProvider {\n        name() { return InMemoryProvider.Name; }\n        constructor() {\n            super({ store: new InMemoryStore() });\n        }\n        /**\n         * Creates an InMemoryProvider instance.\n         */\n        static Create(options, cb) {\n            cb(null, new InMemoryProvider());\n        }\n    }\n    InMemoryProvider.Name = \"InMemory\";\n    InMemoryProvider.Options = {};\n\n    InMemoryProvider.InMemoryStore = InMemoryStore;\n\n    return InMemoryProvider;\n});\ndefine('skylark-data-files/providers/localstorage/local-storage-store',[\r\n    \"skylark-langx-binary/buffer\",\r\n    '../simple-sync-rw-transaction',\r\n    '../../error-codes',\r\n    '../../file-error',\r\n], function (Buffer,SimpleSyncRWTransaction, ErrorCodes,FileError) {\r\n    'use strict';\r\n\r\n\r\n    /**\r\n     * A synchronous key-value store backed by localStorage.\r\n     */\r\n    class LocalStorageStore {\r\n        name() {\r\n            return LocalStorageProvider.Name;\r\n        }\r\n        clear() {\r\n            window.localStorage.clear();\r\n        }\r\n        beginTransaction(type) {\r\n            // No need to differentiate.\r\n            return new SimpleSyncRWTransaction(this);\r\n        }\r\n        get(key) {\r\n            try {\r\n                const data = window.localStorage.getItem(key);\r\n                if (data !== null) {\r\n                    return Buffer.from(data, binaryEncoding);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // Do nothing.\r\n            }\r\n            // Key doesn't exist, or a failure occurred.\r\n            return undefined;\r\n        }\r\n        put(key, data, overwrite) {\r\n            try {\r\n                if (!overwrite && window.localStorage.getItem(key) !== null) {\r\n                    // Don't want to overwrite the key!\r\n                    return false;\r\n                }\r\n                window.localStorage.setItem(key, data.toString(binaryEncoding));\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.ENOSPC, \"LocalStorage is full.\");\r\n            }\r\n        }\r\n        del(key) {\r\n            try {\r\n                window.localStorage.removeItem(key);\r\n            }\r\n            catch (e) {\r\n                throw new FileError(ErrorCodes.EIO, \"Unable to delete key \" + key + \": \" + e);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    return LocalStorageStore;\r\n});\ndefine('skylark-data-files/providers/localstorage/local-storage-provider',[\n    \"skylark-langx-binary/buffer\",\n    '../sync-key-value-provider',\n    '../../error-codes',\n    '../../file-error',\n    \"./local-storage-store\"\n], function (Buffer,SyncKeyValueProvider, ErrorCodes,FileError,LocalStorageStore) {\n    'use strict';\n\n\n    /**\n     * Some versions of FF and all versions of IE do not support the full range of\n     * 16-bit numbers encoded as characters, as they enforce UTF-16 restrictions.\n     * @url http://stackoverflow.com/questions/11170716/are-there-any-characters-that-are-not-allowed-in-localstorage/11173673#11173673\n     * @hidden\n     */\n    let supportsBinaryString = false, binaryEncoding;\n    try {\n        window.localStorage.setItem(\"__test__\", String.fromCharCode(0xD800));\n        supportsBinaryString = window.localStorage.getItem(\"__test__\") === String.fromCharCode(0xD800);\n    }\n    catch (e) {\n        // IE throws an exception.\n        supportsBinaryString = false;\n    }\n    \n    binaryEncoding = supportsBinaryString ? 'binary_string' : 'binary_string_ie';\n    if (!Buffer.isEncoding(binaryEncoding)) {\n        // Fallback for non BrowserFS implementations of buffer that lack a\n        // binary_string format.\n        binaryEncoding = \"base64\";\n    }\n\n    /**\n     * A synchronous file system backed by localStorage. Connects our\n     * LocalStorageStore to our SyncKeyValueProvider.\n     */\n    class LocalStorageProvider extends SyncKeyValueProvider {\n        /**\n         * Creates a new LocalStorage file system using the contents of `localStorage`.\n         */\n        constructor() { super({ store: new LocalStorageStore() }); }\n        /**\n         * Creates a LocalStorageProvider instance.\n         */\n        static Create(options, cb) {\n            cb(null, new LocalStorageProvider());\n        }\n        static isAvailable() {\n            return typeof window.localStorage !== 'undefined';\n        }\n    }\n\n    LocalStorageProvider.Name = \"LocalStorage\";\n    LocalStorageProvider.Options = {};\n    \n    LocalStorageProvider.LocalStorageStore = LocalStorageStore;\n\n    return LocalStorageProvider;\n});\ndefine('skylark-data-files/providers/mutex',[\r\n    \"skylark-langx-funcs/defer\"\r\n], function (defer) {\r\n    'use strict';\r\n    /**\r\n     * Non-recursive mutex\r\n     * @hidden\r\n     */\r\n    class Mutex {\r\n        constructor() {\r\n            this._locked = false;\r\n            this._waiters = [];\r\n        }\r\n        lock(cb) {\r\n            if (this._locked) {\r\n                this._waiters.push(cb);\r\n                return;\r\n            }\r\n            this._locked = true;\r\n            cb();\r\n        }\r\n        unlock() {\r\n            if (!this._locked) {\r\n                throw new Error('unlock of a non-locked mutex');\r\n            }\r\n            const next = this._waiters.shift();\r\n            // don't unlock - we want to queue up next for the\r\n            // _end_ of the current task execution, but we don't\r\n            // want it to be called inline with whatever the\r\n            // current stack is.  This way we still get the nice\r\n            // behavior that an unlock immediately followed by a\r\n            // lock won't cause starvation.\r\n            if (next) {\r\n                defer(next);\r\n                return;\r\n            }\r\n            this._locked = false;\r\n        }\r\n        tryLock() {\r\n            if (this._locked) {\r\n                return false;\r\n            }\r\n            this._locked = true;\r\n            return true;\r\n        }\r\n        isLocked() {\r\n            return this._locked;\r\n        }\r\n    }\r\n\r\n    return Mutex;\r\n});\ndefine('skylark-data-files/providers/locked-provider',[\r\n    \"../files\",\r\n    './mutex'\r\n], function (files,Mutex) {\r\n    'use strict';\r\n    /**\r\n     * This class serializes access to an underlying async filesystem.\r\n     * For example, on an OverlayFS instance with an async lower\r\n     * directory operations like rename and rmdir may involve multiple\r\n     * requests involving both the upper and lower filesystems -- they\r\n     * are not executed in a single atomic step.  OverlayFS uses this\r\n     * LockedProvider to avoid having to reason about the correctness of\r\n     * multiple requests interleaving.\r\n     */\r\n    class LockedProvider {\r\n        constructor(fs) {\r\n            this._fs = fs;\r\n            this._mu = new Mutex();\r\n        }\r\n        getName() {\r\n            return 'LockedProvider<' + this._fs.getName() + '>';\r\n        }\r\n        getFSUnlocked() {\r\n            return this._fs;\r\n        }\r\n        diskSpace(p, cb) {\r\n            // FIXME: should this lock?\r\n            this._fs.diskSpace(p, cb);\r\n        }\r\n        isReadOnly() {\r\n            return this._fs.isReadOnly();\r\n        }\r\n        supportsLinks() {\r\n            return this._fs.supportsLinks();\r\n        }\r\n        supportsProps() {\r\n            return this._fs.supportsProps();\r\n        }\r\n        supportsSynch() {\r\n            return this._fs.supportsSynch();\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rename(oldPath, newPath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.renameSync(oldPath, newPath);\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.stat(p, isLstat, (err, stat) => {\r\n                    this._mu.unlock();\r\n                    cb(err, stat);\r\n                });\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.statSync(p, isLstat);\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.open(p, flag, mode, (err, fd) => {\r\n                    this._mu.unlock();\r\n                    cb(err, fd);\r\n                });\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.openSync(p, flag, mode);\r\n        }\r\n        unlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.unlink(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.unlinkSync(p);\r\n        }\r\n        rmdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.rmdir(p, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.rmdirSync(p);\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.mkdir(p, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.mkdirSync(p, mode);\r\n        }\r\n        readdir(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readdir(p, (err, files) => {\r\n                    this._mu.unlock();\r\n                    cb(err, files);\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readdirSync(p);\r\n        }\r\n        exists(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.exists(p, (exists) => {\r\n                    this._mu.unlock();\r\n                    cb(exists);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.existsSync(p);\r\n        }\r\n        realpath(p, cache, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.realpath(p, cache, (err, resolvedPath) => {\r\n                    this._mu.unlock();\r\n                    cb(err, resolvedPath);\r\n                });\r\n            });\r\n        }\r\n        realpathSync(p, cache) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.realpathSync(p, cache);\r\n        }\r\n        truncate(p, len, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.truncate(p, len, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        truncateSync(p, len) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.truncateSync(p, len);\r\n        }\r\n        readFile(fname, encoding, flag, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readFile(fname, encoding, flag, (err, data) => {\r\n                    this._mu.unlock();\r\n                    cb(err, data);\r\n                });\r\n            });\r\n        }\r\n        readFileSync(fname, encoding, flag) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readFileSync(fname, encoding, flag);\r\n        }\r\n        writeFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.writeFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        writeFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.writeFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        appendFile(fname, data, encoding, flag, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.appendFile(fname, data, encoding, flag, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        appendFileSync(fname, data, encoding, flag, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.appendFileSync(fname, data, encoding, flag, mode);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chmod(p, isLchmod, mode, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chmodSync(p, isLchmod, mode);\r\n        }\r\n        chown(p, isLchown, uid, gid, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.chown(p, isLchown, uid, gid, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.chownSync(p, isLchown, uid, gid);\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.utimes(p, atime, mtime, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.utimesSync(p, atime, mtime);\r\n        }\r\n        link(srcpath, dstpath, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.link(srcpath, dstpath, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        linkSync(srcpath, dstpath) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.linkSync(srcpath, dstpath);\r\n        }\r\n        symlink(srcpath, dstpath, type, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.symlink(srcpath, dstpath, type, (err) => {\r\n                    this._mu.unlock();\r\n                    cb(err);\r\n                });\r\n            });\r\n        }\r\n        symlinkSync(srcpath, dstpath, type) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.symlinkSync(srcpath, dstpath, type);\r\n        }\r\n        readlink(p, cb) {\r\n            this._mu.lock(() => {\r\n                this._fs.readlink(p, (err, linkString) => {\r\n                    this._mu.unlock();\r\n                    cb(err, linkString);\r\n                });\r\n            });\r\n        }\r\n        readlinkSync(p) {\r\n            if (this._mu.isLocked()) {\r\n                throw new Error('invalid sync call');\r\n            }\r\n            return this._fs.readlinkSync(p);\r\n        }\r\n    }\r\n\r\n    return files.providers.LockedProvider = LockedProvider;\r\n});\ndefine('skylark-data-files/providers/overlay/overlay-file',[\r\n    '../../preload-file'\r\n], function (PreloadFile) {\r\n\r\n    /**\r\n     * Overlays a RO file to make it writable.\r\n     */\r\n    class OverlayFile extends PreloadFile {\r\n        constructor(fs, path, flag, stats, data) {\r\n            super(fs, path, flag, stats, data);\r\n        }\r\n        sync(cb) {\r\n            if (!this.isDirty()) {\r\n                cb(null);\r\n                return;\r\n            }\r\n            this._fs._syncAsync(this, (err) => {\r\n                this.resetDirty();\r\n                cb(err);\r\n            });\r\n        }\r\n        syncSync() {\r\n            if (this.isDirty()) {\r\n                this._fs._syncSync(this);\r\n                this.resetDirty();\r\n            }\r\n        }\r\n        close(cb) {\r\n            this.sync(cb);\r\n        }\r\n        closeSync() {\r\n            this.syncSync();\r\n        }\r\n    }\r\n\r\n\r\n    return OverlayFile;\r\n});\ndefine('skylark-data-files/providers/overlay/unlocked-overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    \"../base-provider\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"./overlay-file\"\r\n], function (paths, BaseProvider, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,OverlayFile) {\r\n    /**\r\n     * @hidden\r\n     */\r\n    const deletionLogPath = '/.deletedFiles.log';\r\n\r\n    /**\r\n     * Given a read-only mode, makes it writable.\r\n     * @hidden\r\n     */\r\n    function makeModeWritable(mode) {\r\n        return 0o222 | mode;\r\n    }\r\n\r\n\r\n    /**\r\n     * @hidden\r\n     */\r\n    function getFlag(f) {\r\n        return FileFlag.getFileFlag(f);\r\n    }    \r\n     /**\r\n     * *INTERNAL, DO NOT USE DIRECTLY!*\r\n     *\r\n     * Core OverlayProviderclass that contains no locking whatsoever. We wrap these objects\r\n     * in a LockedFS to prevent races.\r\n     */\r\n    class UnlockedOverlayProvider extends BaseProvider {\r\n        constructor(writable, readable) {\r\n            super();\r\n            this._isInitialized = false;\r\n            this._initializeCallbacks = [];\r\n            this._deletedFiles = {};\r\n            this._deleteLog = '';\r\n            // If 'true', we have scheduled a delete log update.\r\n            this._deleteLogUpdatePending = false;\r\n            // If 'true', a delete log update is needed after the scheduled delete log\r\n            // update finishes.\r\n            this._deleteLogUpdateNeeded = false;\r\n            // If there was an error updating the delete log...\r\n            this._deleteLogError = null;\r\n            this._writable = writable;\r\n            this._readable = readable;\r\n            if (this._writable.isReadOnly()) {\r\n                throw new ApiError(ErrorCode.EINVAL, \"Writable file system must be writable.\");\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return true;\r\n        }\r\n        getOverlayedProviders() {\r\n            return {\r\n                readable: this._readable,\r\n                writable: this._writable\r\n            };\r\n        }\r\n        _syncAsync(file, cb) {\r\n            this.createParentDirectoriesAsync(file.getPath(), (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                this._writable.writeFile(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode, cb);\r\n            });\r\n        }\r\n        _syncSync(file) {\r\n            this.createParentDirectories(file.getPath());\r\n            this._writable.writeFileSync(file.getPath(), file.getBuffer(), null, getFlag('w'), file.getStats().mode);\r\n        }\r\n        getName() {\r\n            return OverlayFS.Name;\r\n        }\r\n        /**\r\n         * **INTERNAL METHOD**\r\n         *\r\n         * Called once to load up metadata stored on the writable file system.\r\n         */\r\n        _initialize(cb) {\r\n            const callbackArray = this._initializeCallbacks;\r\n            const end = (e) => {\r\n                this._isInitialized = !e;\r\n                this._initializeCallbacks = [];\r\n                callbackArray.forEach(((cb) => cb(e)));\r\n            };\r\n            // if we're already initialized, immediately invoke the callback\r\n            if (this._isInitialized) {\r\n                return cb();\r\n            }\r\n            callbackArray.push(cb);\r\n            // The first call to initialize initializes, the rest wait for it to complete.\r\n            if (callbackArray.length !== 1) {\r\n                return;\r\n            }\r\n            // Read deletion log, process into metadata.\r\n            this._writable.readFile(deletionLogPath, 'utf8', getFlag('r'), (err, data) => {\r\n                if (err) {\r\n                    // ENOENT === Newly-instantiated file system, and thus empty log.\r\n                    if (err.errno !== ErrorCode.ENOENT) {\r\n                        return end(err);\r\n                    }\r\n                }\r\n                else {\r\n                    this._deleteLog = data;\r\n                }\r\n                this._reparseDeletionLog();\r\n                end();\r\n            });\r\n        }\r\n        isReadOnly() { return false; }\r\n        supportsSynch() { return this._readable.supportsSynch() && this._writable.supportsSynch(); }\r\n        supportsLinks() { return false; }\r\n        supportsProps() { return this._readable.supportsProps() && this._writable.supportsProps(); }\r\n        getDeletionLog() {\r\n            return this._deleteLog;\r\n        }\r\n        restoreDeletionLog(log) {\r\n            this._deleteLog = log;\r\n            this._reparseDeletionLog();\r\n            this.updateLog('');\r\n        }\r\n        rename(oldPath, newPath, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(oldPath, cb) || this.checkPathAsync(newPath, cb)) {\r\n                return;\r\n            }\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                return cb(ApiError.EPERM('Cannot rename deletion log.'));\r\n            }\r\n            // nothing to do if paths match\r\n            if (oldPath === newPath) {\r\n                return cb();\r\n            }\r\n            this.stat(oldPath, false, (oldErr, oldStats) => {\r\n                if (oldErr) {\r\n                    return cb(oldErr);\r\n                }\r\n                return this.stat(newPath, false, (newErr, newStats) => {\r\n                    const self = this;\r\n                    // precondition: both oldPath and newPath exist and are dirs.\r\n                    // decreases: |files|\r\n                    // Need to move *every file/folder* currently stored on\r\n                    // readable to its new location on writable.\r\n                    function copyDirContents(files) {\r\n                        const file = files.shift();\r\n                        if (!file) {\r\n                            return cb();\r\n                        }\r\n                        const oldFile = paths.resolve(oldPath, file);\r\n                        const newFile = paths.resolve(newPath, file);\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        self.rename(oldFile, newFile, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            copyDirContents(files);\r\n                        });\r\n                    }\r\n                    let mode = 0o777;\r\n                    // from linux's rename(2) manpage: oldpath can specify a\r\n                    // directory.  In this case, newpath must either not exist, or\r\n                    // it must specify an empty directory.\r\n                    if (oldStats.isDirectory()) {\r\n                        if (newErr) {\r\n                            if (newErr.errno !== ErrorCode.ENOENT) {\r\n                                return cb(newErr);\r\n                            }\r\n                            return this._writable.exists(oldPath, (exists) => {\r\n                                // simple case - both old and new are on the writable layer\r\n                                if (exists) {\r\n                                    return this._writable.rename(oldPath, newPath, cb);\r\n                                }\r\n                                this._writable.mkdir(newPath, mode, (mkdirErr) => {\r\n                                    if (mkdirErr) {\r\n                                        return cb(mkdirErr);\r\n                                    }\r\n                                    this._readable.readdir(oldPath, (err, files) => {\r\n                                        if (err) {\r\n                                            return cb();\r\n                                        }\r\n                                        copyDirContents(files);\r\n                                    });\r\n                                });\r\n                            });\r\n                        }\r\n                        mode = newStats.mode;\r\n                        if (!newStats.isDirectory()) {\r\n                            return cb(ApiError.ENOTDIR(newPath));\r\n                        }\r\n                        this.readdir(newPath, (readdirErr, files) => {\r\n                            if (files && files.length) {\r\n                                return cb(ApiError.ENOTEMPTY(newPath));\r\n                            }\r\n                            this._readable.readdir(oldPath, (err, files) => {\r\n                                if (err) {\r\n                                    return cb();\r\n                                }\r\n                                copyDirContents(files);\r\n                            });\r\n                        });\r\n                    }\r\n                    if (newStats && newStats.isDirectory()) {\r\n                        return cb(ApiError.EISDIR(newPath));\r\n                    }\r\n                    this.readFile(oldPath, null, getFlag('r'), (err, data) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        return this.writeFile(newPath, data, null, getFlag('w'), oldStats.mode, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            return this.unlink(oldPath, cb);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        renameSync(oldPath, newPath) {\r\n            this.checkInitialized();\r\n            this.checkPath(oldPath);\r\n            this.checkPath(newPath);\r\n            if (oldPath === deletionLogPath || newPath === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot rename deletion log.');\r\n            }\r\n            // Write newPath using oldPath's contents, delete oldPath.\r\n            const oldStats = this.statSync(oldPath, false);\r\n            if (oldStats.isDirectory()) {\r\n                // Optimization: Don't bother moving if old === new.\r\n                if (oldPath === newPath) {\r\n                    return;\r\n                }\r\n                let mode = 0o777;\r\n                if (this.existsSync(newPath)) {\r\n                    const stats = this.statSync(newPath, false);\r\n                    mode = stats.mode;\r\n                    if (stats.isDirectory()) {\r\n                        if (this.readdirSync(newPath).length > 0) {\r\n                            throw ApiError.ENOTEMPTY(newPath);\r\n                        }\r\n                    }\r\n                    else {\r\n                        throw ApiError.ENOTDIR(newPath);\r\n                    }\r\n                }\r\n                // Take care of writable first. Move any files there, or create an empty directory\r\n                // if it doesn't exist.\r\n                if (this._writable.existsSync(oldPath)) {\r\n                    this._writable.renameSync(oldPath, newPath);\r\n                }\r\n                else if (!this._writable.existsSync(newPath)) {\r\n                    this._writable.mkdirSync(newPath, mode);\r\n                }\r\n                // Need to move *every file/folder* currently stored on readable to its new location\r\n                // on writable.\r\n                if (this._readable.existsSync(oldPath)) {\r\n                    this._readable.readdirSync(oldPath).forEach((name) => {\r\n                        // Recursion! Should work for any nested files / folders.\r\n                        this.renameSync(paths.resolve(oldPath, name), paths.resolve(newPath, name));\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                if (this.existsSync(newPath) && this.statSync(newPath, false).isDirectory()) {\r\n                    throw ApiError.EISDIR(newPath);\r\n                }\r\n                this.writeFileSync(newPath, this.readFileSync(oldPath, null, getFlag('r')), null, getFlag('w'), oldStats.mode);\r\n            }\r\n            if (oldPath !== newPath && this.existsSync(oldPath)) {\r\n                this.unlinkSync(oldPath);\r\n            }\r\n        }\r\n        stat(p, isLstat, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this._writable.stat(p, isLstat, (err, stat) => {\r\n                if (err && err.errno === ErrorCode.ENOENT) {\r\n                    if (this._deletedFiles[p]) {\r\n                        cb(ApiError.ENOENT(p));\r\n                    }\r\n                    this._readable.stat(p, isLstat, (err, stat) => {\r\n                        if (stat) {\r\n                            // Make the oldStat's mode writable. Preserve the topmost\r\n                            // part of the mode, which specifies if it is a file or a\r\n                            // directory.\r\n                            stat = Stats.clone(stat);\r\n                            stat.mode = makeModeWritable(stat.mode);\r\n                        }\r\n                        cb(err, stat);\r\n                    });\r\n                }\r\n                else {\r\n                    cb(err, stat);\r\n                }\r\n            });\r\n        }\r\n        statSync(p, isLstat) {\r\n            this.checkInitialized();\r\n            try {\r\n                return this._writable.statSync(p, isLstat);\r\n            }\r\n            catch (e) {\r\n                if (this._deletedFiles[p]) {\r\n                    throw ApiError.ENOENT(p);\r\n                }\r\n                const oldStat = Stats.clone(this._readable.statSync(p, isLstat));\r\n                // Make the oldStat's mode writable. Preserve the topmost part of the\r\n                // mode, which specifies if it is a file or a directory.\r\n                oldStat.mode = makeModeWritable(oldStat.mode);\r\n                return oldStat;\r\n            }\r\n        }\r\n        open(p, flag, mode, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, stats) => {\r\n                if (stats) {\r\n                    switch (flag.pathExistsAction()) {\r\n                        case ActionType.TRUNCATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        case ActionType.NOP:\r\n                            return this._writable.exists(p, (exists) => {\r\n                                if (exists) {\r\n                                    this._writable.open(p, flag, mode, cb);\r\n                                }\r\n                                else {\r\n                                    // at this point we know the stats object we got is from\r\n                                    // the readable FS.\r\n                                    stats = Stats.clone(stats);\r\n                                    stats.mode = mode;\r\n                                    this._readable.readFile(p, null, getFlag('r'), (readFileErr, data) => {\r\n                                        if (readFileErr) {\r\n                                            return cb(readFileErr);\r\n                                        }\r\n                                        if (stats.size === -1) {\r\n                                            stats.size = data.length;\r\n                                        }\r\n                                        const f = new OverlayFile(this, p, flag, stats, data);\r\n                                        cb(null, f);\r\n                                    });\r\n                                }\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.EEXIST(p));\r\n                    }\r\n                }\r\n                else {\r\n                    switch (flag.pathNotExistsAction()) {\r\n                        case ActionType.CREATE_FILE:\r\n                            return this.createParentDirectoriesAsync(p, (err) => {\r\n                                if (err) {\r\n                                    return cb(err);\r\n                                }\r\n                                return this._writable.open(p, flag, mode, cb);\r\n                            });\r\n                        default:\r\n                            return cb(ApiError.ENOENT(p));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        openSync(p, flag, mode) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM('Cannot open deletion log.');\r\n            }\r\n            if (this.existsSync(p)) {\r\n                switch (flag.pathExistsAction()) {\r\n                    case ActionType.TRUNCATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    case ActionType.NOP:\r\n                        if (this._writable.existsSync(p)) {\r\n                            return this._writable.openSync(p, flag, mode);\r\n                        }\r\n                        else {\r\n                            // Create an OverlayFile.\r\n                            const buf = this._readable.readFileSync(p, null, getFlag('r'));\r\n                            const stats = Stats.clone(this._readable.statSync(p, false));\r\n                            stats.mode = mode;\r\n                            return new OverlayFile(this, p, flag, stats, buf);\r\n                        }\r\n                    default:\r\n                        throw ApiError.EEXIST(p);\r\n                }\r\n            }\r\n            else {\r\n                switch (flag.pathNotExistsAction()) {\r\n                    case ActionType.CREATE_FILE:\r\n                        this.createParentDirectories(p);\r\n                        return this._writable.openSync(p, flag, mode);\r\n                    default:\r\n                        throw ApiError.ENOENT(p);\r\n                }\r\n            }\r\n        }\r\n        unlink(p, cb) {\r\n            if (!this.checkInitAsync(cb) || this.checkPathAsync(p, cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        return this._writable.unlink(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    this.deletePath(p);\r\n                                }\r\n                                cb(null);\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        // if this only exists on the readable FS, add it to the\r\n                        // delete map.\r\n                        this.deletePath(p);\r\n                        cb(null);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        unlinkSync(p) {\r\n            this.checkInitialized();\r\n            this.checkPath(p);\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.unlinkSync(p);\r\n                }\r\n                // if it still exists add to the delete log\r\n                if (this.existsSync(p)) {\r\n                    this.deletePath(p);\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        rmdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            const rmdirLower = () => {\r\n                this.readdir(p, (err, files) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    if (files.length) {\r\n                        return cb(ApiError.ENOTEMPTY(p));\r\n                    }\r\n                    this.deletePath(p);\r\n                    cb(null);\r\n                });\r\n            };\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (writableExists) => {\r\n                    if (writableExists) {\r\n                        this._writable.rmdir(p, (err) => {\r\n                            if (err) {\r\n                                return cb(err);\r\n                            }\r\n                            this._readable.exists(p, (readableExists) => {\r\n                                if (readableExists) {\r\n                                    rmdirLower();\r\n                                }\r\n                                else {\r\n                                    cb();\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else {\r\n                        rmdirLower();\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        rmdirSync(p) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                if (this._writable.existsSync(p)) {\r\n                    this._writable.rmdirSync(p);\r\n                }\r\n                if (this.existsSync(p)) {\r\n                    // Check if directory is empty.\r\n                    if (this.readdirSync(p).length > 0) {\r\n                        throw ApiError.ENOTEMPTY(p);\r\n                    }\r\n                    else {\r\n                        this.deletePath(p);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        mkdir(p, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.exists(p, (exists) => {\r\n                if (exists) {\r\n                    return cb(ApiError.EEXIST(p));\r\n                }\r\n                // The below will throw should any of the parent directories\r\n                // fail to exist on _writable.\r\n                this.createParentDirectoriesAsync(p, (err) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this._writable.mkdir(p, mode, cb);\r\n                });\r\n            });\r\n        }\r\n        mkdirSync(p, mode) {\r\n            this.checkInitialized();\r\n            if (this.existsSync(p)) {\r\n                throw ApiError.EEXIST(p);\r\n            }\r\n            else {\r\n                // The below will throw should any of the parent directories fail to exist\r\n                // on _writable.\r\n                this.createParentDirectories(p);\r\n                this._writable.mkdirSync(p, mode);\r\n            }\r\n        }\r\n        readdir(p, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.stat(p, false, (err, dirStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (!dirStats.isDirectory()) {\r\n                    return cb(ApiError.ENOTDIR(p));\r\n                }\r\n                this._writable.readdir(p, (err, wFiles) => {\r\n                    if (err && err.code !== 'ENOENT') {\r\n                        return cb(err);\r\n                    }\r\n                    else if (err || !wFiles) {\r\n                        wFiles = [];\r\n                    }\r\n                    this._readable.readdir(p, (err, rFiles) => {\r\n                        // if the directory doesn't exist on the lower FS set rFiles\r\n                        // here to simplify the following code.\r\n                        if (err || !rFiles) {\r\n                            rFiles = [];\r\n                        }\r\n                        // Readdir in both, check delete log on read-only file system's files, merge, return.\r\n                        const seenMap = {};\r\n                        const filtered = wFiles.concat(rFiles.filter((fPath) => !this._deletedFiles[`${p}/${fPath}`])).filter((fPath) => {\r\n                            // Remove duplicates.\r\n                            const result = !seenMap[fPath];\r\n                            seenMap[fPath] = true;\r\n                            return result;\r\n                        });\r\n                        cb(null, filtered);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        readdirSync(p) {\r\n            this.checkInitialized();\r\n            const dirStats = this.statSync(p, false);\r\n            if (!dirStats.isDirectory()) {\r\n                throw ApiError.ENOTDIR(p);\r\n            }\r\n            // Readdir in both, check delete log on RO file system's listing, merge, return.\r\n            let contents = [];\r\n            try {\r\n                contents = contents.concat(this._writable.readdirSync(p));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            try {\r\n                contents = contents.concat(this._readable.readdirSync(p).filter((fPath) => !this._deletedFiles[`${p}/${fPath}`]));\r\n            }\r\n            catch (e) {\r\n                // NOP.\r\n            }\r\n            const seenMap = {};\r\n            return contents.filter((fileP) => {\r\n                const result = !seenMap[fileP];\r\n                seenMap[fileP] = true;\r\n                return result;\r\n            });\r\n        }\r\n        exists(p, cb) {\r\n            // Cannot pass an error back to callback, so throw an exception instead\r\n            // if not initialized.\r\n            this.checkInitialized();\r\n            this._writable.exists(p, (existsWritable) => {\r\n                if (existsWritable) {\r\n                    return cb(true);\r\n                }\r\n                this._readable.exists(p, (existsReadable) => {\r\n                    cb(existsReadable && this._deletedFiles[p] !== true);\r\n                });\r\n            });\r\n        }\r\n        existsSync(p) {\r\n            this.checkInitialized();\r\n            return this._writable.existsSync(p) || (this._readable.existsSync(p) && this._deletedFiles[p] !== true);\r\n        }\r\n        chmod(p, isLchmod, mode, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chmod(p, isLchmod, mode, cb);\r\n                }\r\n            });\r\n        }\r\n        chmodSync(p, isLchmod, mode) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chmodSync(p, isLchmod, mode);\r\n            });\r\n        }\r\n        chown(p, isLchmod, uid, gid, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.chown(p, isLchmod, uid, gid, cb);\r\n                }\r\n            });\r\n        }\r\n        chownSync(p, isLchown, uid, gid) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.chownSync(p, isLchown, uid, gid);\r\n            });\r\n        }\r\n        utimes(p, atime, mtime, cb) {\r\n            if (!this.checkInitAsync(cb)) {\r\n                return;\r\n            }\r\n            this.operateOnWritableAsync(p, (err) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                else {\r\n                    this._writable.utimes(p, atime, mtime, cb);\r\n                }\r\n            });\r\n        }\r\n        utimesSync(p, atime, mtime) {\r\n            this.checkInitialized();\r\n            this.operateOnWritable(p, () => {\r\n                this._writable.utimesSync(p, atime, mtime);\r\n            });\r\n        }\r\n        deletePath(p) {\r\n            this._deletedFiles[p] = true;\r\n            this.updateLog(`d${p}\\n`);\r\n        }\r\n        updateLog(addition) {\r\n            this._deleteLog += addition;\r\n            if (this._deleteLogUpdatePending) {\r\n                this._deleteLogUpdateNeeded = true;\r\n            }\r\n            else {\r\n                this._deleteLogUpdatePending = true;\r\n                this._writable.writeFile(deletionLogPath, this._deleteLog, 'utf8', FileFlag.getFileFlag('w'), 0o644, (e) => {\r\n                    this._deleteLogUpdatePending = false;\r\n                    if (e) {\r\n                        this._deleteLogError = e;\r\n                    }\r\n                    else if (this._deleteLogUpdateNeeded) {\r\n                        this._deleteLogUpdateNeeded = false;\r\n                        this.updateLog('');\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        _reparseDeletionLog() {\r\n            this._deletedFiles = {};\r\n            this._deleteLog.split('\\n').forEach((path) => {\r\n                // If the log entry begins w/ 'd', it's a deletion.\r\n                this._deletedFiles[path.slice(1)] = path.slice(0, 1) === 'd';\r\n            });\r\n        }\r\n        checkInitialized() {\r\n            if (!this._isInitialized) {\r\n                throw new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\");\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                throw e;\r\n            }\r\n        }\r\n        checkInitAsync(cb) {\r\n            if (!this._isInitialized) {\r\n                cb(new ApiError(ErrorCode.EPERM, \"OverlayProvideris not initialized. Please initialize OverlayProviderusing its initialize() method before using it.\"));\r\n                return false;\r\n            }\r\n            else if (this._deleteLogError !== null) {\r\n                const e = this._deleteLogError;\r\n                this._deleteLogError = null;\r\n                cb(e);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n        checkPath(p) {\r\n            if (p === deletionLogPath) {\r\n                throw ApiError.EPERM(p);\r\n            }\r\n        }\r\n        checkPathAsync(p, cb) {\r\n            if (p === deletionLogPath) {\r\n                cb(ApiError.EPERM(p));\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        createParentDirectoriesAsync(p, cb) {\r\n            let parent = paths.dirname(p);\r\n            const toCreate = [];\r\n            const self = this;\r\n            this._writable.stat(parent, false, statDone);\r\n            function statDone(err, stat) {\r\n                if (err) {\r\n                    if (parent === \"/\") {\r\n                        cb(new ApiError(ErrorCode.EBUSY, \"Invariant failed: root does not exist!\"));\r\n                    }\r\n                    else {\r\n                        toCreate.push(parent);\r\n                        parent = paths.dirname(parent);\r\n                        self._writable.stat(parent, false, statDone);\r\n                    }\r\n                }\r\n                else {\r\n                    createParents();\r\n                }\r\n            }\r\n            function createParents() {\r\n                if (!toCreate.length) {\r\n                    return cb();\r\n                }\r\n                const dir = toCreate.pop();\r\n                self._readable.stat(dir, false, (err, stats) => {\r\n                    // stop if we couldn't read the dir\r\n                    if (!stats) {\r\n                        return cb();\r\n                    }\r\n                    self._writable.mkdir(dir, stats.mode, (err) => {\r\n                        if (err) {\r\n                            return cb(err);\r\n                        }\r\n                        createParents();\r\n                    });\r\n                });\r\n            }\r\n        }\r\n        /**\r\n         * With the given path, create the needed parent directories on the writable storage\r\n         * should they not exist. Use modes from the read-only storage.\r\n         */\r\n        createParentDirectories(p) {\r\n            let parent = paths.dirname(p), toCreate = [];\r\n            while (!this._writable.existsSync(parent)) {\r\n                toCreate.push(parent);\r\n                parent = paths.dirname(parent);\r\n            }\r\n            toCreate = toCreate.reverse();\r\n            toCreate.forEach((p) => {\r\n                this._writable.mkdirSync(p, this.statSync(p, false).mode);\r\n            });\r\n        }\r\n        /**\r\n         * Helper function:\r\n         * - Ensures p is on writable before proceeding. Throws an error if it doesn't exist.\r\n         * - Calls f to perform operation on writable.\r\n         */\r\n        operateOnWritable(p, f) {\r\n            if (this.existsSync(p)) {\r\n                if (!this._writable.existsSync(p)) {\r\n                    // File is on readable storage. Copy to writable storage before\r\n                    // changing its mode.\r\n                    this.copyToWritable(p);\r\n                }\r\n                f();\r\n            }\r\n            else {\r\n                throw ApiError.ENOENT(p);\r\n            }\r\n        }\r\n        operateOnWritableAsync(p, cb) {\r\n            this.exists(p, (exists) => {\r\n                if (!exists) {\r\n                    return cb(ApiError.ENOENT(p));\r\n                }\r\n                this._writable.exists(p, (existsWritable) => {\r\n                    if (existsWritable) {\r\n                        cb();\r\n                    }\r\n                    else {\r\n                        return this.copyToWritableAsync(p, cb);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * Copy from readable to writable storage.\r\n         * PRECONDITION: File does not exist on writable storage.\r\n         */\r\n        copyToWritable(p) {\r\n            const pStats = this.statSync(p, false);\r\n            if (pStats.isDirectory()) {\r\n                this._writable.mkdirSync(p, pStats.mode);\r\n            }\r\n            else {\r\n                this.writeFileSync(p, this._readable.readFileSync(p, null, getFlag('r')), null, getFlag('w'), this.statSync(p, false).mode);\r\n            }\r\n        }\r\n        copyToWritableAsync(p, cb) {\r\n            this.stat(p, false, (err, pStats) => {\r\n                if (err) {\r\n                    return cb(err);\r\n                }\r\n                if (pStats.isDirectory()) {\r\n                    return this._writable.mkdir(p, pStats.mode, cb);\r\n                }\r\n                // need to copy file.\r\n                this._readable.readFile(p, null, getFlag('r'), (err, data) => {\r\n                    if (err) {\r\n                        return cb(err);\r\n                    }\r\n                    this.writeFile(p, data, null, getFlag('w'), pStats.mode, cb);\r\n                });\r\n            });\r\n        }\r\n    }\r\n \r\n\r\n    return UnlockedOverlayProvider;\r\n});\ndefine('skylark-data-files/providers/overlay/overlay-provider',[\r\n    \"skylark-langx-paths\",\r\n    '../../stats',\r\n    '../../file-type',\r\n    '../../file-error',\r\n    '../../error-codes',\r\n    \"../../file-flag\",\r\n    \"../../action-type\",\r\n    \"../locked-provider\",\r\n    \"./unlocked-overlay-provider\"\r\n], function (paths, Stats,FileType,FileError, ErrorCodes, FileFlag,ActionType,LockedProvider,UnlockedOverlayProvider) {\r\n\r\n\r\n    /**\r\n     * OverlayProvidermakes a read-only filesystem writable by storing writes on a second,\r\n     * writable file system. Deletes are persisted via metadata stored on the writable\r\n     * file system.\r\n     */\r\n    class OverlayProvider extends LockedProvider {\r\n        /**\r\n         * @param writable The file system to write modified files to.\r\n         * @param readable The file system that initially populates this file system.\r\n         */\r\n        constructor(writable, readable) {\r\n            super(new UnlockedOverlayProvider(writable, readable));\r\n        }\r\n        /**\r\n         * Constructs and initializes an OverlayProviderinstance with the given options.\r\n         */\r\n        static Create(opts, cb) {\r\n            try {\r\n                const fs = new OverlayProvider(opts.writable, opts.readable);\r\n                fs._initialize((e) => {\r\n                    cb(e, fs);\r\n                });\r\n            }\r\n            catch (e) {\r\n                cb(e);\r\n            }\r\n        }\r\n        static isAvailable() {\r\n            return UnlockedOverlayProvider.isAvailable();\r\n        }\r\n        getOverlayedProviders() {\r\n            return super.getFSUnlocked().getOverlayedProviders();\r\n        }\r\n        unwrap() {\r\n            return super.getFSUnlocked();\r\n        }\r\n        _initialize(cb) {\r\n            super.getFSUnlocked()._initialize(cb);\r\n        }\r\n    }\r\n    OverlayProvider.Name = \"OverlayProvider\";\r\n    OverlayProvider.Options = {\r\n        writable: {\r\n            type: \"object\",\r\n            description: \"The file system to write modified files to.\"\r\n        },\r\n        readable: {\r\n            type: \"object\",\r\n            description: \"The file system that initially populates this file system.\"\r\n        }\r\n    };\r\n\r\n    return OverlayProvider;\r\n});\ndefine('skylark-data-files/main',[\r\n\t\"./files\",\r\n\t\"./action-type\",\r\n\t\"./base-file\",\r\n\t\"./error-codes\",\r\n\t\"./error-strings\",\r\n\t\"./file-error\",\r\n\t\"./file-flag\",\r\n\t\"./file-system\",\r\n\t\"./no-sync-file\",\r\n\t\"./preload-file\",\r\n\t\"./stats\",\r\n\t\"./configure\",\r\n\t\"./providers/dropbox/dropbox-provider\",\r\n\t\"./providers/html5/html5-lfs-provider\",\r\n\t\"./providers/http/http-provider\",\r\n\t\"./providers/indexeddb/indexed-db-provider\",\r\n\t\"./providers/inmemory/in-memory-provider\",\r\n\t\"./providers/localstorage/local-storage-provider\",\r\n\t\"./providers/overlay/overlay-provider\"\r\n\r\n],function(files){\r\n\treturn files;\r\n});\ndefine('skylark-data-files', ['skylark-data-files/main'], function (main) { return main; });\n\n"]}